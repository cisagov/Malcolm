########################
# parsing of logs/metrics specific to the operation of
#   Malcolm and Hedgehog Linux itself (i.e., not captured
#   network traffic metadata, but operational metadata)
#
# Copyright (c) 2025 Battelle Energy Alliance, LLC.  All rights reserved.
#######################

filter {

  # move a couple of things identifying the event source from under miscbeat up to the top level
  if ([miscbeat][message][module]) and (![miscbeat][module])  {
    # special case to handle fluent-bit -> fluentd.loomsystems -> filebeat TCP input
    #   move entire "message" contents up to root
    # https://github.com/idaholab/Malcolm/issues/318
    ruby {
        id => "ruby_miscbeat_message_move_up"
        code => "
            event.get('[miscbeat][message]').each { |k, v|
                event.set('[miscbeat][' + k + ']', v)
            }
            event.remove('[miscbeat][message]')
        "
    }
  }
  if ([miscbeat][host]) {
    ruby {
      id => "ruby_miscbeat_host_merge"
      path => "/usr/share/logstash/malcolm-ruby/hash_merge.rb"
      script_params => {
        "source" => "[miscbeat][host]"
        "target" => "[host]"
      }
      remove_field => [ "[miscbeat][host]" ]
    }
  }
  if ([miscbeat][agent]) {
    ruby {
      id => "ruby_miscbeat_agent_merge"
      path => "/usr/share/logstash/malcolm-ruby/hash_merge.rb"
      script_params => {
        "source" => "[miscbeat][agent]"
        "target" => "[agent]"
      }
      remove_field => [ "[miscbeat][agent]" ]
    }
  }

  if (![host][name]) and ([agent][hostname]) {
    mutate { id => "mutate_beats_add_field_host_name_agent_hostname"
             add_field => { "[host][name]" => "%{[agent][hostname]}" } }
  }

  if ([agent][type] == "filebeat") and ([event][module] == "nginx") {
    #############################################################################################################################
    # nginx access and error logs

    # parse log fields
    if ([event][dataset] == "nginx.access") {
      grok {
        id => "grok_beat_nginx_access"
        patterns_dir => "/usr/share/logstash/malcolm-patterns"
        match => { "[event][original]" => "%{NGINX_ACCESS}" }
      }
    }
    if ([event][dataset] == "nginx.error") {
      grok {
        id => "grok_beat_nginx_error"
        patterns_dir => "/usr/share/logstash/malcolm-patterns"
        match => { "[event][original]" => "%{NGINX_ERROR}" }
      }
    }

    # save nginx log timestamp over @timestamp
    if ([timestamp]) {
      date {
        id => "date_beats_nginx_timestamp"
        match => [ "[timestamp]", "dd/MMM/yyyy:HH:mm:ss Z", "yyyy/MM/dd HH:mm:ss" ]
        target => "[@timestamp]"
        remove_field => [ "[timestamp]" ]
      }
    }

    # set agent.type to "nginx"
    mutate { id => "mutate_replace_agent_type_beats_filebeat_nginx"
             replace => { "[agent][type]" => "nginx" } }

  } else if ("_malcolm_miscbeat" in [tags]) or ([miscbeat]) {
    #############################################################################################################################
    # misc. sensor metrics and logs from fluentbit received by filebeat TCP input
    # https://docs.fluentbit.io/manual/
    # https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-tcp.html

    # set event.module to whatever we set "module" to when running fluentbit
    if ([miscbeat][module]) {
      mutate { id => "mutate_replace_event_module_miscbeat_module"
               replace => { "[event][module]" => "%{[miscbeat][module]}" }
               remove_field => [ "[miscbeat][module]" ] }
    }

    # convert fluentbit's date field and save it to @timestamp
    if ([miscbeat][date]) {
      date {
        id => "date_beats_miscbeat_date"
        match => [ "[miscbeat][date]", "UNIX" ]
        target => "[@timestamp]"
        remove_field => [ "[miscbeat][date]" ]
      }
    }

    if ([miscbeat][aide]) {
      #-------------------------------------------------
      # fluentbit exec of AIDE
      # https://aide.github.io/

      # parse AIDE run start_time and end_time
      if ([miscbeat][aide][start_time]) {
        date {
          id => "date_beats_miscbeat_aide_start_time"
          match => [ "[miscbeat][aide][start_time]", "yyyy-MM-dd HH:mm:ss Z" ]
          target => "[miscbeat][aide][start_time]"
        }
      }
      if ([miscbeat][aide][end_time]) {
        date {
          id => "date_beats_miscbeat_aide_end_time"
          match => [ "[miscbeat][aide][end_time]", "yyyy-MM-dd HH:mm:ss Z" ]
          target => "[miscbeat][aide][end_time]"
        }
      }

      # set action (changed, added, removed files/directories)
      ruby {
          id => "ruby_miscbeat_aide_action"
          code => "
            actions = Array.new
            actions.push('add') if (event.get('[miscbeat][aide][number_of_entries][added]').to_i > 0)
            actions.push('change') if (event.get('[miscbeat][aide][number_of_entries][changed]').to_i > 0)
            actions.push('remove') if (event.get('[miscbeat][aide][number_of_entries][removed]').to_i > 0)
            event.set('[event][action]', actions) unless (actions.length == 0)
          "
      }

      # convert hash of hashes to arrays of hashes so we don't end up creating a new
      # dynamically-mapped field for every single file/directory
      if ([miscbeat][aide][details]) {
        ruby {
          id => "ruby_miscbeat_aide_details_hashform"
          path => "/usr/share/logstash/malcolm-ruby/hashhash_to_hasharray.rb"
          script_params => {
            "source" => "[miscbeat][aide][details]"
            "target_hash_array" => "[miscbeat][aide][details]"
            "target_keys_array" => "[file][path]"
            "name_key" => "path"
          }
        }
      }
      if ([miscbeat][aide][databases]) {
        ruby {
          id => "ruby_miscbeat_aide_databases_hashform"
          path => "/usr/share/logstash/malcolm-ruby/hashhash_to_hasharray.rb"
          script_params => {
            "source" => "[miscbeat][aide][databases]"
            "target_hash_array" => "[miscbeat][aide][databases]"
            "name_key" => "path"
          }
        }
      }
      if ([miscbeat][aide][added]) {
        ruby {
          id => "ruby_miscbeat_aide_added_to_array"
          path => "/usr/share/logstash/malcolm-ruby/hashhash_to_hasharray.rb"
          script_params => {
            "source" => "[miscbeat][aide][added]"
            "target_keys_array" => "[miscbeat][aide][added]"
          }
        }
      }
      if ([miscbeat][aide][changed]) {
        ruby {
          id => "ruby_miscbeat_aide_changed_to_array"
          path => "/usr/share/logstash/malcolm-ruby/hashhash_to_hasharray.rb"
          script_params => {
            "source" => "[miscbeat][aide][changed]"
            "target_keys_array" => "[miscbeat][aide][changed]"
          }
        }
      }
      if ([miscbeat][aide][removed]) {
        ruby {
          id => "ruby_miscbeat_aide_removed_to_array"
          path => "/usr/share/logstash/malcolm-ruby/hashhash_to_hasharray.rb"
          script_params => {
            "source" => "[miscbeat][aide][removed]"
            "target_keys_array" => "[miscbeat][aide][removed]"
          }
        }
      }

      # merge file.path to contain all related file names/paths
      ruby {
        id => "ruby_miscbeat_aide_merge_paths"
        code => "
          paths = event.get('[file][path]').to_a +
                  event.get('[miscbeat][aide][added]').to_a +
                  event.get('[miscbeat][aide][changed]').to_a +
                  event.get('[miscbeat][aide][removed]').to_a
          event.set('[file][path]', paths.uniq.flatten.reject{ |e| e.nil? || e&.empty? }) unless (paths.length == 0)
        "
      }

      # rename miscbeat.aide.outline to event.result and translate clunky result messages
      if ([miscbeat][aide][outline]) {
        mutate { id => "mutate_rename_miscbeat_aide_outline"
                 rename => { "[miscbeat][aide][outline]" => "[event][result]" } }
        if ([event][result] =~ /^AIDE found NO differences/) {
          mutate { id => "mutate_replace_miscbeat_aide_result_no_differences"
                   replace => { "[event][result]" => "Success" } }
        } else if ([event][result] =~ /^AIDE found differences/) {
          mutate { id => "mutate_replace_miscbeat_aide_result_differences"
                   replace => { "[event][result]" => "Failure" } }
        }
      }

      # generate unique ID
      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_aide"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][aide][number_of_entries][total]",
                      "[miscbeat][aide][number_of_entries][added]",
                      "[miscbeat][aide][number_of_entries][removed]",
                      "[miscbeat][aide][number_of_entries][changed]",
                      "[event][result]",
                      "[miscbeat][aide][start_time]",
                      "[miscbeat][aide][end_time]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][aide])

    if ([miscbeat][auditlog]) {
      #-------------------------------------------------
      # fluentbit tail of /var/log/audit/audit.log
      # https://man7.org/linux/man-pages/man5/auditd.conf.5.html

      ruby {
        id => "ruby_miscbeat_auditlog_remove_empty_values"
        path => "/usr/share/logstash/malcolm-ruby/compact_event.rb"
      }

      if ([miscbeat][auditlog][grantors]) {
        mutate { id => "mutate_split_miscbeat_auditlog_grantors"
                 split => { "[miscbeat][auditlog][grantors]" => "," } }
      }

      if (![miscbeat][auditlog][success]) and
         ([miscbeat][auditlog][res] =~ /^success'?$/) {
        mutate { id => "mutate_miscbeat_auditlog_res_success"
                 add_field => { "[miscbeat][auditlog][success]" => "yes" }
                 remove_field => [ "[miscbeat][auditlog][res]" ] }
      }

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_auditlog"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][auditlog][ses]",
                      "[miscbeat][auditlog][type]",
                      "[miscbeat][auditlog][SYSCALL]",
                      "[miscbeat][auditlog][acct]",
                      "[miscbeat][auditlog][UID]",
                      "[miscbeat][auditlog][exe]",
                      "[miscbeat][auditlog][msg]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][auditlog])

    if ([miscbeat][kmsg]) {
      #-------------------------------------------------
      # kmsg - https://docs.fluentbit.io/manual/pipeline/inputs/kernel-logs
      mutate { id => "mutate_rename_miscbeat_kmsg"
               rename => { "[miscbeat][kmsg][msg]" => "[event][original]" } }

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_kmsg"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][kmsg][sequence]",
                      "[miscbeat][kmsg][priority]",
                      "[event][original]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][kmsg])

    if ([miscbeat][cpu]) {
      #-------------------------------------------------
      # cpu - https://docs.fluentbit.io/manual/pipeline/inputs/cpu-metrics

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_cpu"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][cpu][cpu_p]",
                      "[miscbeat][cpu][system_p]",
                      "[miscbeat][cpu][user_p]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][cpu])

    if ([miscbeat][mem]) {
      #-------------------------------------------------
      # mem - https://docs.fluentbit.io/manual/pipeline/inputs/memory-metrics

      if (![event][hash]) {

        if ([miscbeat][mem][Mem][used]) {
          fingerprint {
            id => "fingerprint_malcolm_miscbeat_mem_total"
            source => [ "[host][name]",
                        "[event][module]",
                        "[miscbeat][mem][Mem][used]",
                        "[miscbeat][mem][Mem][free]",
                        "[miscbeat][mem][Mem][total]",
                        "[@timestamp]" ]
            concatenate_sources => true
            # uses event.hash
            ecs_compatibility => "v8"
            method => "MURMUR3_128"
            base64encode => true
          }
        } else if ([miscbeat][mem][Mem][used_p]) {
          fingerprint {
            id => "fingerprint_malcolm_miscbeat_mem_used_p"
            source => [ "[host][name]",
                        "[event][module]",
                        "[miscbeat][mem][Mem][used_p]",
                        "[@timestamp]" ]
            concatenate_sources => true
            # uses event.hash
            ecs_compatibility => "v8"
            method => "MURMUR3_128"
            base64encode => true
          }
        }
      }

    } # if ([miscbeat][mem])

    if ([miscbeat][disk]) {
      #-------------------------------------------------
      # disk - https://docs.fluentbit.io/manual/pipeline/inputs/disk-io-metrics

      if ([miscbeat][disk][df][details]) {
        ruby {
          id => "ruby_miscbeat_disk_df_sum"
          code => "
            if dfentries = event.get('[miscbeat][disk][df][details]') then
              size, used, avail = 0, 0, 0
              dfentries.each do |dfentry|
                size = size + dfentry.dig('size').to_i
                used = used + dfentry.dig('used').to_i
                avail = avail + dfentry.dig('avail').to_i
              end
              event.set('[miscbeat][disk][df][size]', size)
              event.set('[miscbeat][disk][df][used]', used)
              event.set('[miscbeat][disk][df][avail]', avail)
            end"
        }
      }

      if (![event][hash]) {

        if ([miscbeat][disk][read_size]) and ([miscbeat][disk][write_size]) {
          fingerprint {
            id => "fingerprint_malcolm_miscbeat_disk_read_write"
            source => [ "[host][name]",
                        "[event][module]",
                        "[miscbeat][disk][read_size]",
                        "[miscbeat][disk][write_size]",
                        "[@timestamp]" ]
            concatenate_sources => true
            # uses event.hash
            ecs_compatibility => "v8"
            method => "MURMUR3_128"
            base64encode => true
          }
        } else {
          fingerprint {
            id => "fingerprint_malcolm_miscbeat_disk"
            source => [ "[host][name]",
                        "[event][module]",
                        "[miscbeat][disk][df][size]",
                        "[miscbeat][disk][df][used]",
                        "[miscbeat][disk][df][avail]",
                        "[@timestamp]" ]
            concatenate_sources => true
            # uses event.hash
            ecs_compatibility => "v8"
            method => "MURMUR3_128"
            base64encode => true
          }
        }
      } # ![event][hash]

    } # if ([miscbeat][disk])

    if ([miscbeat][network]) {
      #-------------------------------------------------
      # not using fluent-bit netif input, rolled my own with /proc/net/dev and jq

      mutate { id => "mutate_rename_miscbeat_network_interfaces"
               rename => { "[miscbeat][network][interfaces]" => "[miscbeat][network][details]" } }
      ruby {
        id => "ruby_miscbeat_network_details_sum"
        code => "
          if interfaces = event.get('[miscbeat][network][details]') then
            bytes_tx, bytes_rx, packets_tx, packets_rx, errors_tx, errors_rx, drop_tx, drop_rx = 0, 0, 0, 0, 0, 0, 0, 0
            interfaces.each do |key, value|
              bytes_tx = bytes_tx + value.dig('tx_bytes').to_i
              bytes_rx = bytes_rx + value.dig('rx_bytes').to_i
              packets_tx = packets_tx + value.dig('tx_packets').to_i
              packets_rx = packets_rx + value.dig('rx_packets').to_i
              errors_tx = errors_tx + value.dig('tx_errs').to_i
              errors_rx = errors_rx + value.dig('rx_errs').to_i
              drop_tx = drop_tx + value.dig('tx_drop').to_i
              drop_rx = drop_rx + value.dig('rx_drop').to_i
            end
            event.set('[miscbeat][network][interface]', interfaces.keys)
            event.set('[miscbeat][network][bytes][tx]', bytes_tx)
            event.set('[miscbeat][network][bytes][rx]', bytes_rx)
            event.set('[miscbeat][network][bytes][total]', bytes_tx+bytes_rx)
            event.set('[miscbeat][network][packets][tx]', packets_tx)
            event.set('[miscbeat][network][packets][rx]', packets_rx)
            event.set('[miscbeat][network][packets][total]', packets_tx+packets_rx)
            event.set('[miscbeat][network][errors][tx]', errors_tx)
            event.set('[miscbeat][network][errors][rx]', errors_rx)
            event.set('[miscbeat][network][errors][total]', errors_tx+errors_rx)
            event.set('[miscbeat][network][drops][tx]', drop_tx)
            event.set('[miscbeat][network][drops][rx]', drop_rx)
            event.set('[miscbeat][network][drops][total]', drop_tx+drop_rx)
          end"
          remove_field => [ "[miscbeat][network][details]" ]
       }

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_network"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][network][bytes][total]",
                      "[miscbeat][network][packets][total]",
                      "[miscbeat][network][errors][total]",
                      "[miscbeat][network][drops][total]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][network])

    if ([miscbeat][proc]) {
      #-------------------------------------------------
      # proc - https://docs.fluentbit.io/manual/pipeline/inputs/process

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_proc"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][proc][proc_name]",
                      "[miscbeat][proc][pid]",
                      "[miscbeat][proc][fd]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][proc])

    if ([miscbeat][syslog]) {
      #-------------------------------------------------
      # syslog via fluent-bit - https://docs.fluentbit.io/manual/pipeline/inputs/syslog

      # time gets parsed into the miscbeat.date field, this is redundant
      mutate { id => "mutate_miscbeat_remove_syslog_time"
               remove_field => [ "[miscbeat][syslog][time]" ] }

      # rename syslog fields according to ECS
      # https://www.elastic.co/guide/en/ecs/current/ecs-log.html#field-log-syslog
      mutate { id => "mutate_rename_miscbeat_syslog"
               rename => { "[miscbeat][syslog][ident]" => "[log][syslog][appname]" }
               rename => { "[miscbeat][syslog][pid]" => "[log][syslog][procid]" }
               rename => { "[miscbeat][syslog][pri]" => "[log][syslog][priority]" }
               rename => { "[miscbeat][syslog][message]" => "[event][original]" }
               rename => { "[miscbeat][syslog][host]" => "[log][syslog][hostname]" }
      }

      # convert syslog "priority" number to "severity" and "facility" and map to human-readable names
      if ([log][syslog][priority]) {
        ruby {
          id => "ruby_log_syslog_priority_convert"
          code => "
            if pri = event.get('[log][syslog][priority]').to_i then
              event.set('[log][syslog][severity][code]', pri % 8)
              event.set('[log][syslog][facility][code]', pri / 8)
            end"
        }
        if ([log][syslog][severity][code]) {
          translate {
            id => "translate_sensor_syslog_severity_code"
            source => "[log][syslog][severity][code]"
            target => "[log][syslog][severity][name]"
            dictionary_path => "/etc/syslog_severity_levels.yaml"
          }
        }
        if ([log][syslog][facility][code]) {
          translate {
            id => "translate_sensor_syslog_facility_code"
            source => "[log][syslog][facility][code]"
            target => "[log][syslog][facility][name]"
            dictionary_path => "/etc/syslog_facility_codes.yaml"
          }
        }
      }

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_syslog"
          source => [ "[host][name]",
                      "[event][module]",
                      "[log][syslog][severity][code]",
                      "[log][syslog][facility][code]",
                      "[log][syslog][appname]",
                      "[event][original]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][syslog])

    if ([miscbeat][systemd]) {
     #-------------------------------------------------
     # systemd - https://docs.fluentbit.io/manual/pipeline/inputs/systemd
     # see also - https://www.freedesktop.org/software/systemd/man/latest/systemd.journal-fields.html

      if ([miscbeat][systemd][source_realtime_timestamp]) {
        # microseconds to milliseconds
        ruby {
          id => "ruby_miscbeat_systemd_source_realtime_timestamp_calc"
          code => "
            event.set('[miscbeat][systemd][source_realtime_timestamp]',
                      (event.get('[miscbeat][systemd][source_realtime_timestamp]').to_i / 1000))
          "
        }
        # milliseconds to date
        date {
          id => "date_beats_miscbeat_systemd_source_realtime_timestamp"
          match => [ "[miscbeat][systemd][source_realtime_timestamp]", "UNIX_MS" ]
          target => "[miscbeat][systemd][source_realtime_timestamp]"
        }
      }

      # rename fields according to ECS
      # https://www.elastic.co/guide/en/ecs/current/ecs-process.html
      # https://www.elastic.co/guide/en/ecs/current/ecs-log.html
      mutate { id => "mutate_rename_miscbeat_systemd_log_fields"
               # todo: translate this to CAP_BPF, CAP_SYS_ADMIN, etc.
               rename => { "[miscbeat][systemd][cap_effective]" => "[process][thread][capabilities][effective]" }
               rename => { "[miscbeat][systemd][cmdline]" => "[process][command_line]" }
               rename => { "[miscbeat][systemd][code_file]" => "[log][origin][file][name]" }
               rename => { "[miscbeat][systemd][code_func]" => "[log][origin][function]" }
               rename => { "[miscbeat][systemd][code_line]" => "[log][origin][file][line]" }
               rename => { "[miscbeat][systemd][comm]" => "[process][name]" }
               rename => { "[miscbeat][systemd][exe]" => "[process][executable]" }
               rename => { "[miscbeat][systemd][gid]" => "[process][group_leader][pid]" }
               rename => { "[miscbeat][systemd][pid]" => "[process][pid]" }
               rename => { "[miscbeat][systemd][syslog_facility]" => "[log][syslog][facility][code]" }
               rename => { "[miscbeat][systemd][syslog_identifier]" => "[log][syslog][appname]" }
               rename => { "[miscbeat][systemd][syslog_pid]" => "[log][syslog][procid]" }
               rename => { "[miscbeat][systemd][systemd_owner_uid]" => "[process][real_user][id]" }
               rename => { "[miscbeat][systemd][tid]" => "[process][thread][id]" }
               rename => { "[miscbeat][systemd][uid]" => "[process][user][id]" }
               rename => { "[miscbeat][systemd][transport]" => "[log][logger]" }
      }
      if ([log][syslog][facility][code]) {
        translate {
          id => "translate_sensor_systemd_syslog_facility_code"
          source => "[log][syslog][facility][code]"
          target => "[log][syslog][facility][name]"
          dictionary_path => "/etc/syslog_facility_codes.yaml"
        }
      }

      # store raw message text as event.original
      if ([miscbeat][systemd][syslog_raw]) {
        mutate { id => "mutate_rename_miscbeat_systemd_syslog_raw"
                 rename => { "[miscbeat][systemd][syslog_raw]" => "[event][original]" } }
      } else if ([miscbeat][systemd][message]) {
        mutate { id => "mutate_rename_miscbeat_systemd_message"
                 rename => { "[miscbeat][systemd][message]" => "[event][original]" } }
      }

      #
      if ([miscbeat][systemd][errno]) {
        mutate { id => "mutate_rename_miscbeat_systemd_errno"
                 rename => { "[miscbeat][systemd][errno]" => "[event][result]" } }
      }

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_systemd"
          source => [ "[host][name]",
                      "[event][module]",
                      "[process][pid]",
                      "[process][user][id]",
                      "[process][thread][id]",
                      "[process][group_leader][pid]",
                      "[miscbeat][systemd][unit]",
                      "[miscbeat][systemd][comm]",
                      "[miscbeat][systemd][exe]",
                      "[miscbeat][systemd][cmdline]",
                      "[miscbeat][systemd][machine_id]",
                      "[event][original]",
                      "[miscbeat][systemd][message_id]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][systemd])

    if ([miscbeat][thermal]) {
    #-------------------------------------------------
    # thermal - https://docs.fluentbit.io/manual/pipeline/inputs/thermal

      if ([miscbeat][thermal][temp]) {
        # don't bother saving 0.0 temperatures
        ruby { id => "ruby_miscbeat_thermal_temp_drop_zeroes"
               code=> "event.cancel unless event.get('[miscbeat][thermal][temp]')&.nonzero?" }
      }

    } # if ([miscbeat][thermal])

    # merge winevtlog and winlog (from fluent-bit)
    if ([miscbeat][winevtlog]) or ([miscbeat][winlog]) {

      ruby {
        id => "ruby_winlog_remove_empty_values"
        path => "/usr/share/logstash/malcolm-ruby/compact_event.rb"
      }

      # save event.module to agent.type before we replace it
      mutate { id => "mutate_replace_agent_type_beats_fluentbit_winlog"
               replace => { "[agent][type]" => "%{[event][module]}" } }

      mutate { id => "mutate_add_field_os_family_winlog"
               add_field => { "[os][family]" => "windows" } }
      mutate { id => "mutate_add_field_os_type_winlog"
               add_field => { "[os][type]" => "windows" } }
      mutate { id => "mutate_replace_fluentbit_winlog_event_module"
               replace => { "[event][module]" => "winlog" } }

      if ([miscbeat][winevtlog]) {
        if ([miscbeat][winevtlog][Level]) {
          translate {
            id => "translate_miscbeat_winevtlog_level_to_eventtype"
            source => "[miscbeat][winevtlog][Level]"
            target => "[miscbeat][winevtlog][EventType]"
            dictionary_path => "/etc/winlog_levels_to_name.yaml"
          }
        }
        mutate { id => "mutate_rename_miscbeat_winevtlog_winlog_ecs"
                 rename => { "[miscbeat][winevtlog]" => "[winlog]" } }

      } else if ([miscbeat][winlog]) {
          mutate { id => "mutate_rename_miscbeat_winlog_winlog_ecs"
                   rename => { "[miscbeat][winlog]" => "[winlog]" } }
      }

      if ([winlog][EventType]) and (![winevtlog][Level]) {
        translate {
          id => "translate_winlog_eventtype_to_level"
          source => "[winlog][EventType]"
          target => "[winlog][Level]"
          dictionary_path => "/etc/winlog_levels_to_numbers.yaml"
        }
      }

      mutate { id => "mutate_rename_fluentbit_winlog"
               rename => { "[winlog][ActivityID]" => "[winlog][activity_id]" }
               rename => { "[winlog][Computer]" => "[winlog][computer_name]" }
               rename => { "[winlog][Channel]" => "[winlog][channel]" }
               rename => { "[winlog][Data]" => "[winlog][data]" }
               rename => { "[winlog][ComputerName]" => "[winlog][computer_name]" }
               rename => { "[winlog][EventCategory]" => "[winlog][task]" }
               rename => { "[winlog][EventID]" => "[winlog][event_id]" }
               rename => { "[winlog][EventRecordID]" => "[winlog][record_id]" }
               rename => { "[winlog][EventType]" => "[log][level]" }
               rename => { "[winlog][Keywords]" => "[winlog][keywords]" }
               rename => { "[winlog][Level]" => "[winlog][level]" }
               rename => { "[winlog][Message]" => "[event][original]" }
               rename => { "[winlog][Opcode]" => "[winlog][opcode]" }
               rename => { "[winlog][Qualifiers]" => "[winlog][qualifiers]" }
               rename => { "[winlog][ProcessID]" => "[winlog][process][pid]" }
               rename => { "[winlog][ProviderGuid]" => "[winlog][provider_guid]" }
               rename => { "[winlog][ProviderName]" => "[winlog][provider_name]" }
               rename => { "[winlog][RelatedActivityID]" => "[winlog][related_activity_id]" }
               rename => { "[winlog][Sid]" => "[winlog][sid]" }
               rename => { "[winlog][StringInserts]" => "[winlog][string_inserts]" }
               rename => { "[winlog][SourceName]" => "[winlog][provider_name]" }
               rename => { "[winlog][Task]" => "[winlog][task]" }
               rename => { "[winlog][ThreadID]" => "[winlog][process][thread][id]" }
               rename => { "[winlog][TimeCreated]" => "[winlog][time_created]" }
               rename => { "[winlog][TimeGenerated]" => "[winlog][time_created]" }
               rename => { "[winlog][TimeWritten]" => "[winlog][time_written]" }
               rename => { "[winlog][UserID]" => "[winlog][user][identifier]" }
               rename => { "[winlog][Version]" => "[winlog][version]" }
      }

      if ([winlog][EventType]) {
        mutate { id => "mutate_merge_winlog_eventtype_result"
                 merge => { "[event][result]" => "[winlog][EventType]" } }
      }

      if ([winlog][time_created]) {
        date {
          id => "date_fluentbit_winlog_time_created"
          match => [ "[winlog][time_created]", "yyyy-MM-dd HH:mm:ss Z" ]
          target => "[winlog][time_created]"
        }
      }
      if ([winlog][time_written]) {
        date {
          id => "date_fluentbit_winlog_time_written"
          match => [ "[winlog][time_written]", "yyyy-MM-dd HH:mm:ss Z" ]
          target => "[winlog][time_written]"
        }
      }

      # generate unique ID
      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_fluentbit_winlog"
          source => [ "[winlog][computer_name]",
                      "[agent][type]",
                      "[winlog][channel]",
                      "[winlog][provider_name]",
                      "[winlog][event_id]",
                      "[winlog][record_id]",
                      "[event][original]",
                      "[winlog][time_created]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # ([winevtlog]) or ([winlog])

    if ([miscbeat][winstat]) {

      mutate { id => "mutate_rename_fluentbit_miscbeat_winstat"
               rename => { "[miscbeat][winstat]" => "[winstat]" } }

      # generate unique ID
      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_fluentbit_winstat"
          source => [ "[host][name]",
                      "[event][module]",
                      "[winstat][cpu_kernel]",
                      "[winstat][cpu_user]",
                      "[winstat][kernel_paged]",
                      "[winstat][kernel_nonpaged]",
                      "[winstat][physical_used]",
                      "[winstat][physical_available]",
                      "[winstat][processes]",
                      "[winstat][uptime_msec]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # [miscbeat][winstat]

  } else if ([agent][type] == "winlogbeat") and ([winlog]) {
    #-------------------------------------------------
    # Winlogbeat - https://www.elastic.co/guide/en/beats/winlogbeat/current/_winlogbeat_overview.html
    # Normalize to match evtx upload and fluentbit windows event logs

    ruby {
      id => "ruby_winlogbeat_remove_empty_values"
      path => "/usr/share/logstash/malcolm-ruby/compact_event.rb"
      script_params => {
        "discard_zeroes" => "true"
      }
    }

    mutate { id => "mutate_replace_winlogbeat_event_module"
             replace => { "[event][module]" => "winlog" } }

    mutate { id => "mutate_add_field_os_family_winlogbeat"
             add_field => { "[os][family]" => "windows" } }
    mutate { id => "mutate_add_field_os_type_winlogbeat"
             add_field => { "[os][type]" => "windows" } }

    if ([log][level]) {
      translate {
        id => "translate_winlogbeat_log_levelcase"
        source => "[log][level]"
        target => "[log][level]"
        dictionary => {
          "error" => "Error"
          "failureaudit" => "FailureAudit"
          "information" => "Information"
          "successaudit" => "SuccessAudit"
          "warning" => "Warning"
        }
      }
      mutate { id => "mutate_merge_winlogbeat_log_level_to_result"
               merge => { "[event][result]" => "[log][level]" } }
      if (![winlog][level]) {
        translate {
          id => "translate_winlogbeat_to_level"
          source => "[log][level]"
          target => "[winlog][level]"
          dictionary_path => "/etc/winlog_levels_to_numbers.yaml"
        }
      }
    }

    if ([winlog][time_created]) {
      date { id => "date_winlogbeat_time_created"
             match => [ "[winlog][time_created]", "yyyy-MM-dd HH:mm:ss Z" ]
             target => "[winlog][time_created]" }
    }

    # generate unique ID
    if (![event][hash]) {
      fingerprint {
        id => "fingerprint_malcolm_winlogbeat"
        source => [ "[winlog][computer_name]",
                    "[agent][type]",
                    "[winlog][channel]",
                    "[winlog][provider_name]",
                    "[winlog][event_id]",
                    "[winlog][record_id]",
                    "[event][original]",
                    "[winlog][time_created]" ]
        concatenate_sources => true
        # uses event.hash
        ecs_compatibility => "v8"
        method => "MURMUR3_128"
        base64encode => true
      }
    }


  } else if ([agent][type] == "filebeat") and ([log][syslog]) {
    #-------------------------------------------------
    # syslog direct to Malcolm - https://www.elastic.co/guide/en/beats/filebeat/current/syslog.html

    mutate { id => "mutate_replace_syslog_direct_event_module"
             replace => { "[event][module]" => "syslog" } }

    # store the originating host name as host.name as it's probably what people will want to search by
    if ([log][syslog][hostname]) { mutate { id => "mutate_syslog_direct_replace_hostname"
                                            replace => { "[host][name]" => "%{[log][syslog][hostname]}" }
                                            remove_field => [ "[hostname]" ] } }

    if (![event][hash]) {
      fingerprint {
        id => "fingerprint_malcolm_miscbeat_syslog_direct"
        source => [ "[host][name]",
                    "[event][module]",
                    "[log][syslog][severity][code]",
                    "[log][syslog][facility][code]",
                    "[log][syslog][appname]",
                    "[event][original]",
                    "[@timestamp]" ]
        concatenate_sources => true
        # uses event.hash
        ecs_compatibility => "v8"
        method => "MURMUR3_128"
        base64encode => true
      }
    }

  } else if ("_zeekdiagnostic" in [tags]) {
    #-------------------------------------------------
    # Zeek diagnostic logs
    # https://docs.zeek.org/en/master/script-reference/log-files.html#zeek-diagnostics

    if ([zeek][stats]) {
      # remove zero values from zeek stats
      ruby {
        id => "ruby_zeek_remove_zero_stats"
        path => "/usr/share/logstash/malcolm-ruby/compact_event_hash.rb"
        script_params => {
          "field" => "[zeek][stats]"
          "discard_zeroes" => "true"
        }
      }
    }

    mutate { id => "mutate_add_field_event_module_zeek_diagnostic"
             add_field => { "[event][module]" => "zeek" } }

    mutate { id => "mutate_remove_fields_zeek_diagnostic"
             remove_field => [ "[event][original]",
                               "[firstPacket]",
                               "[lastPacket]",
                               "[timestamp]",
                               "[zeek][ts]",
                               "[length]",
                               "[event][duration]" ] }

  } else if ("_suricatastats" in [tags]) {
    #-------------------------------------------------
    # Suricata statistics
    # https://docs.suricata.io/en/suricata-6.0.2/configuration/suricata-yaml.html#stats

    # sum packet drops into suricata.stats.pkts_dropped
    ruby {
      id => "ruby_miscbeat_suricata_stats_pkts_dropped"
      code => "
        pkts_dropped = event.get('[suricata][stats][capture][kernel_drops]').to_i +
                       event.get('[suricata][stats][tcp][segment_memcap_drop]').to_i +
                       event.get('[suricata][stats][tcp][ssn_memcap_drop]').to_i
        event.set('[suricata][stats][pkts_dropped]', pkts_dropped) unless (pkts_dropped == 0)
      "
     }

    if ([suricata][stats]) {
      # remove zero values from suricata stats
      ruby {
        id => "ruby_suricata_remove_zero_stats"
        path => "/usr/share/logstash/malcolm-ruby/compact_event_hash.rb"
        script_params => {
          "field" => "[suricata][stats]"
          "discard_zeroes" => "true"
        }
      }
    }

    mutate { id => "mutate_add_field_event_module_suricata_stats"
             add_field => { "[event][module]" => "suricata" } }

    mutate { id => "mutate_remove_fields_suricata_stats"
             remove_field => [ "[event][original]",
                               "[firstPacket]",
                               "[lastPacket]",
                               "[timestamp]",
                               "[suricata][timestamp]",
                               "[length]",
                               "[event][duration]" ] }

  } else if ("_evtx_to_json" in [tags]) {
    # massage evtx-formatted (https://github.com/omerbenamram/evtx) logs
    #   to match the winevtlog and winlog messages (from winlogbeat) as above

    # - Tags may have been specified, like: blahblah(tagA,tagB,tagC).log, extract them
    ruby {
      id => "ruby_evxt_tags_extract"
      #                                                                       ↓Prefix (discard)
      #                                                                                   ↓Tags   ↓Rotate Timestamp (discard)                                        ↓.evtx.json (discard)
      code => "
        if fileParts = event.get('[log][file][path]').split('/').last.match(/^(?:.*?)(?:\((.*)\))?(?:\.\d{4}[_:-]?\d{2}[_:-]?\d{2}[_:-]?\d{2}[_:-]?\d{2}[_:-]?\d{2})?\.evtx\.json/i) then
          filenameTags = fileParts.captures[0].split(',')
          nbsiteid = filenameTags.find { |str| str[/NBSITEID(.+)/] }[/NBSITEID(.+)/, 1].to_s rescue nil
          filenameTags.delete_if{|v| ((v == nil) or (v == '')  or (v !~ /\D/) or (v =~ /\A\s*NBSITEID/) or (v =~ /\A\s*(evtx|json)s?\s*\z/i))}
          event.set('[@metadata][evtx_log_tags]', filenameTags.uniq) unless (filenameTags.length == 0)
          event.set('[@metadata][nbsiteid]', nbsiteid) unless (nbsiteid.nil? || nbsiteid.empty?)
        end"
    }
    if ([@metadata][evtx_log_tags]) { mutate { id => "mutate_merge_evtx_log_tags"
                                               merge => { "[tags]" => "[@metadata][evtx_log_tags]" } } }
    if (![@metadata][nbsiteid]) and ([netbox][site]) {
      # for forwarded logs, the NetBox site value arrives in netbox.site
      mutate {
        id => "mutate_rename_beats_forwarded_site_id"
        rename => { "[netbox][site]" => "[@metadata][nbsiteid]" }
      }
    }

    # agent.type = evtx
    mutate { id => "mutate_replace_agent_type_beats_filebeat_evtx"
             replace => { "[agent][type]" => "evtx" } }

    # event.module = winlog to match up with fluentbit and winlogbeat records
    mutate { id => "mutate_add_field_event_module_evtx"
             add_field => { "[event][module]" => "winlog" } }

    mutate { id => "mutate_rename_evtx_event_data"
             rename => { "[evtx][Event][EventData]" => "[winlog][event_data]" } }

    mutate { id => "mutate_rename_evtx_user_data"
             rename => { "[evtx][Event][UserData]" => "[winlog][user_data]" } }

    # map level ID to level name
    if ([evtx][Event][System][Level]) {
      translate {
        id => "translate_evtx_level_to_eventtype"
        source => "[evtx][Event][System][Level]"
        target => "[log][level]"
        dictionary_path => "/etc/winlog_levels_to_name.yaml"
      }
      mutate { id => "mutate_merge_evtx_eventtype_to_result"
               merge => { "[event][result]" => "[log][level]" } }
    }

    # rename fields to match up to fluent-bit winlog/winevtlog records
    mutate { id => "mutate_rename_evtx"
             rename => { "[evtx][Event][System][Channel]" => "[winlog][channel]" }
             rename => { "[evtx][Event][System][Computer]" => "[winlog][computer_name]" }
             rename => { "[evtx][Event][System][Correlation_attributes][ActivityID]" => "[winlog][activity_id]" }
             rename => { "[evtx][Event][System][EventID]" => "[winlog][event_id]" }
             rename => { "[evtx][Event][System][EventID_attributes][Qualifiers]" => "[winlog][qualifiers]" }
             rename => { "[evtx][Event][System][EventRecordID]" => "[winlog][record_id]" }
             rename => { "[evtx][Event][System][Keywords]" => "[winlog][keywords]" }
             rename => { "[evtx][Event][System][Level]" => "[winlog][level]" }
             rename => { "[evtx][Event][System][Opcode]" => "[winlog][opcode]" }
             rename => { "[evtx][Event][System][Provider_attributes][Guid]" => "[winlog][provider_guid]" }
             rename => { "[evtx][Event][System][Provider_attributes][Name]" => "[winlog][provider_name]" }
             rename => { "[evtx][Event][System][Security_attributes][UserID]" => "[winlog][user][identifier]" }
             rename => { "[evtx][Event][System][Task]" => "[winlog][task]" }
             rename => { "[evtx][Event][System][Version]" => "[winlog][version]" }
    }

    ###########################################
    # some evtx Time fields (more generic ones are done in 13_normalize.conf)

    if ([evtx][Event][System][TimeCreated_attributes][SystemTime]) {
      date {
        id => "date_beats_evtx_systemtime"
        match => [ "[evtx][Event][System][TimeCreated_attributes][SystemTime]", "ISO8601" ]
        target => "[evtx][Event][System][TimeCreated_attributes][SystemTime]"
      }
      if (![winlog][time_created]) {
        mutate {
          id => "date_beats_evtx_systemtime_to_timewritten"
          copy => { "[evtx][Event][System][TimeCreated_attributes][SystemTime]" => "[winlog][time_created]" }
        }
      }
    }

    if ([winlog][user_data][CompatibilityFixEvent][StartTime]) {
      date {
        id => "date_beats_evtx_timewritten"
        match => [ "[winlog][user_data][CompatibilityFixEvent][StartTime]", "ISO8601" ]
        target => "[winlog][user_data][CompatibilityFixEvent][StartTime]"
      }
    }

    # end evtx Time fields
    ###########################################

    # we don't care about the xmlns fields
    mutate { id => "mutate_miscbeat_remove_evtx_xmlns"
             remove_field => [
                               "[evtx][Event_attributes][xmlns]",
                               "[winlog][user_data][AddServiceID_attributes][xmlns]",
                               "[winlog][user_data][CbsPackageChangeState_attributes][xmlns]",
                               "[winlog][user_data][CbsPackageInitiateChanges_attributes][xmlns]",
                               "[winlog][user_data][CbsUpdateChangeState_attributes][xmlns]",
                               "[winlog][user_data][CompatibilityFixEvent_attributes][xmlns:auto-ns2]",
                               "[winlog][user_data][CompatibilityFixEvent_attributes][xmlns]",
                               "[winlog][user_data][DroppedLeakDiagnosisEventInfo_attributes][xmlns]",
                               "[winlog][user_data][EventData_attributes][xmlns]",
                               "[winlog][user_data][EventInfo_attributes][xmlns]",
                               "[winlog][user_data][EventXML_attributes][xmlns:auto-ns2]",
                               "[winlog][user_data][EventXML_attributes][xmlns]",
                               "[winlog][user_data][LogFileCleared_attributes][xmlns:auto-ns3]",
                               "[winlog][user_data][LogFileCleared_attributes][xmlns]",
                               "[winlog][user_data][Operation_ClientFailure_attributes][xmlns]",
                               "[winlog][user_data][Operation_EssStarted_attributes][xmlns]",
                               "[winlog][user_data][Operation_ESStoConsumerBinding_attributes][xmlns]",
                               "[winlog][user_data][Operation_StartedOperational_attributes][xmlns]",
                               "[winlog][user_data][Operation_TemporaryEssStarted_attributes][xmlns]",
                               "[winlog][user_data][RegisterUninstallStringEventData_attributes][xmlns]",
                               "[winlog][user_data][ResolverFiredEvent_attributes][xmlns]",
                               "[winlog][user_data][RmApplicationEvent_attributes][xmlns]",
                               "[winlog][user_data][RmRestartEvent_attributes][xmlns]",
                               "[winlog][user_data][RmSessionEvent_attributes][xmlns]",
                               "[winlog][user_data][RmUnsupportedRestartEvent_attributes][xmlns]",
                               "[winlog][user_data][ServiceShutdown_attributes][xmlns]",
                               "[winlog][user_data][VmlEventLog_attributes][xmlns]" ] }

    # clean up record (remove empty values, NULL, etc.)
    ruby {
      id => "ruby_evtx_remove_empty_values"
      path => "/usr/share/logstash/malcolm-ruby/compact_event.rb"
      script_params => {
        "discard_zeroes" => "true"
      }
    }

    # some more ECS stuff (more generic ones are done in 13_normalize.conf)
    mutate { id => "mutate_add_field_event_kind_evtx"
             add_field => { "[event][kind]" => "event" } }
    mutate { id => "mutate_add_field_os_family_evtx"
             add_field => { "[os][family]" => "windows" } }
    mutate { id => "mutate_add_field_os_type_evtx"
             add_field => { "[os][type]" => "windows" } }

    # generate unique ID
    if (![event][hash]) {
      fingerprint {
        id => "fingerprint_malcolm_evtx"
        source => [ "[winlog][computer_name]",
                    "[agent][type]",
                    "[winlog][channel]",
                    "[winlog][provider_name]",
                    "[winlog][event_id]",
                    "[winlog][record_id]",
                    "[winlog][time_created]" ]
        concatenate_sources => true
        # uses event.hash
        ecs_compatibility => "v8"
        method => "MURMUR3_128"
        base64encode => true
      }
    }

  } # event type (filebeat.nginx, miscbeat, etc)

}