######################## # parsing of logs/metrics specific to the operation of
#                          Malcolm and Hedgehog Linux itself (i.e., not captured
#                          network traffic metadata, but operational metadata)
#
# Copyright (c) 2022 Battelle Energy Alliance, LLC.  All rights reserved.
#######################

filter {

  if (![host][name]) and ([agent][hostname]) {
    mutate { id => "mutate_beats_add_field_host_name_agent_hostname"
             add_field => { "[host][name]" => "%{[agent][hostname]}" } }
  }

  if ([agent][type] == "filebeat") and ([event][module] == "nginx") {
    #############################################################################################################################
    # nginx access and error logs

    # parse log fields
    if ([event][dataset] == "nginx.access") {
      grok {
        id => "grok_beat_nginx_access"
        patterns_dir => "/usr/share/logstash/malcolm-patterns"
        match => { "[event][original]" => "%{NGINX_ACCESS}" }
        # remove_tag => ["_grokparsefailure"]
      }
    }
    if ([event][dataset] == "nginx.error") {
      grok {
        id => "grok_beat_nginx_error"
        patterns_dir => "/usr/share/logstash/malcolm-patterns"
        match => { "[event][original]" => "%{NGINX_ERROR}" }
        # remove_tag => ["_grokparsefailure"]
      }
    }

    # save nginx log timestamp over @timestamp
    if ([timestamp]) {
      date {
        id => "date_beats_nginx_timestamp"
        match => [ "[timestamp]", "dd/MMM/yyyy:HH:mm:ss Z", "yyyy/MM/dd HH:mm:ss" ]
        target => "[@timestamp]"
        remove_field => [ "[timestamp]" ]
      }
    }

    # set agent.type to "nginx"
    mutate { id => "mutate_replace_agent_type_beats_filebeat_nginx"
             replace => { "[agent][type]" => "nginx" } }

  } else if ("_malcolm_miscbeat" in [tags]) {
    #############################################################################################################################
    # misc. sensor metrics and logs from fluentbit received by filebeat TCP input
    # https://docs.fluentbit.io/manual/
    # https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-tcp.html

    # set event.module to whatever we set "module" to when running fluentbit
    if ([miscbeat][module]) {
      mutate { id => "mutate_replace_event_module_miscbeat_module"
               replace => { "[event][module]" => "%{[miscbeat][module]}" }
               remove_field => [ "[miscbeat][module]" ] }
    }

    # convert fluentbit's date field and save it to @timestamp
    if ([miscbeat][date]) {
      date {
        id => "date_beats_miscbeat_date"
        match => [ "[miscbeat][date]", "UNIX" ]
        target => "[@timestamp]"
        remove_field => [ "[miscbeat][date]" ]
      }
    }

    if ([miscbeat][aide]) {
      #-------------------------------------------------
      # fluentbit exec of AIDE
      # https://aide.github.io/

      # parse AIDE run start_time and end_time
      if ([miscbeat][aide][start_time]) {
        date {
          id => "date_beats_miscbeat_aide_start_time"
          match => [ "[miscbeat][aide][start_time]", "yyyy-MM-dd HH:mm:ss Z" ]
          target => "[miscbeat][aide][start_time]"
        }
      }
      if ([miscbeat][aide][end_time]) {
        date {
          id => "date_beats_miscbeat_aide_end_time"
          match => [ "[miscbeat][aide][end_time]", "yyyy-MM-dd HH:mm:ss Z" ]
          target => "[miscbeat][aide][end_time]"
        }
      }

      # set action (changed, added, removed files/directories)
      ruby {
          id => "ruby_miscbeat_aide_action"
          code => "
            actions = Array.new
            actions.push('add') if (event.get('[miscbeat][aide][number_of_entries][added]').to_i > 0)
            actions.push('change') if (event.get('[miscbeat][aide][number_of_entries][changed]').to_i > 0)
            actions.push('remove') if (event.get('[miscbeat][aide][number_of_entries][removed]').to_i > 0)
            event.set('[event][action]', actions) unless (actions.length == 0)
          "
      }

      # convert hashe of hashes to arrays of hashes so we don't end up creating a new
      # dynamically-mapped field for every single file/directory
      if ([miscbeat][aide][details]) {
        ruby {
          id => "ruby_miscbeat_aide_details_hashform"
          path => "/usr/share/logstash/malcolm-ruby/hashhash_to_hasharray.rb"
          script_params => {
            "source" => "[miscbeat][aide][details]"
            "target_hash_array" => "[miscbeat][aide][details]"
            "target_keys_array" => "[file][path]"
            "name_key" => "path"
          }
        }
      }
      if ([miscbeat][aide][databases]) {
        ruby {
          id => "ruby_miscbeat_aide_databases_hashform"
          path => "/usr/share/logstash/malcolm-ruby/hashhash_to_hasharray.rb"
          script_params => {
            "source" => "[miscbeat][aide][databases]"
            "target_hash_array" => "[miscbeat][aide][databases]"
            "name_key" => "path"
          }
        }
      }
      if ([miscbeat][aide][added]) {
        ruby {
          id => "ruby_miscbeat_aide_added_to_array"
          path => "/usr/share/logstash/malcolm-ruby/hashhash_to_hasharray.rb"
          script_params => {
            "source" => "[miscbeat][aide][added]"
            "target_keys_array" => "[miscbeat][aide][added]"
          }
        }
      }
      if ([miscbeat][aide][changed]) {
        ruby {
          id => "ruby_miscbeat_aide_changed_to_array"
          path => "/usr/share/logstash/malcolm-ruby/hashhash_to_hasharray.rb"
          script_params => {
            "source" => "[miscbeat][aide][changed]"
            "target_keys_array" => "[miscbeat][aide][changed]"
          }
        }
      }
      if ([miscbeat][aide][removed]) {
        ruby {
          id => "ruby_miscbeat_aide_removed_to_array"
          path => "/usr/share/logstash/malcolm-ruby/hashhash_to_hasharray.rb"
          script_params => {
            "source" => "[miscbeat][aide][removed]"
            "target_keys_array" => "[miscbeat][aide][removed]"
          }
        }
      }

      # merge file.path to contain all related file names/paths
      ruby {
        id => "ruby_miscbeat_aide_merge_paths"
        code => "
          paths = event.get('[file][path]').to_a +
                  event.get('[miscbeat][aide][added]').to_a +
                  event.get('[miscbeat][aide][changed]').to_a +
                  event.get('[miscbeat][aide][removed]').to_a
          event.set('[file][path]', paths.uniq.flatten.compact) unless (paths.length == 0)
        "
      }

      # rename miscbeat.aide.outline to event.result and translate clunky result messages
      if ([miscbeat][aide][outline]) {
        mutate { id => "mutate_rename_miscbeat_aide_outline"
                 rename => { "[miscbeat][aide][outline]" => "[event][result]" } }
        if ([event][result] =~ /^AIDE found NO differences/) {
          mutate { id => "mutate_replace_miscbeat_aide_result_no_differences"
                   replace => { "[event][result]" => "Success" } }
        } else if ([event][result] =~ /^AIDE found differences/) {
          mutate { id => "mutate_replace_miscbeat_aide_result_differences"
                   replace => { "[event][result]" => "Failure" } }
        }
      }

      # generate unique ID
      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_aide"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][aide][number_of_entries][total]",
                      "[miscbeat][aide][number_of_entries][added]",
                      "[miscbeat][aide][number_of_entries][removed]",
                      "[miscbeat][aide][number_of_entries][changed]",
                      "[event][result]",
                      "[miscbeat][aide][start_time]",
                      "[miscbeat][aide][end_time]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][aide])

    if ([miscbeat][auditlog]) {
      #-------------------------------------------------
      # fluentbit tail of /var/log/audit/audit.log
      # https://man7.org/linux/man-pages/man5/auditd.conf.5.html

      ruby {
        id => "ruby_miscbeat_auditlog_remove_empty_values"
        path => "/usr/share/logstash/malcolm-ruby/compact_event.rb"
      }

      if ([miscbeat][auditlog][grantors]) {
        mutate { id => "mutate_split_miscbeat_auditlog_grantors"
                 split => { "[miscbeat][auditlog][grantors]" => "," } }
      }

      if (![miscbeat][auditlog][success]) and
         ([miscbeat][auditlog][res] =~ /^success'?$/) {
        mutate { id => "mutate_miscbeat_auditlog_res_success"
                 add_field => { "[miscbeat][auditlog][success]" => "yes" }
                 remove_field => [ "[miscbeat][auditlog][res]" ] }
      }

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_auditlog"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][auditlog][ses]",
                      "[miscbeat][auditlog][type]",
                      "[miscbeat][auditlog][SYSCALL]",
                      "[miscbeat][auditlog][acct]",
                      "[miscbeat][auditlog][UID]",
                      "[miscbeat][auditlog][exe]",
                      "[miscbeat][auditlog][msg]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][auditlog])

    if ([miscbeat][kmsg]) {
      #-------------------------------------------------
      # kmsg - https://docs.fluentbit.io/manual/pipeline/inputs/kernel-logs
      mutate { id => "mutate_rename_miscbeat_kmsg"
               rename => { "[miscbeat][kmsg][msg]" => "[event][original]" } }

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_kmsg"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][kmsg][sequence]",
                      "[miscbeat][kmsg][priority]",
                      "[event][original]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][kmsg])

    if ([miscbeat][cpu]) {
      #-------------------------------------------------
      # cpu - https://docs.fluentbit.io/manual/pipeline/inputs/cpu-metrics

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_cpu"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][cpu][cpu_p]",
                      "[miscbeat][cpu][system_p]",
                      "[miscbeat][cpu][user_p]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][cpu])

    if ([miscbeat][mem]) {
      #-------------------------------------------------
      # mem - https://docs.fluentbit.io/manual/pipeline/inputs/memory-metrics

      if (![event][hash]) {

        if ([miscbeat][mem][Mem][used]) {
          fingerprint {
            id => "fingerprint_malcolm_miscbeat_mem_total"
            source => [ "[host][name]",
                        "[event][module]",
                        "[miscbeat][mem][Mem][used]",
                        "[miscbeat][mem][Mem][free]",
                        "[miscbeat][mem][Mem][total]",
                        "[@timestamp]" ]
            concatenate_sources => true
            # uses event.hash
            ecs_compatibility => "v8"
            method => "MURMUR3_128"
            base64encode => true
          }
        } else if ([miscbeat][mem][Mem][used_p]) {
          fingerprint {
            id => "fingerprint_malcolm_miscbeat_mem_used_p"
            source => [ "[host][name]",
                        "[event][module]",
                        "[miscbeat][mem][Mem][used_p]",
                        "[@timestamp]" ]
            concatenate_sources => true
            # uses event.hash
            ecs_compatibility => "v8"
            method => "MURMUR3_128"
            base64encode => true
          }
        }
      }

    } # if ([miscbeat][mem])

    if ([miscbeat][disk]) {
      #-------------------------------------------------
      # disk - https://docs.fluentbit.io/manual/pipeline/inputs/disk-io-metrics

      if ([miscbeat][disk][df][details]) {
        ruby {
          id => "ruby_miscbeat_disk_df_sum"
          code => "
            if dfentries = event.get('[miscbeat][disk][df][details]') then
              size, used, avail = 0, 0, 0
              dfentries.each do |dfentry|
                size = size + dfentry.dig('size').to_i
                used = used + dfentry.dig('used').to_i
                avail = avail + dfentry.dig('avail').to_i
              end
              event.set('[miscbeat][disk][df][size]', size)
              event.set('[miscbeat][disk][df][used]', used)
              event.set('[miscbeat][disk][df][avail]', avail)
            end"
        }
      }

      if (![event][hash]) {

        if ([miscbeat][disk][read_size]) and ([miscbeat][disk][write_size]) {
          fingerprint {
            id => "fingerprint_malcolm_miscbeat_disk_read_write"
            source => [ "[host][name]",
                        "[event][module]",
                        "[miscbeat][disk][read_size]",
                        "[miscbeat][disk][write_size]",
                        "[@timestamp]" ]
            concatenate_sources => true
            # uses event.hash
            ecs_compatibility => "v8"
            method => "MURMUR3_128"
            base64encode => true
          }
        } else {
          fingerprint {
            id => "fingerprint_malcolm_miscbeat_disk"
            source => [ "[host][name]",
                        "[event][module]",
                        "[miscbeat][disk][df][size]",
                        "[miscbeat][disk][df][used]",
                        "[miscbeat][disk][df][avail]",
                        "[@timestamp]" ]
            concatenate_sources => true
            # uses event.hash
            ecs_compatibility => "v8"
            method => "MURMUR3_128"
            base64encode => true
          }
        }
      } # ![event][hash]

    } # if ([miscbeat][disk])

    if ([miscbeat][network]) {
      #-------------------------------------------------
      # not using fluent-bit netif input, rolled my own with /proc/net/dev and jq

      mutate { id => "mutate_rename_miscbeat_network_interfaces"
               rename => { "[miscbeat][network][interfaces]" => "[miscbeat][network][details]" } }
      ruby {
        id => "ruby_miscbeat_network_details_sum"
        code => "
          if interfaces = event.get('[miscbeat][network][details]') then
            bytes_tx, bytes_rx, packets_tx, packets_rx, errors_tx, errors_rx, drop_tx, drop_rx = 0, 0, 0, 0, 0, 0, 0, 0
            interfaces.each do |key, value|
              bytes_tx = bytes_tx + value.dig('tx_bytes').to_i
              bytes_rx = bytes_rx + value.dig('rx_bytes').to_i
              packets_tx = packets_tx + value.dig('tx_packets').to_i
              packets_rx = packets_rx + value.dig('rx_packets').to_i
              errors_tx = errors_tx + value.dig('tx_errs').to_i
              errors_rx = errors_rx + value.dig('rx_errs').to_i
              drop_tx = drop_tx + value.dig('tx_drop').to_i
              drop_rx = drop_rx + value.dig('rx_drop').to_i
            end
            event.set('[miscbeat][network][interface]', interfaces.keys)
            event.set('[miscbeat][network][bytes][tx]', bytes_tx)
            event.set('[miscbeat][network][bytes][rx]', bytes_rx)
            event.set('[miscbeat][network][bytes][total]', bytes_tx+bytes_rx)
            event.set('[miscbeat][network][packets][tx]', packets_tx)
            event.set('[miscbeat][network][packets][rx]', packets_rx)
            event.set('[miscbeat][network][packets][total]', packets_tx+packets_rx)
            event.set('[miscbeat][network][errors][tx]', errors_tx)
            event.set('[miscbeat][network][errors][rx]', errors_rx)
            event.set('[miscbeat][network][errors][total]', errors_tx+errors_rx)
            event.set('[miscbeat][network][drops][tx]', drop_tx)
            event.set('[miscbeat][network][drops][rx]', drop_rx)
            event.set('[miscbeat][network][drops][total]', drop_tx+drop_rx)
          end"
       }

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_network"
          source => [ "[host][name]",
                      "[event][module]",
                      "[miscbeat][network][bytes][total]",
                      "[miscbeat][network][packets][total]",
                      "[miscbeat][network][errors][total]",
                      "[miscbeat][network][drops][total]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][network])

    if ([miscbeat][syslog]) {
      #-------------------------------------------------
      # syslog - https://docs.fluentbit.io/manual/pipeline/inputs/syslog

      # time gets parsed into the miscbeat.date field, this is redundant
      mutate { id => "mutate_miscbeat_remove_syslog_time"
               remove_field => [ "[miscbeat][syslog][time]" ] }

      # rename syslog fields according to ECS
      # https://www.elastic.co/guide/en/ecs/current/ecs-log.html#field-log-syslog
      mutate { id => "mutate_rename_miscbeat_syslog"
               rename => { "[miscbeat][syslog][ident]" => "[log][syslog][appname]" }
               rename => { "[miscbeat][syslog][pid]" => "[log][syslog][procid]" }
               rename => { "[miscbeat][syslog][pri]" => "[log][syslog][priority]" }
               rename => { "[miscbeat][syslog][message]" => "[event][original]" }
               rename => { "[miscbeat][syslog][host]" => "[log][syslog][hostname]" }
      }

      # convert syslog "priority" number to "severity" and "facility" and map to human-readable names
      if ([log][syslog][priority]) {
        ruby {
          id => "ruby_log_syslog_priority_convert"
          code => "
            if pri = event.get('[log][syslog][priority]').to_i then
              event.set('[log][syslog][severity][code]', pri % 8)
              event.set('[log][syslog][facility][code]', pri / 8)
            end"
        }
        if ([log][syslog][severity][code]) {
          translate {
            id => "translate_sensor_syslog_severity_code"
            source => "[log][syslog][severity][code]"
            target => "[log][syslog][severity][name]"
            dictionary_path => "/etc/syslog_severity_levels.yaml"
          }
        }
        if ([log][syslog][facility][code]) {
          translate {
            id => "translate_sensor_syslog_facility_code"
            source => "[log][syslog][facility][code]"
            target => "[log][syslog][facility][name]"
            dictionary_path => "/etc/syslog_facility_codes.yaml"
          }
        }
      }

      if (![event][hash]) {
        fingerprint {
          id => "fingerprint_malcolm_miscbeat_syslog"
          source => [ "[host][name]",
                      "[event][module]",
                      "[log][syslog][severity][code]",
                      "[log][syslog][facility][code]",
                      "[log][syslog][appname]",
                      "[event][original]",
                      "[@timestamp]" ]
          concatenate_sources => true
          # uses event.hash
          ecs_compatibility => "v8"
          method => "MURMUR3_128"
          base64encode => true
        }
      }

    } # if ([miscbeat][syslog])

  } # event type (filebeat.nginx, miscbeat, etc)

}