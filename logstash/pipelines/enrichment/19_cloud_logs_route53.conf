filter {
  # AWS Route 53 Query Logs Parser
  # Parses Route 53 DNS query logs
  # Related: GitHub Issue #232 - Cloud Infrastructure Logs Integration
  
  if ([event][dataset] == "aws.route53") {
    
    # Route 53 query logs are in JSON format
    # Format: https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html
    
    json {
      id => "json_route53_parse"
      source => "message"
      target => "aws.route53"
    }
    
    # Extract timestamp
    if [aws.route53][query_timestamp] {
      date {
        id => "date_route53_timestamp"
        match => [ "[aws.route53][query_timestamp]", "ISO8601" ]
        target => "@timestamp"
      }
    }
    
    # Map Route 53 fields to ECS
    if [aws.route53][srcaddr] {
      mutate {
        id => "mutate_route53_source_ip"
        add_field => { "[source][ip]" => "%{[aws.route53][srcaddr]}" }
      }
    }
    
    if [aws.route53][srcport] {
      mutate {
        id => "mutate_route53_source_port"
        add_field => { "[source][port]" => "%{[aws.route53][srcport]}" }
      }
    }
    
    if [aws.route53][query_name] {
      mutate {
        id => "mutate_route53_dns_question"
        add_field => { 
          "[dns][question][name]" => "%{[aws.route53][query_name]}"
          "[dns][question][registered_domain]" => "%{[aws.route53][query_name]}"
        }
      }
    }
    
    if [aws.route53][query_type] {
      mutate {
        id => "mutate_route53_dns_type"
        add_field => { "[dns][question][type]" => "%{[aws.route53][query_type]}" }
      }
    }
    
    if [aws.route53][rcode] {
      mutate {
        id => "mutate_route53_dns_response_code"
        add_field => { "[dns][response_code]" => "%{[aws.route53][rcode]}" }
      }
    }
    
    if [aws.route53][answers] {
      ruby {
        id => "ruby_route53_parse_answers"
        code => "
          answers = event.get('[aws.route53][answers]')
          if answers && answers.is_a?(Array)
            resolved_ips = []
            answers.each do |answer|
              if answer['Rdata'] && answer['Rdata'] =~ /^\\d+\\.\\d+\\.\\d+\\.\\d+$/
                resolved_ips << answer['Rdata']
              end
            end
            event.set('[dns][resolved_ip]', resolved_ips) unless resolved_ips.empty?
          end
        "
      }
    }
    
    # Set event outcome based on response code
    if [dns.response_code] {
      if [dns.response_code] == "NOERROR" {
        mutate {
          id => "mutate_route53_success"
          add_field => { "[event][outcome]" => "success" }
        }
      } else {
        mutate {
          id => "mutate_route53_failure"
          add_field => { 
            "[event][outcome]" => "failure"
            "[event][type]" => "error"
          }
        }
      }
    }
    
    # Add cloud metadata
    mutate {
      id => "mutate_route53_cloud_metadata"
      add_field => {
        "[cloud][provider]" => "aws"
        "[cloud][service][name]" => "route53"
        "[event][kind]" => "event"
        "[event][category]" => "network"
        "[network][protocol]" => "dns"
        "[network][transport]" => "udp"
      }
    }
    
    # Detect DNS tunneling (long domain names)
    if [dns.question.name] {
      ruby {
        id => "ruby_route53_detect_tunneling"
        code => "
          domain = event.get('[dns][question][name]')
          if domain && domain.length > 100
            event.set('tags', []) unless event.get('tags')
            event.get('tags') << 'potential_dns_tunneling'
          end
        "
      }
    }
    
    # Detect DGA (Domain Generation Algorithm) patterns
    if [dns.question.name] =~ /[a-z0-9]{20,}/ {
      mutate {
        id => "mutate_route53_dga"
        add_tag => ["potential_dga"]
      }
    }
    
    # Detect NXDOMAIN responses (potential C2 or scanning)
    if [dns.response_code] == "NXDOMAIN" {
      mutate {
        id => "mutate_route53_nxdomain"
        add_tag => ["nxdomain_response"]
      }
    }
    
    # Detect queries to suspicious TLDs
    if [dns.question.name] =~ /\.(tk|ml|ga|cf|gq|pw|cc|ws|info|biz|top)$/ {
      mutate {
        id => "mutate_route53_suspicious_tld"
        add_tag => ["suspicious_tld"]
      }
    }
    
    # Detect high-volume queries from single source (potential DNS amplification)
    # This would require aggregation, so just tag for now
    if [aws.route53][srcaddr] {
      mutate {
        id => "mutate_route53_query_source"
        add_field => { "[event][action]" => "dns_query" }
      }
    }
    
    # Detect TXT record queries (often used for data exfiltration)
    if [dns.question.type] == "TXT" {
      mutate {
        id => "mutate_route53_txt_query"
        add_tag => ["txt_record_query"]
      }
    }
    
    # Detect ANY queries (often used in amplification attacks)
    if [dns.question.type] == "ANY" {
      mutate {
        id => "mutate_route53_any_query"
        add_tag => ["any_record_query", "potential_amplification"]
      }
    }
    
    # Clean up
    mutate {
      id => "mutate_route53_cleanup"
      remove_field => ["message"]
    }
    
    # Note: GeoIP enrichment for source.ip will be handled by Malcolm's
    # existing 11_lookups.conf filter
    
  } # end if aws.route53

} # end filter
