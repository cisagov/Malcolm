filter {
  # AWS VPC Flow Logs Parser
  # Supports VPC Flow Logs versions 2-5
  # Related: GitHub Issue #232 - Cloud Infrastructure Logs Integration
  
  if ([event][dataset] == "aws.vpcflowlogs") {
    
    # Parse VPC Flow Logs format (version 2 - default format)
    # Format: version account-id interface-id srcaddr dstaddr srcport dstport protocol packets bytes start end action log-status
    grok {
      id => "grok_vpc_flow_logs_v2"
      match => {
        "message" => "%{NUMBER:vpc.version} %{NOTSPACE:cloud.account.id} %{NOTSPACE:aws.vpc.interface_id} %{IP:source.ip} %{IP:destination.ip} %{NUMBER:source.port:int} %{NUMBER:destination.port:int} %{NUMBER:network.iana_number:int} %{NUMBER:network.packets:int} %{NUMBER:network.bytes:int} %{NUMBER:event.start:int} %{NUMBER:event.end:int} %{WORD:aws.vpc.action} %{WORD:aws.vpc.log_status}"
      }
      tag_on_failure => ["_grokparsefailure_vpc_flow"]
    }
    
    # Convert timestamps from Unix epoch to ISO8601
    if [event.start] {
      date {
        id => "date_vpc_flow_start"
        match => [ "event.start", "UNIX" ]
        target => "@timestamp"
      }
      
      # Calculate duration in nanoseconds (ECS standard)
      if [event.end] {
        ruby {
          id => "ruby_vpc_flow_duration"
          code => "event.set('event.duration', (event.get('event.end').to_i - event.get('event.start').to_i) * 1000000000)"
        }
      }
    }
    
    # Map IANA protocol number to name (following Malcolm's pattern from 11_lookups.conf)
    translate {
      id => "translate_vpc_flow_protocol"
      field => "network.iana_number"
      destination => "network.transport"
      dictionary => {
        "1" => "icmp"
        "6" => "tcp"
        "17" => "udp"
        "47" => "gre"
        "50" => "esp"
        "51" => "ah"
        "58" => "ipv6-icmp"
      }
      fallback => "unknown"
    }
    
    # Set event outcome and type based on action
    if [aws.vpc.action] == "ACCEPT" {
      mutate {
        id => "mutate_vpc_flow_accept"
        add_field => {
          "[event][outcome]" => "success"
          "[event][type]" => "connection"
          "[event][category]" => "network"
          "[event][kind]" => "event"
        }
      }
    } else if [aws.vpc.action] == "REJECT" {
      mutate {
        id => "mutate_vpc_flow_reject"
        add_field => {
          "[event][outcome]" => "failure"
          "[event][type]" => "denied"
          "[event][category]" => "network"
          "[event][kind]" => "event"
        }
        add_tag => ["rejected_traffic"]
      }
    }
    
    # Add cloud provider metadata
    mutate {
      id => "mutate_vpc_flow_cloud_metadata"
      add_field => {
        "[cloud][provider]" => "aws"
        "[cloud][service][name]" => "vpc"
      }
    }
    
    # Add network.protocol array for Malcolm compatibility
    if [network.transport] {
      mutate {
        id => "mutate_vpc_flow_network_protocol"
        add_field => { "[network][protocol]" => "%{[network][transport]}" }
      }
    }
    
    # Detect potential data exfiltration (high bytes transferred)
    if [network.bytes] and [network.bytes] > 10000000 {  # > 10MB
      mutate {
        id => "mutate_vpc_flow_high_volume"
        add_tag => ["high_volume_transfer"]
      }
    }
    
    # Detect potential port scanning (many rejected connections)
    if ("rejected_traffic" in [tags]) {
      mutate {
        id => "mutate_vpc_flow_potential_scan"
        add_tag => ["potential_port_scan"]
      }
    }
    
    # Clean up temporary fields
    mutate {
      id => "mutate_vpc_flow_cleanup"
      remove_field => ["message"]
    }
    
    # Note: GeoIP and ASN enrichment will be handled by Malcolm's existing
    # 11_lookups.conf filter based on source.ip and destination.ip fields
    
  } # end if aws.vpcflowlogs

} # end filter
