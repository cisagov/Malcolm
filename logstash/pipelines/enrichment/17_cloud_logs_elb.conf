filter {
  # AWS ELB/ALB Access Logs Parser
  # Parses Elastic Load Balancer and Application Load Balancer access logs
  # Related: GitHub Issue #232 - Cloud Infrastructure Logs Integration
  
  if ([event][dataset] == "aws.elb") {
    
    # ELB/ALB logs are space-delimited with quoted fields
    # Format varies between Classic ELB and ALB
    # Detect type based on log format
    
    # ALB format (starts with type field)
    if [message] =~ /^(http|https|h2|ws|wss) / {
      grok {
        id => "grok_alb_access_logs"
        match => {
          "message" => "%{NOTSPACE:aws.elb.type} %{TIMESTAMP_ISO8601:aws.elb.timestamp} %{NOTSPACE:aws.elb.name} %{NOTSPACE:aws.elb.client} %{NOTSPACE:aws.elb.target} %{NUMBER:aws.elb.request_processing_time:float} %{NUMBER:aws.elb.target_processing_time:float} %{NUMBER:aws.elb.response_processing_time:float} %{NUMBER:http.response.status_code:int} %{NUMBER:aws.elb.target_status_code:int} %{NUMBER:http.request.bytes:int} %{NUMBER:http.response.bytes:int} \"%{DATA:http.request.method} %{DATA:url.original} %{DATA:http.version}\" \"%{DATA:user_agent.original}\" %{NOTSPACE:tls.cipher} %{NOTSPACE:tls.version_protocol} %{NOTSPACE:aws.elb.target_group_arn} \"%{DATA:trace.id}\" \"%{DATA:aws.elb.domain_name}\" \"%{DATA:aws.elb.chosen_cert_arn}\" %{NUMBER:aws.elb.matched_rule_priority:int} %{TIMESTAMP_ISO8601:aws.elb.request_creation_time} \"%{DATA:aws.elb.actions_executed}\" \"%{DATA:aws.elb.redirect_url}\" \"%{DATA:error.message}\" \"%{DATA:aws.elb.target_port_list}\" \"%{DATA:aws.elb.target_status_code_list}\" \"%{DATA:aws.elb.classification}\" \"%{DATA:aws.elb.classification_reason}\""
        }
        tag_on_failure => ["_grokparsefailure_alb"]
      }
    } 
    # Classic ELB format
    else {
      grok {
        id => "grok_elb_access_logs"
        match => {
          "message" => "%{TIMESTAMP_ISO8601:aws.elb.timestamp} %{NOTSPACE:aws.elb.name} %{NOTSPACE:aws.elb.client} %{NOTSPACE:aws.elb.backend} %{NUMBER:aws.elb.request_processing_time:float} %{NUMBER:aws.elb.backend_processing_time:float} %{NUMBER:aws.elb.response_processing_time:float} %{NUMBER:http.response.status_code:int} %{NUMBER:aws.elb.backend_status_code:int} %{NUMBER:http.request.bytes:int} %{NUMBER:http.response.bytes:int} \"%{DATA:http.request.method} %{DATA:url.original} %{DATA:http.version}\" \"%{DATA:user_agent.original}\" %{NOTSPACE:tls.cipher} %{NOTSPACE:tls.version_protocol}"
        }
        tag_on_failure => ["_grokparsefailure_elb"]
      }
    }
    
    # Parse timestamp
    if [aws.elb.timestamp] {
      date {
        id => "date_elb_timestamp"
        match => [ "[aws.elb][timestamp]", "ISO8601" ]
        target => "@timestamp"
      }
    }
    
    # Parse client IP and port
    if [aws.elb.client] {
      grok {
        id => "grok_elb_client"
        match => { "[aws.elb][client]" => "%{IP:source.ip}:%{NUMBER:source.port:int}" }
      }
    }
    
    # Parse target/backend IP and port
    if [aws.elb.target] {
      grok {
        id => "grok_elb_target"
        match => { "[aws.elb][target]" => "%{IP:destination.ip}:%{NUMBER:destination.port:int}" }
      }
    } else if [aws.elb.backend] {
      grok {
        id => "grok_elb_backend"
        match => { "[aws.elb][backend]" => "%{IP:destination.ip}:%{NUMBER:destination.port:int}" }
      }
    }
    
    # Parse URL components
    if [url.original] {
      ruby {
        id => "ruby_elb_parse_url"
        code => "
          require 'uri'
          begin
            uri = URI.parse(event.get('[url][original]'))
            event.set('[url][path]', uri.path) if uri.path
            event.set('[url][query]', uri.query) if uri.query
            event.set('[url][scheme]', uri.scheme) if uri.scheme
          rescue
            # Invalid URL, skip parsing
          end
        "
      }
    }
    
    # Calculate total processing time
    if [aws.elb.request_processing_time] and [aws.elb.target_processing_time] and [aws.elb.response_processing_time] {
      ruby {
        id => "ruby_elb_total_time"
        code => "
          total = event.get('[aws.elb][request_processing_time]').to_f + 
                  event.get('[aws.elb][target_processing_time]').to_f + 
                  event.get('[aws.elb][response_processing_time]').to_f
          event.set('[event][duration]', (total * 1000000000).to_i)
        "
      }
    }
    
    # Set event outcome based on status code
    if [http.response.status_code] {
      if [http.response.status_code] >= 200 and [http.response.status_code] < 400 {
        mutate {
          id => "mutate_elb_success"
          add_field => { "[event][outcome]" => "success" }
        }
      } else if [http.response.status_code] >= 400 and [http.response.status_code] < 500 {
        mutate {
          id => "mutate_elb_client_error"
          add_field => { 
            "[event][outcome]" => "failure"
            "[event][type]" => "error"
          }
          add_tag => ["client_error"]
        }
      } else if [http.response.status_code] >= 500 {
        mutate {
          id => "mutate_elb_server_error"
          add_field => { 
            "[event][outcome]" => "failure"
            "[event][type]" => "error"
          }
          add_tag => ["server_error"]
        }
      }
    }
    
    # Add cloud metadata
    mutate {
      id => "mutate_elb_cloud_metadata"
      add_field => {
        "[cloud][provider]" => "aws"
        "[cloud][service][name]" => "elb"
        "[event][kind]" => "event"
        "[event][category]" => "web"
      }
    }
    
    # Detect slow requests (> 5 seconds)
    if [event.duration] and [event.duration] > 5000000000 {
      mutate {
        id => "mutate_elb_slow_request"
        add_tag => ["slow_request"]
      }
    }
    
    # Detect potential attacks
    if [http.response.status_code] == 403 or [http.response.status_code] == 401 {
      mutate {
        id => "mutate_elb_unauthorized"
        add_tag => ["unauthorized_access"]
      }
    }
    
    # Detect SQL injection attempts in URL
    if [url.original] =~ /(union|select|insert|update|delete|drop|exec|script)/i {
      mutate {
        id => "mutate_elb_sql_injection"
        add_tag => ["potential_sql_injection"]
      }
    }
    
    # Clean up
    mutate {
      id => "mutate_elb_cleanup"
      remove_field => ["message"]
    }
    
    # Note: GeoIP enrichment for source.ip will be handled by Malcolm's
    # existing 11_lookups.conf filter
    
  } # end if aws.elb

} # end filter
