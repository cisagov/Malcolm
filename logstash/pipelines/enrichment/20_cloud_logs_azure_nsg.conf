filter {
  # Azure NSG Flow Logs Parser
  # Parses Azure Network Security Group Flow Logs (Version 2)
  # Related: GitHub Issue #232 - Cloud Infrastructure Logs Integration
  
  if ([event][dataset] == "azure.nsgflowlogs") {
    
    # Azure NSG Flow Logs are in JSON format
    # Format: https://docs.microsoft.com/en-us/azure/network-watcher/network-watcher-nsg-flow-logging-overview
    
    json {
      id => "json_azure_nsg_parse"
      source => "message"
      target => "azure"
    }
    
    # Navigate nested JSON structure
    # records -> properties -> flows -> flows -> flowTuples
    if [azure][records] {
      ruby {
        id => "ruby_azure_nsg_extract_flows"
        code => "
          records = event.get('[azure][records]')
          return unless records && records.is_a?(Array)
          
          records.each do |record|
            next unless record['properties'] && record['properties']['flows']
            
            # Extract resource metadata
            event.set('[azure][nsg][resource_id]', record['resourceId']) if record['resourceId']
            event.set('[azure][nsg][subscription_id]', record['subscriptionId']) if record['subscriptionId']
            event.set('[azure][nsg][resource_group]', record['resourceGroup']) if record['resourceGroup']
            
            # Process flows
            flows = record['properties']['flows']
            flows.each do |flow|
              rule = flow['rule']
              event.set('[azure][nsg][rule]', rule) if rule
              
              # Process flow tuples
              if flow['flows']
                flow['flows'].each do |mac_flow|
                  mac = mac_flow['mac']
                  event.set('[source][mac]', mac) if mac
                  
                  if mac_flow['flowTuples']
                    # Parse first flow tuple (can be extended to handle multiple)
                    tuple = mac_flow['flowTuples'][0]
                    if tuple
                      parts = tuple.split(',')
                      
                      # Version 2 format:
                      # timestamp,source_ip,dest_ip,source_port,dest_port,protocol,traffic_flow,traffic_decision,flow_state,packets_sent,bytes_sent,packets_received,bytes_received
                      event.set('[azure][nsg][flow_timestamp]', parts[0]) if parts[0]
                      event.set('[source][ip]', parts[1]) if parts[1]
                      event.set('[destination][ip]', parts[2]) if parts[2]
                      event.set('[source][port]', parts[3].to_i) if parts[3]
                      event.set('[destination][port]', parts[4].to_i) if parts[4]
                      event.set('[network][iana_number]', parts[5]) if parts[5]
                      event.set('[azure][nsg][traffic_flow]', parts[6]) if parts[6]
                      event.set('[azure][nsg][traffic_decision]', parts[7]) if parts[7]
                      event.set('[azure][nsg][flow_state]', parts[8]) if parts[8]
                      event.set('[azure][nsg][packets_sent]', parts[9].to_i) if parts[9]
                      event.set('[network][bytes]', parts[10].to_i) if parts[10]
                      event.set('[azure][nsg][packets_received]', parts[11].to_i) if parts[11]
                      event.set('[azure][nsg][bytes_received]', parts[12].to_i) if parts[12]
                    end
                  end
                end
              end
            end
          end
        "
      }
    }
    
    # Parse timestamp
    if [azure.nsg.flow_timestamp] {
      date {
        id => "date_azure_nsg_timestamp"
        match => [ "[azure.nsg][flow_timestamp]", "UNIX" ]
        target => "@timestamp"
      }
    }
    
    # Map protocol number to name
    if [network.iana_number] {
      translate {
        id => "translate_azure_nsg_protocol"
        field => "[network][iana_number]"
        destination => "[network][transport]"
        dictionary => {
          "6" => "tcp"
          "17" => "udp"
          "1" => "icmp"
          "58" => "icmpv6"
        }
        fallback => "unknown"
      }
    }
    
    # Set event outcome based on traffic decision
    if [azure.nsg.traffic_decision] {
      if [azure.nsg.traffic_decision] == "A" {
        mutate {
          id => "mutate_azure_nsg_allowed"
          add_field => { "[event][outcome]" => "success" }
        }
      } else if [azure.nsg.traffic_decision] == "D" {
        mutate {
          id => "mutate_azure_nsg_denied"
          add_field => { 
            "[event][outcome]" => "failure"
            "[event][type]" => "denied"
          }
          add_tag => ["rejected_traffic"]
        }
      }
    }
    
    # Determine network direction
    if [azure.nsg.traffic_flow] {
      if [azure.nsg.traffic_flow] == "I" {
        mutate {
          id => "mutate_azure_nsg_inbound"
          add_field => { "[network][direction]" => "inbound" }
        }
      } else if [azure.nsg.traffic_flow] == "O" {
        mutate {
          id => "mutate_azure_nsg_outbound"
          add_field => { "[network][direction]" => "outbound" }
        }
      }
    }
    
    # Add cloud metadata
    mutate {
      id => "mutate_azure_nsg_cloud_metadata"
      add_field => {
        "[cloud][provider]" => "azure"
        "[cloud][service][name]" => "network_security_group"
        "[event][kind]" => "event"
        "[event][category]" => "network"
      }
    }
    
    # Detect high volume transfers (> 10MB)
    if [network.bytes] and [network.bytes] > 10485760 {
      mutate {
        id => "mutate_azure_nsg_high_volume"
        add_tag => ["high_volume_transfer"]
      }
    }
    
    # Detect potential port scanning (multiple denied connections)
    if [azure.nsg.traffic_decision] == "D" {
      mutate {
        id => "mutate_azure_nsg_potential_scan"
        add_tag => ["potential_port_scan"]
      }
    }
    
    # Detect connections to common malicious ports
    if [destination.port] {
      if [destination.port] == 4444 or [destination.port] == 5555 or [destination.port] == 6666 or [destination.port] == 7777 {
        mutate {
          id => "mutate_azure_nsg_suspicious_port"
          add_tag => ["suspicious_port"]
        }
      }
    }
    
    # Clean up
    mutate {
      id => "mutate_azure_nsg_cleanup"
      remove_field => ["message", "azure.records"]
    }
    
    # Note: GeoIP enrichment for source.ip and destination.ip will be handled
    # by Malcolm's existing 11_lookups.conf filter
    
  } # end if azure.nsgflowlogs

} # end filter
