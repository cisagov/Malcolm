# Copyright (c) 2025 Battelle Energy Alliance, LLC.  All rights reserved.

# final adjustments before forwarding

filter {

  # timestamp calculation
  ruby {
    id => "ruby_filescan_timestamp_calc"
    init => "
      require 'date'
      @parse_to_ms = ->(v) {
        begin
          v && !v.to_s.strip.empty? ?
            (DateTime.parse(v).to_time.to_f * 1000).round :
            nil
        rescue
          nil
        end
      }
    "
    code => "
      ts_val    = event.get('[@timestamp]').to_s
      start_ms = @parse_to_ms.call(event.get('[zeek][ts]')) || @parse_to_ms.call(event.get('[entity][raw][timestamp]')) || @parse_to_ms.call(event.get('[start]')) || @parse_to_ms.call(ts_val)
      end_ms   = @parse_to_ms.call(event.get('[end]')) || start_ms
      event.set('[firstPacket]', start_ms)
      event.set('[lastPacket]',  end_ms)
    "
    remove_field => [ "[start]", "[end]" ]
  }

  # hashes
  # https://www.elastic.co/guide/en/ecs/current/ecs-hash.html
  # https://www.elastic.co/guide/en/ecs/current/ecs-related.html
  if ([file][hash][md5]) {
    ruby {
      id => "ruby_filescan_file_hash_md5_make_unique"
      path => "/usr/share/logstash/malcolm-ruby/make_unique_array.rb"
      script_params => { "field" => "[file][hash][md5]" }
    }
    mutate { id => "mutate_filescan_file_hash_md5_makrelated"
             merge => { "[related][hash]" => "[file][hash][md5]" } }
  }

  if ([file][hash][sha1]) {
    ruby {
      id => "ruby_filescan_file_hash_sha1_make_unique"
      path => "/usr/share/logstash/malcolm-ruby/make_unique_array.rb"
      script_params => { "field" => "[file][hash][sha1]" }
    }
    mutate { id => "mutate_filescan_file_hash_sha1_marelated"
             merge => { "[related][hash]" => "[file][hash][sha1]" } }
  }

  if ([file][hash][sha256]) {
    ruby {
      id => "ruby_filescan_file_hash_sha256_make_unique"
      path => "/usr/share/logstash/malcolm-ruby/make_unique_array.rb"
      script_params => { "field" => "[file][hash][sha256]" }
    }
    mutate { id => "mutate_filescan_file_hash_sha256_related"
             merge => { "[related][hash]" => "[file][hash][sha256]" } }
  }

  if ([file][hash][ssdeep]) {
    ruby {
      id => "ruby_filescan_file_hash_ssdeep_make_unique"
      path => "/usr/share/logstash/malcolm-ruby/make_unique_array.rb"
      script_params => { "field" => "[file][hash][ssdeep]" }
    }
    mutate { id => "mutate_filescan_file_hash_ssdeep_related"
             merge => { "[related][hash]" => "[file][hash][ssdeep]" } }
  }

  if ([file][hash][tlsh]) {
    ruby {
      id => "ruby_filescan_file_hash_tlsh_make_unique"
      path => "/usr/share/logstash/malcolm-ruby/make_unique_array.rb"
      script_params => { "field" => "[file][hash][tlsh]" }
    }
    mutate { id => "mutate_filescan_file_hash_tlsh_marelated"
             merge => { "[related][hash]" => "[file][hash][tlsh]" } }
  }

  if ([file][mime_type]) {
    ruby {
      id => "ruby_filescan_mime_type_adjust_and_unique"
      code => "
        mimeTypes = Array(event.get('[file][mime_type]') || []).compact.map do |mt|
          mt = mt.to_s.strip
          mt.split(';')[0].strip.downcase
        end
        event.set('[file][mime_type]', mimeTypes.uniq.reject(&:empty?))
      "
    }
  }

  fingerprint {
    id => "fingerprint_filescan_hash"
    source => [ "[file][hash][sha256]",
                "[firstPacket]",
                "[lastPacket]",
                "[service][type]" ]
    concatenate_sources => true
    ecs_compatibility => "v8"
    method => "MURMUR3_128"
    base64encode => true
  }

  mutate { id => "mutate_filescan_final_tags_remove"
           remove_tag => [ "_dateparsefailure",
                           "_filebeat_filescan",
                           "_filebeat_filescan_hedgehog",
                           "_filebeat_filescan_malcolm_live",
                           "_filebeat_filescan_malcolm_upload",
                           "_filebeat_filescan_upload",
                           "_grokparsefailure",
                           "_jsonparsefailure",
                           "_jsonparsesuccess" ] }

  mutate {
    id => "mutate_filescan_remove_field_useless"
    remove_field => [
      "[id]",
      "[results][strelka][start]",
      "[results][strelka][end]",
      "[metadata][record]",
      "[results][strelka][result][request][attributes][metadata][record]",
      "[results][strelka][result][file][metadata][record]",
      "[entity][raw]"
    ]
  }

  mutate { id => "mutate_filescan_rename results"
           rename => { "[results]" => "[filescan][results]" } }

}
