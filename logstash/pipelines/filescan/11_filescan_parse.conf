#input { stdin { } }
#input {
#  file {
#    path => "/home/user/Desktop/strelka_example_results/simple.jsonline"
#    start_position => "beginning"
#    }
#}

filter {
  # json check
  if ([message] =~ /^{.*}$/) { 
    fingerprint {
      id => "fingerprint_fallback_event_hash"
      source => [ "[message]" ]
      concatenate_sources => true
      ecs_compatibility => "v8"
      method => "MURMUR3_128"
      base64encode => true
    }

    # parse the json
    json {
      id => "json_parse_filescan"
      source => "[message]"
      target => "[filescan]"
      add_tag => [ "_jsonparsesuccess" ]
      remove_field => [ "[message]" ]
    }
  
    # generic adds
    # https://www.elastic.co/guide/en/ecs/current/ecs-file.html

    # if ([filescan][file][name]) {
    #   mutate {
    #     id => "mutate_merge_normalize_filescan_filename"
    #     merge => { "[file][path]" => "[filescan][file][name]" }
    #   }
    # }

    # if ([filescan][scan][pe]) {
    #     ruby {
    #         code => "
    #             c = event.get('[filescan][scan][pe][sections]')
    #             c.each_with_index do |section, index|
    #                 event.set('[filescan][scan][pe][sections][#{index}][entropy]', section['entropy'].to_f)
    #             end
    #         "
    #     }
    # }
    # mutate {
    #     convert => { "[filescan][scan][pe][sections][entropy]" => "float" }
    # }

    # mutate {
    #   id => "mutate_rename_scanners"
    #   rename => { "[filescan][file][scanners]" => ""  }
    # }

    # TODO: also all the other fields
    # integration could potentially also make use of the filename


    # hashes
    # https://www.elastic.co/guide/en/ecs/current/ecs-hash.html
    # https://www.elastic.co/guide/en/ecs/current/ecs-related.html

    # if ([filescan][scan][hash][md5]) {
    #   mutate {
    #     id => "mutate_merge_field_file_hash_fileinfo_md5"
    #     merge => { "[file][hash][md5]" => "[filescan][scan][hash][md5]" }
    #   }

    #   mutate {
    #     id => "mutate_merge_field_related_hash_fileinfo_md5"
    #     merge => { "[related][hash]" => "[filescan][scan][hash][md5]" }
    #   }
    # }

    # if ([filescan][scan][hash][sha1]) {
    #   mutate {
    #     id => "mutate_merge_field_file_hash_fileinfo_sha1"
    #     merge => { "[file][hash][sha1]" => "[filescan][scan][hash][sha1]" }
    #   }

    #   mutate {
    #     id => "mutate_merge_field_related_hash_fileinfo_sha1"
    #     merge => { "[related][hash]" => "[filescan][scan][hash][sha1]" }
    #   }
    # }

    # if ([filescan][scan][hash][sha256]) {
    #   mutate {
    #     id => "mutate_merge_field_file_hash_fileinfo_sha256"
    #     merge => { "[file][hash][sha256]" => "[filescan][scan][hash][sha256]" }
    #   }

    #   mutate {
    #     id => "mutate_merge_field_related_hash_fileinfo_sha256"
    #     merge => { "[related][hash]" => "[filescan][scan][hash][sha256]" }
    #   }
    # }

    # if ([filescan][scan][hash][ssdeep]) {
    #   mutate {
    #     id => "mutate_merge_field_file_hash_fileinfo_ssdeep"
    #     merge => { "[file][hash][ssdeep]" => "[filescan][scan][hash][ssdeep]" }
    #   }

    #   mutate {
    #     id => "mutate_merge_field_related_hash_fileinfo_ssdeep"
    #     merge => { "[related][hash]" => "[filescan][scan][hash][ssdeep]" }
    #   }
    # }

    # if ([filescan][scan][hash][tlsh]) {
    #   mutate {
    #     id => "mutate_merge_field_file_hash_fileinfo_tlsh"
    #     merge => { "[file][hash][tlsh]" => "[filescan][scan][hash][tlsh]" }
    #   }

    #   mutate {
    #     id => "mutate_merge_field_related_hash_fileinfo_tlsh"
    #     merge => { "[related][hash]" => "[filescan][scan][hash][tlsh]" }
    #   }
    # }

    # File/MIME types ###################################################################################################
    # ECS -> various -> file.mime_type
    # collect all file/MIME types under the parent [file][mime_type] array

    # if ([filescan][file][flavors][mime]) {
    #   mutate {
    #     id => "mutate_merge_normalize_filescan_fileinfo_mime_type"
    #     merge => { "[file][mime_type]" => "[filescan][file][flavors][mime]" }
    #   } 
    # }

    # if ([filescan][scan][pe]) {
    #   # "mz_file" in [filescan][file][flavors][yara]
    #   # TODO: break file types into separate filters
    # }
    # if ([filescan][scan][elf]) {
    #   # "elf_file" in [filescan][file][flavors][yara]
    # }
    # if ([filescan][scan][macho]) {
    # }

    # if ([filescan][scan][clamav][signature]) {
    #     mutate {
    #       id => "add_clamav_hit_signature"
    #       copy => { "[filescan][scan][clamav][signature]" => "[rule][name]" }
    #       add_field => { "[event][module]" => "ClamAV" }
    #       add_field => { "[rule][category]" => "unknown" }
    #     }
    # }

    # mutate {
    #   id => "set_zeek_file_size"
    #   copy => { "[file][size]" => "[zeek.files.seen_bytes]" }
    # }

    # # remove some fields we currently don't want
    # prune {
    #   blacklist_names => ["elapsed"]
    # }

    # mutate {
    #   remove_field => ["[filescan][scan][pe][resources]"]
    # }


    #####
    # TODO set id for deduplication

  } else {
    drop { id => "drop_filescan_invalid_logs" }
  }

}

#output {
#  stdout { codec => rubydebug }
#}
