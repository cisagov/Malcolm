filter {

  # Map zeek fields to ECS where possible (see https://github.com/idaholab/Malcolm/issues/16)
  # For now I will add fields rather than rename them. This will preserve backwards compatibility
  # but the records will be somewhat bigger. I'll have to address what (if anything) to do with upgrades.

  #
  # Some fields (particularly AS and GEO fields) don't exist at this point in the pipeline, as they
  # are added during enrichment. In that case, I will make a note of it here and handle it in
  # ./pipelines/enrichment/20_enriched_to_ecs.conf:
  #
  # Autonomous System and Geo are handled after enrichment in 20_enriched_to_ecs.conf
  #  ðŸ—¹ Autonomous System - Fields describing an Autonomous System (Internet routing prefix). - https://www.elastic.co/guide/en/ecs/current/ecs-as.html
  #  ðŸ—¹ Geo - Fields describing a location. - https://www.elastic.co/guide/en/ecs/current/ecs-geo.html
  #
  # Risk/severity/priority/whatever will be done *after* enrichment based on normalized fields
  # - event.severity, event.risk_score and event.risk_score_norm
  #
  # TODO: certain other fields that I'm already normalizing for arkime could maybe be moved out of
  # here into enriched_to_ecs in the enrichment pipeline, but that kind of depends on what things
  # look like when we add more data sources in the future, or if arkime tackles ECS, etc.
  #

  # for now don't do anything unles an env explicitly enables it
  mutate {
    id => "mutate_add_field_env_logstash_zeek_to_ecs"
    add_field => { "[@metadata][ENV_LOGSTASH_ZEEK_TO_ECS]" => "${LOGSTASH_TO_ECS:false}" }
  }
  if ([@metadata][ENV_LOGSTASH_ZEEK_TO_ECS] == "true") {

    # I will mark these â˜ off with a ðŸ—¹ or ðŸ—· as I address them or decide they don't need adressing

    # ðŸ—¹ Network - Fields describing the communication path over which the event happened. - https://www.elastic.co/guide/en/ecs/current/ecs-network.html

    # network.direction handled during enrichment pipeline
    # network.name      handled during enrichment pipeline
    # network.type      handled during enrichment pipeline
    # TODO: some of these done here should probably be done after enrichment, too

    # network.application and network.protocol (TODO: what's the difference as far as my logs go)
    if ([zeek][service]) {
      mutate { id => "mutate_add_field_ecs_network_application"
               add_field => { "[network][application]" => "%{[zeek][service]}" } }
      mutate { id => "mutate_add_field_ecs_network_protocol"
               add_field => { "[network][protocol]" => "%{[zeek][service]}" } }
    }

    # network.iana_number
          if ([ipProtocol]) {                     mutate { id => "mutate_add_field_ecs_network_iana_number"
                                                           add_field => { "[network][iana_number]" => "%{[ipProtocol]}" } } }

    # network.transport
          if ([zeek][proto]) {                    mutate { id => "mutate_add_field_ecs_network_transport"
                                                           add_field => { "[network][transport]" => "%{[zeek][proto]}" } } }

    # â˜ Destination - Fields about the destination side of a network connection, used with source. - https://www.elastic.co/guide/en/ecs/current/ecs-destination.html
    # â˜ Source - Fields about the source side of a network connection, used with destination. - https://www.elastic.co/guide/en/ecs/current/ecs-source.html
    #   - These should be handled in the original parsing (in 11_zeek_logs.conf), are there other fields?

    # ðŸ—¹ Client - Fields about the client side of a network connection, used with server. - https://www.elastic.co/guide/en/ecs/current/ecs-client.html
    # as Arkime uses source/destination for network stuff (vs. client/server) we're doing that as well for zeek logs

    # client.domain
          if ([source][hostname]) {            mutate { id => "mutate_add_field_ecs_client_domain_source_hostname"
                                                           add_field => { "[client][domain]" => "%{[source][hostname]}" } } }
    else if ([zeek_dhcp][host_name]) {            mutate { id => "mutate_add_field_ecs_client_domain_dhcp_host_name"
                                                           add_field => { "[client][domain]" => "%{[zeek_dhcp][host_name]}" } } }
    else if ([zeek_dhcp][domain]) {               mutate { id => "mutate_add_field_ecs_client_domain_dhcp_domain"
                                                           add_field => { "[client][domain]" => "%{[zeek_dhcp][domain]}" } } }
    else if ([zeek_ntlm][host]) {                 mutate { id => "mutate_add_field_ecs_client_domain_ntlm_host_name"
                                                           add_field => { "[client][domain]" => "%{[zeek_ntlm][host]}" } } }
    else if ([zeek_ntlm][domain]) {               mutate { id => "mutate_add_field_ecs_client_domain_ntlm_domain"
                                                           add_field => { "[client][domain]" => "%{[zeek_ntlm][domain]}" } } }

    # ðŸ—¹ Server - Fields about the server side of a network connection, used with client. - https://www.elastic.co/guide/en/ecs/current/ecs-server.html
    # as Arkime uses source/destination for network stuff (vs. client/server) we're doing that as well for zeek logs

    # server.domain
          if ([destination][hostname]) {            mutate { id => "mutate_add_field_ecs_server_domain_destination_hostname"
                                                           add_field => { "[server][domain]" => "%{[destination][hostname]}" } } }

    # â˜ Event - Fields breaking down the event details. - https://www.elastic.co/guide/en/ecs/current/ecs-event.html

    # event.action from zeek.action
         if ([zeek][action]) {                    mutate { id => "mutate_add_field_ecs_event_action"
                                                           add_field => { "[event][action]" => "%{[zeek][action]}" } } }

    # event.dataset from zeek.logtype
    mutate { id => "mutate_add_field_ecs_event_dataset"
             add_field => { "[event][dataset]" => "zeek.%{[zeek][logType]}" } }

    # event.duration
    if ([zeek_conn][duration]) {
      # convert duration (floating-point seconds) to nanoseconds
      ruby {
        id => "ruby_zeek_duration_to_ecs_event_duration"
        code => "event.set('[event][duration]', (1000000000 * event.get('[zeek_conn][duration]').to_f).round(0))"
      }
    }

    # for event.start/event.end, we'll the arkime firstPacket/lastPacket field as we already did the math
    if ([firstPacket]) {                          mutate { id => "mutate_add_field_ecs_event_start"
                                                           add_field => { "[event][start]" => "%{[firstPacket]}" } } }
    if ([lastPacket]) {                           mutate { id => "mutate_add_field_ecs_event_end"
                                                           add_field => { "[event][end]" => "%{[lastPacket]}" } } }

    # UIDs and FUIDs constitude unique IDs
    if ([zeek][uid]) {                            mutate { id => "mutate_add_field_ecs_id_uid"
                                                           merge => { "[event][id]" => "[zeek][uid]" } } }
    if ([zeek][fuid]) {                           mutate { id => "mutate_add_field_ecs_id_fuid"
                                                           merge => { "[event][id]" => "[zeek][fuid]" } } }

    # event.provider
    if (![event][provider]) {                     mutate { id => "mutate_add_field_event_provider_zeek"
                                                           add_field => { "[event][provider]" => "zeek" } } }

    # event.kind - https://www.elastic.co/guide/en/ecs/current/ecs-allowed-values-event-kind.html
    if ([zeek_notice]) or ([zeek_signatures]) or ([zeek_weird]) {
      mutate { id => "mutate_add_field_ecs_event_kind_alert"
               add_field => { "[event][kind]" => "alert" } }
    } else {
      mutate { id => "mutate_add_field_ecs_event_kind_event"
               add_field => { "[event][kind]" => "event" } }
    }

    # event.category - https://www.elastic.co/guide/en/ecs/current/ecs-allowed-values-event-category.html
    translate {
      id => "translate_zeek_ecs_event_category"
      field => "[zeek][logType]"
      destination => "[event][category]"
      dictionary_path => "/etc/zeek_log_ecs_categories.yaml"
    }

    # TODO: this gets very granular and varies wildly per protocol, not sure I can translate these 100% from zeek.action and zeek.result
    # event.type - https://www.elastic.co/guide/en/ecs/current/ecs-allowed-values-event-type.html
    # event.outcome - https://www.elastic.co/guide/en/ecs/current/ecs-allowed-values-event-outcome.html
    # Eeesh, this is a swag...
    # if ([zeek][result]) {
    #   ruby {
    #     id => "ruby_ecs_event_outcome_zeek_result"
    #     code => "
    #       event.get('[zeek][result]').each { |zeekResult|
    #         zeekResult.downcase!
    #         if zeekResult =~ /(abo?rt|bad|busy|close|conflict|crit|declin|denied|deny|disabl|discon|down|err|exceed|exhaust|expir|fail|forbid|illeg|imposs|inappr|incorr|insuff|interrupt|misdirected|nak|no[ _-]*such|overload|problem|refus|reject|terminat|timeout|violat|wrong|(im|dis|mis|un|un|not)[ _-]*(avail|allow|assign|auth|deciph|process|permit|found|support|exist|enough|implem|known|ok|okay|reach|respond|consist|access|satis|succes|valid|want)|too[ _-]*(large|long|small|short|early|late|many|few))/
    #           event.set('[event][outcome]', 'failure')
    #           break
    #         elsif zeekResult =~ /(ok|okay|success|ack|complet|correct|good|ready|finish|valid)/
    #           event.set('[event][outcome]', 'success')
    #           break
    #         end
    #       }
    #     "
    #   }
    # }

    # â˜ DNS - Fields describing DNS queries and answers. - https://www.elastic.co/guide/en/ecs/current/ecs-dns.html
    if ([zeek_dns]) {

      # dns.resolved_ip
      if ([dns][ip]) {                            mutate { id => "mutate_merge_ecs_dhs_resolved_ip"
                                                           merge => { "[dns][resolved_ip]" => "[dns][ip]" } } }

      # dns.answers and dns.type:answer
      if ([zeek_dns][answers]) {
        ruby {
          id => "ruby_zeek_dns_answers_to_ecs"
          code => '
            event.set("[dns][answers]", [Array(event.get("[zeek_dns][answers]")), Array(event.get("[zeek_dns][TTLs]"))].transpose.map{ |d| Hash[[:data, :ttl].zip(d)] })
        '}
        mutate { id => "mutate_add_field_ecs_dns_type_answer"
                 add_field => { "[dns][type]" => "answer" } }
      }

      # dns.op_code
      if ([dns][opcode]) {                          mutate { id => "mutate_add_field_ecs_dns_opcode"
                                                             add_field => { "[dns][op_code]" => "%{[dns][opcode]}" } } }

      # dns.question.class
      if ([zeek_dns][qclass_name]) {                mutate { id => "mutate_add_field_ecs_dns_qclass"
                                                             add_field => { "[dns][question][class]" => "%{[zeek_dns][qclass_name]}" } } }

      # dns.question.type
      if ([zeek_dns][qtype_name]) {                 mutate { id => "mutate_add_field_ecs_dns_qtype"
                                                             add_field => { "[dns][question][type]" => "%{[zeek_dns][qtype_name]}" } } }

      # dns.question.name and dns.type:query
      if ([zeek_dns][query]) {
                            mutate { id => "mutate_add_field_ecs_dns_query"
                                     add_field => { "[dns][question][name]" => "%{[zeek_dns][query]}" } }
        if (![dns][type]) { mutate { id => "mutate_add_field_ecs_dns_type_query"
                                     add_field => { "[dns][type]" => "query" } } }
      }

      if ([dns][type]) {
        # dns.header_flags
        if ([zeek][AA] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_aa"
                                                             add_field => { "[dns][header_flags]" => "AA" } } }
        if ([zeek][TC] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_tc"
                                                             add_field => { "[dns][header_flags]" => "TC" } } }
        if ([zeek][RD] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_rd"
                                                             add_field => { "[dns][header_flags]" => "RD" } } }
        if ([zeek][RA] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_ra"
                                                             add_field => { "[dns][header_flags]" => "RA" } } }
      }

      # dns.response_code
      if ([zeek_dns][rcode_name]) {                 mutate { id => "mutate_add_field_ecs_dns_response_code"
                                                             add_field => { "[dns][response_code]" => "%{[zeek_dns][rcode_name]}" } } }

      # dns.id
      if ([zeek_dns][trans_id]) {                   mutate { id => "mutate_add_field_ecs_dns_id"
                                                             add_field => { "[dns][id]" => "%{[zeek_dns][trans_id]}" } } }

      # TODO: domain stuff (dns.question.registered_domain, dns.question.subdomain, dns.question.top_level_domain)
      # perhaps use something like https://github.com/plutonbacon/logstash-filter-publicsuffix
    }

    # ðŸ—¹ File - Fields describing files. - https://www.elastic.co/guide/en/ecs/current/ecs-file.html

    if ([zeek_files]) {

      # file.type
      mutate { id => "mutate_add_field_ecs_file_type"
               add_field => { "[file][type]" => "file" } }

      # file.directory, file.name, file.path
      if ([zeek_files][filename]) {
        mutate { id => "mutate_add_field_ecs_file_path"
                 add_field => { "[file][path]" => "%{[zeek_files][filename]}" } }
        grok {
          id => "grok_zeek_files_filename_ecs"
          match => { "[zeek_files][filename]" => [ "%{GREEDYDATA:[file][directory]}[\\\/]%{DATA:[file][name]}" ] }
        }
      }

      # file.mime_type
      if ([zeek_files][mime_type]) {                mutate { id => "mutate_add_field_ecs_files_mime_type"
                                                             add_field => { "[file][mime_type]" => "%{[zeek_files][mime_type]}" } } }

      # file.size
      if ([zeek_files][total_bytes]) {              mutate { id => "mutate_add_field_ecs_files_size"
                                                             add_field => { "[file][size]" => "%{[zeek_files][total_bytes]}" } } }

      # ðŸ—¹ Hash - Hashes, usually file hashes. - https://www.elastic.co/guide/en/ecs/current/ecs-hash.html
      # file.hash.md5,sha1,sha256
      if ([zeek_files][md5]) {                      mutate { id => "mutate_add_field_ecs_files_hash_md5"
                                                             add_field => { "[file][hash][md5]" => "%{[zeek_files][md5]}" } } }
      if ([zeek_files][sha1]) {                     mutate { id => "mutate_add_field_ecs_files_hash_sha1"
                                                             add_field => { "[file][hash][sha1]" => "%{[zeek_files][sha1]}" } } }
      if ([zeek_files][sha256]) {                   mutate { id => "mutate_add_field_ecs_files_hash_sha256"
                                                             add_field => { "[file][hash][sha256]" => "%{[zeek_files][sha256]}" } } }
    }

    if ([zeek_smb_files]) {

      # from smb_files, file.created,accessed,ctime,mtime,size
      if ([zeek_smb_files][times_created]) {        mutate { id => "mutate_add_field_ecs_smb_created"
                                                             add_field => { "[file][created]" => "%{[zeek_smb_files][times_created]}" } } }

      if ([zeek_smb_files][times_accessed]) {       mutate { id => "mutate_add_field_ecs_smb_accessed"
                                                             add_field => { "[file][accessed]" => "%{[zeek_smb_files][times_accessed]}" } } }

      if ([zeek_smb_files][times_changed]) {        mutate { id => "mutate_add_field_ecs_smb_changed"
                                                             add_field => { "[file][ctime]" => "%{[zeek_smb_files][times_changed]}" } } }

      if ([zeek_smb_files][times_modified]) {       mutate { id => "mutate_add_field_ecs_smb_modified"
                                                             add_field => { "[file][mtime]" => "%{[zeek_smb_files][times_modified]}" } } }

      if ([zeek_smb_files][size]) {                 mutate { id => "mutate_add_field_ecs_smb_size"
                                                             add_field => { "[file][size]" => "%{[zeek_smb_files][size]}" } } }

      # file.name from smb_files.name
      if (![file][name]) and ([zeek_smb_files][name]) {
        mutate { id => "mutate_add_field_ecs_file_smb_files_name"
                 add_field => { "[file][name]" => "%{[zeek_smb_files][name]}" } }
      }
    }

    # file.directory from zeek_smb_files.smb_path
    if ([@metadata][smb_path]) {
      if (![file][type]) { mutate { id => "mutate_add_field_ecs_file_type_smb_path"
                                    add_field => { "[file][type]" => "file" } } }

      mutate { id => "mutate_add_field_ecs_file_directory_from_smb"
               add_field => { "[file][directory]" => "%{[@metadata][smb_path]}" } }
    }

    # file.path from file.directory and file.name, if present and not already populated
    if ([file][directory]) and (![file][path]) {
      if ([file][name]) {
        mutate { id => "mutate_add_field_ecs_path_from_dir_and_name"
                 add_field => { "[file][path]" => "%{[file][directory]}/%{[file][name]}" } }
      } else {
        mutate { id => "mutate_add_field_ecs_path_from_dir_only"
                 add_field => { "[file][path]" => "%{[file][directory]}" } }
      }
    }

    if ([file][name]) {
      if (![file][type]) { mutate { id => "mutate_add_field_ecs_file_type_name"
                                    add_field => { "[file][type]" => "file" } } }

      # file.extension
      grok {
        id => "grok_zeek_files_fileext_ecs"
        match => { "[file][name]" => [ "%{GREEDYDATA}\.%{DATA:[file][extension]}" ] }
      }
    }

    # ðŸ—¹ HTTP - Fields describing an HTTP request. - https://www.elastic.co/guide/en/ecs/current/ecs-http.html
    if ([zeek_http]) {

      if ([zeek_http][request_body_len]) {        mutate { id => "mutate_add_field_ecs_http_request_body_bytes"
                                                           add_field => { "[http][request][body][bytes]" => "%{[zeek_http][request_body_len]}" } } }

      if ([zeek_http][method]) {                  mutate { id => "mutate_add_field_ecs_http_request_method"
                                                           add_field => { "[http][request][method]" => "%{[zeek_http][method]}" } } }

      if ([zeek_http][referrer]) {                mutate { id => "mutate_add_field_ecs_http_request_referrer"
                                                           add_field => { "[http][request][referrer]" => "%{[zeek_http][referrer]}" } } }

      if ([zeek_http][response_body_len]) {       mutate { id => "mutate_add_field_ecs_http_response_body_bytes"
                                                           add_field => { "[http][response][body][bytes]" => "%{[zeek_http][response_body_len]}" } } }

      if ([zeek_http][status_code]) {             mutate { id => "mutate_add_field_ecs_http_response_status_cocde"
                                                           add_field => { "[http][response][status_cocde]" => "%{[zeek_http][status_code]}" } } }

      if ([zeek_http][version]) {                 mutate { id => "mutate_add_field_ecs_http_version"
                                                           add_field => { "[http][version]" => "%{[zeek_http][version]}" } } }

      # â˜ URL - Fields that let you store URLs in various forms. - https://www.elastic.co/guide/en/ecs/current/ecs-url.html
      # todo: handle URIs from other protocols (SIP, FTP, ...)
      if ([zeek_http][uri]) or ([zeek_http][host]) {
        ruby {
          id => "ruby_ecs_uri_parse_from_zeek_http"
          init => "require 'uri'"
          code => "
            scheme = 'http'
            user = event.get('[zeek][user]')
            password = event.get('[zeek][password]')
            host = event.get('[zeek_http][host]')
            port = event.get('[zeek][resp_p]')
            uri = event.get('[zeek_http][uri]')
            ext = (uri.nil? || !(uri.include? '/')) ? nil : File.extname(uri).partition('.').last.split(/[\?#]/)[0]
            fragment = uri.nil? ? nil : uri.partition('#').last
            query = uri.nil? ? nil : uri.partition('?').last
            event.set('[url][scheme]', scheme)
            event.set('[url][original]', scheme + '://' + (host.nil? ? '' : host) + (uri.nil? ? '' : uri))
            event.set('[url][full]', scheme + '://' + (user.nil? ? '' : Array(user).first) + (password.nil? ? '' : ':' + password) + ((user.nil? && password.nil?) ? '' : '@') + (host.nil? ? '' : host) + (port.nil? ? '' : ':' + port) + (uri.nil? ? '' : uri))
            event.set('[url][domain]', host) unless host.nil?
            event.set('[url][extension]', ext) unless ext.nil? || ext.empty?
            event.set('[url][fragment]', fragment) unless fragment.nil? || fragment.empty?
            event.set('[url][password]', password) unless password.nil?
            event.set('[url][path]', uri) unless uri.nil?
            event.set('[url][port]', port) unless port.nil?
            event.set('[url][query]', query) unless query.nil? || query.empty?
            event.set('[url][user]', Array(user).first) unless user.nil?
          "
          # TODO: domain stuff (url.registered_domain, url.top_level_domain)
          # perhaps use something like https://github.com/plutonbacon/logstash-filter-publicsuffix
        }
      }
    }

    # ðŸ—¹ Related - Fields meant to facilitate pivoting around a piece of data. - https://www.elastic.co/guide/en/ecs/current/ecs-related.html

    # related.user (zeek.user is already the array we want)
    if ([zeek][user]) { mutate { id => "mutate_merge_field_related_zeek_user"
                                 merge => { "[related][user]" => "[zeek][user]" } } }

    # related.hash (accumulate all hash/fingerprint fields into related.hash)
    if ([zeek_files][md5]) {                      mutate { id => "mutate_merge_field_related_hash_files_md5"
                                                           merge => { "[related][hash]" => "[zeek_files][md5]" } } }
    if ([zeek_files][sha1]) {                     mutate { id => "mutate_merge_field_related_hash_files_sha1"
                                                           merge => { "[related][hash]" => "[zeek_files][sha1]" } } }
    if ([zeek_files][sha256]) {                   mutate { id => "mutate_merge_field_related_hash_files_sha256"
                                                           merge => { "[related][hash]" => "[zeek_files][sha256]" } } }
    if ([zeek_ssh][hassh]) {                      mutate { id => "mutate_merge_field_related_hash_ssh_hassh"
                                                           merge => { "[related][hash]" => "[zeek_ssh][hassh]" } } }
    if ([zeek_ssh][hasshServer]) {                mutate { id => "mutate_merge_field_related_hash_ssh_hasshServer"
                                                           merge => { "[related][hash]" => "[zeek_ssh][hasshServer]" } } }
    if ([zeek_ssl][ja3]) {                        mutate { id => "mutate_merge_field_related_hash_ssl_ja3"
                                                           merge => { "[related][hash]" => "[zeek_ssl][ja3]" } } }
    if ([zeek_ssl][ja3s]) {                       mutate { id => "mutate_merge_field_related_hash_zeek_ssl_ja3s"
                                                           merge => { "[related][hash]" => "[zeek_ssl][ja3s]" } } }

    # related.ip (all IP-type fields get rolled up into related.ip)
    if ([destination][geo][ip]) {                mutate { id => "mutate_merge_field_related_ip_zeek_destination_geo_ip"
                                                          merge => { "[related][ip]" => "[destination][geo][ip]" } } }
    if ([zeek][orig_h]) {                        mutate { id => "mutate_merge_field_related_ip_zeek_orig_h"
                                                          merge => { "[related][ip]" => "[zeek][orig_h]" } } }
    if ([zeek][resp_h]) {                        mutate { id => "mutate_merge_field_related_ip_zeek_resp_h"
                                                         merge => { "[related][ip]" => "[zeek][resp_h]" } } }
    if ([source][geo][ip]) {                     mutate { id => "mutate_merge_field_related_ip_zeek_source_geo_ip"
                                                          merge => { "[related][ip]" => "[source][geo][ip]" } } }
    if ([zeek_dhcp][assigned_ip]) {              mutate { id => "mutate_merge_field_related_ip_zeek_dhcp_assigned_ip"
                                                          merge => { "[related][ip]" => "[zeek_dhcp][assigned_ip]" } } }
    if ([zeek_dhcp][requested_ip]) {             mutate { id => "mutate_merge_field_related_ip_zeek_dhcp_requested_ip"
                                                          merge => { "[related][ip]" => "[zeek_dhcp][requested_ip]" } } }
    if ([zeek_enip_list_identity][device_ip]) {  mutate { id => "mutate_merge_field_related_ip_zeek_enip_list_identity_device_ip"
                                                          merge => { "[related][ip]" => "[zeek_enip_list_identity][device_ip]" } } }
    if ([zeek_files][rx_hosts]) {                mutate { id => "mutate_merge_field_related_ip_zeek_files_rx_hosts"
                                                          merge => { "[related][ip]" => "[zeek_files][rx_hosts]" } } }
    if ([zeek_files][tx_hosts]) {                mutate { id => "mutate_merge_field_related_ip_zeek_files_tx_hosts"
                                                          merge => { "[related][ip]" => "[zeek_files][tx_hosts]" } } }
    if ([zeek_ftp][data_channel_orig_h]) {       mutate { id => "mutate_merge_field_related_ip_zeek_ftp_data_channel_orig_h"
                                                          merge => { "[related][ip]" => "[zeek_ftp][data_channel_orig_h]" } } }
    if ([zeek_ftp][data_channel_resp_h]) {       mutate { id => "mutate_merge_field_related_ip_zeek_ftp_data_channel_resp_h"
                                                          merge => { "[related][ip]" => "[zeek_ftp][data_channel_resp_h]" } } }
    if ([zeek_notice][dst]) {                    mutate { id => "mutate_merge_field_related_ip_zeek_notice_dst"
                                                          merge => { "[related][ip]" => "[zeek_notice][dst]" } } }
    if ([zeek_notice][src]) {                    mutate { id => "mutate_merge_field_related_ip_zeek_notice_src"
                                                          merge => { "[related][ip]" => "[zeek_notice][src]" } } }
    if ([zeek_radius][framed_addr]) {            mutate { id => "mutate_merge_field_related_ip_zeek_radius_framed_addr"
                                                          merge => { "[related][ip]" => "[zeek_radius][framed_addr]" } } }
    if ([zeek_smtp][path]) {                     mutate { id => "mutate_merge_field_related_ip_zeek_smtp_path"
                                                          merge => { "[related][ip]" => "[zeek_smtp][path]" } } }
    if ([zeek_smtp][x_originating_ip]) {         mutate { id => "mutate_merge_field_related_ip_zeek_smtp_x_originating_ip"
                                                          merge => { "[related][ip]" => "[zeek_smtp][x_originating_ip]" } } }
    if ([zeek_socks][bound_host]) {              mutate { id => "mutate_merge_field_related_ip_zeek_socks_bound_host"
                                                          merge => { "[related][ip]" => "[zeek_socks][bound_host]" } } }
    if ([zeek_socks][request_host]) {            mutate { id => "mutate_merge_field_related_ip_zeek_socks_request_host"
                                                          merge => { "[related][ip]" => "[zeek_socks][request_host]" } } }
    if ([zeek_x509][san_ip]) {                   mutate { id => "mutate_merge_field_related_ip_zeek_x509_san_ip"
                                                          merge => { "[related][ip]" => "[zeek_x509][san_ip]" } } }
    if ([related][ip]) {
      ruby {
        id => "ruby_related_ip_uniq"
        path => "/usr/share/logstash/malcolm-ruby/make_unique_array.rb"
        script_params => {
          "field" => "[related][ip]"
        }
      }
    }

    # ðŸ—¹ Rule - Fields to capture details about rules used to generate alerts or other notable events. - https://www.elastic.co/guide/en/ecs/current/ecs-rule.html
    #   - signatures
    #     - engine - >rule.author
    #     - signature_id -> rule.name
    #     - event_msg -> rule.description
    #   - notice
    #     - category -> rule.category, rule.author (mapped), rule.reference (mapped), rule.license (mapped)
    #     - sub_category -> rule.name
    #   - weird
    #     - name -> rule.name

    if ([zeek_signatures]) {
      if ([zeek_signatures][engine]) {       mutate { id => "mutate_merge_field_ecs_rule_author_signatures_engine"
                                                      merge => { "[rule][author]" => "[zeek_signatures][engine]" } } }

      if ([zeek_signatures][signature_id]) { mutate { id => "mutate_add_field_ecs_rule_id_signature_name"
                                                      merge => { "[rule][name]" => "[zeek_signatures][signature_id]" } } }

      if ([zeek_signatures][event_msg]) {    mutate { id => "mutate_add_field_ecs_rule_id_signature_event_msg"                                                      merge => { "[rule][description]" => "[zeek_signatures][event_msg]" } } }
    }

    if ([zeek_notice]) {

      mutate { id => "mutate_add_field_ecs_rule_ruleset_notice_zeek"
               add_field => { "[rule][ruleset]" => "Zeek Notices" } }

      if ([zeek_notice][category]) {     mutate { id => "mutate_add_field_ecs_rule_category_notice_category"
                                                  add_field => { "[rule][category]" => "%{[zeek_notice][category]}" } } }

      if ([zeek_notice][sub_category]) { mutate { id => "mutate_add_field_ecs_rule_category_notice_sub_category"
                                                  add_field => { "[rule][name]" => "%{[zeek_notice][sub_category]}" } } }

      translate {
        id => "translate_zeek_notice_author"
        field => "[zeek_notice][category]"
        destination => "[@metadata][zeek_noticed_mapped_author]"
        dictionary_path => "/etc/notice_authors.yaml"
        fallback => "Zeek"
      }
      if ([@metadata][zeek_noticed_mapped_author]) {
        mutate { id => "mutate_merge_zeek_noticed_mapped_author"
                 merge => { "[rule][author]" => "[@metadata][zeek_noticed_mapped_author]" } }
      }

      translate {
        id => "translate_zeek_notice_reference"
        field => "[zeek_notice][category]"
        destination => "[@metadata][zeek_noticed_mapped_reference]"
        dictionary_path => "/etc/notice_reference.yaml"
        fallback => "https://docs.zeek.org/en/current/zeek-noticeindex.html"
      }
      if ([@metadata][zeek_noticed_mapped_reference]) {
        mutate { id => "mutate_merge_zeek_noticed_mapped_reference"
                 merge => { "[rule][reference]" => "[@metadata][zeek_noticed_mapped_reference]" } }
      }

      translate {
        id => "translate_zeek_notice_license"
        field => "[zeek_notice][category]"
        destination => "[@metadata][zeek_noticed_mapped_license]"
        dictionary_path => "/etc/notice_license.yaml"
        fallback => "https://raw.githubusercontent.com/zeek/zeek/master/COPYING"
      }
      if ([@metadata][zeek_noticed_mapped_license]) {
        mutate { id => "mutate_merge_zeek_noticed_mapped_license"
                 merge => { "[rule][license]" => "[@metadata][zeek_noticed_mapped_license]" } }
      }

    }

    if ([zeek_weird][name]) {
      mutate { id => "mutate_add_field_ecs_rule_author_zeek_weird"
               add_field => { "[rule][author]" => "Zeek" } }
      mutate { id => "mutate_add_field_ecs_rule_ruleset_zeek_weird"
               add_field => { "[rule][ruleset]" => "Zeek Weird Logs" } }
      mutate { id => "mutate_add_field_ecs_rule_reference_zeek_weird"
               add_field => { "[rule][reference]" => "https://docs.zeek.org/en/current/scripts/base/frameworks/notice/weird.zeek.html" } }
      mutate { id => "mutate_add_field_ecs_rule_name_weird_name"
               add_field => { "[rule][name]" => "%{[zeek_weird][name]}" } }
    }

    # ðŸ—¹ Threat - Fields to classify events and alerts according to a threat taxonomy. - https://www.elastic.co/guide/en/ecs/current/ecs-threat.html
    if ([zeek_notice]) {

      if ([zeek_notice][category] == "ATTACK") {

        # populate threat information for MITRE ATT&CK notices from mitre-attack/bzar plugin
        mutate { id => "mutate_add_field_ecs_threat_framework_mitre_attack"
                 add_field => { "[threat][framework]" => "MITRE ATT&CK" } }

        if ([zeek_notice][sub_category]) {
          mutate { id => "mutate_add_field_ecs_threat_tactic_name_mitre"
                   add_field => { "[threat][tactic][name]" => "%{[zeek_notice][sub_category]}" } }
          mutate { id => "mutate_gsub_ecs_threat_tactic_name_notice_sub"
                   gsub => [ "[threat][tactic][name]", "_,", " " ] }
          translate {
            id => "translate_zeek_mitre_attack_tactic_name_to_id"
            field => "[zeek_notice][sub_category]"
            destination => "[threat][tactic][id]"
            dictionary_path => "/etc/mitre_attack_tactic_ids.yaml"
          }
          translate {
            id => "translate_zeek_mitre_attack_tactic_name_to_reference"
            field => "[zeek_notice][sub_category]"
            destination => "[threat][tactic][reference]"
            dictionary_path => "/etc/mitre_attack_tactic_reference.yaml"
            fallback => "https://attack.mitre.org/tactics/enterprise/"
          }
        }

        if ([zeek_notice][sub]) and ([zeek_notice][sub] =~ /^T/) {
          # eg., T1077 Windows Admin Shares + T1105 Remote File Copy
          ruby {
            id => "ruby_ecs_threat_technique_from_attack"
            code => "
              idArray = Array.new
              nameArray = Array.new
              event.get('[zeek_notice][sub]').split('+').each do |technique|
                id, name = technique.strip.match(/(^T.*?)\s+(.+$)/).captures
                idArray.push(id) unless id.nil?
                nameArray.push(name) unless name.nil?
              end
              event.set('[threat][technique][id]', idArray)
              event.set('[threat][technique][name]', nameArray)
              event.set('[threat][technique][reference]', idArray.clone.map(&:clone).map{|x| x.prepend('https://attack.mitre.org/techniques/')})
            "
          }
        }

      } else if ([zeek_notice][category] == "EternalSafety") {
        # populate threat information for EternalSafety from 0xl3x1/zeek-EternalSafety plugin
        mutate { id => "mutate_add_field_ecs_threat_framework_eternal_safety"
                 add_field => { "[threat][framework]" => "EternalSafety" } }
        if ([zeek_notice][sub_category]) { mutate { id => "mutate_add_field_ecs_threat_technique_name_eternal"
                                                    add_field => { "[threat][technique][name]" => "%{[zeek_notice][sub_category]}" } } }
        if ([rule][reference])           { mutate { id => "mutate_add_field_ecs_threat_technique_reference_eternal"
                                                    add_field => { "[threat][technique][reference]" => "%{[rule][reference]}" } } }
      }

    }

    # ðŸ—¹ TLS - Fields describing a TLS connection. - https://www.elastic.co/guide/en/ecs/current/ecs-tls.html
    if ([zeek_ssl]) {

      if ([zeek_ssl][ssl_version]) {
        # turn TLSv10, TLSv13, TSLv12, etc. to 'tls' and '1.2', etc.
        # TODO: tls.cipher already exists as a Arkime field, will this conflict/duplicate that?
        # EDIT: it won't duplicate it, but it will replace it. I guess that's okay for now.
        ruby {
          id => "ruby_ecs_ssl_version_parse"
          code => "
            verMatch = event.get('[zeek_ssl][ssl_version]').tr('.', '').match(/(.+)\s*[v-]\s*([\d\.]+)/i)
            verParts = verMatch.nil? ? nil : verMatch.captures
            unless verParts.nil?
              event.set('[tls][version_protocol]', verParts[0].downcase)
              event.set('[tls][version]', verParts[1].split(//).join('.'))
            end
          "
        }
      }

      if ([zeek_ssl][established]) {          mutate { id => "mutate_add_field_ecs_zeek_tls_established"
                                                       add_field => { "[tls][established]" => "%{[zeek_ssl][established]}" } } }

      if ([zeek_ssl][resumed]) {              mutate { id => "mutate_add_field_ecs_zeek_tls_resumed"
                                                       add_field => { "[tls][resumed]" => "%{[zeek_ssl][resumed]}" } } }

      if ([zeek_ssl][next_protocol]) {
        mutate { id => "mutate_add_field_ecs_zeek_tls_next_protocol"
                       add_field => { "[tls][next_protocol]" => "%{[zeek_ssl][next_protocol]}" } }
        mutate { id => "mutate_lowercase_field_ecs_zeek_tls_next_protocol"
                 lowercase => [ "[tls][next_protocol]" ] }
      }

      # TODO: tls.cipher already exists as a Arkime field, will this conflict/duplicate that?
      # EDIT: apparently it does duplicate the value, so I'm commenting this out for now...
      #if ([zeek_ssl][cipher]) {               mutate { id => "mutate_add_field_ecs_zeek_tls_cipher"
      #                                                 add_field => { "[tls][cipher]" => "%{[zeek_ssl][cipher]}" } } }

      if ([zeek_ssl][curve]) {                mutate { id => "mutate_add_field_ecs_zeek_tls_client_curve"
                                                       add_field => { "[tls][curve]" => "%{[zeek_ssl][curve]}" } } }

      if ([zeek_ssl][ja3]) {                  mutate { id => "mutate_add_field_ecs_zeek_tls_client_ja3"
                                                       add_field => { "[tls][client][ja3]" => "%{[zeek_ssl][ja3]}" } } }

      if ([zeek_ssl][client_issuer_full]) {   mutate { id => "mutate_add_field_ecs_zeek_tls_client_issuer_full"
                                                       add_field => { "[tls][client][issuer]" => "%{[zeek_ssl][client_issuer_full]}" } } }

      if ([zeek_ssl][client_subject_full]) {  mutate { id => "mutate_add_field_ecs_zeek_tls_client_subject_full"
                                                       add_field => { "[tls][client][subject]" => "%{[zeek_ssl][client_subject_full]}" } } }

      if ([zeek_ssl][server_name]) {
        mutate { id => "mutate_add_field_ecs_zeek_tls_client_server_name"
                 add_field => { "[tls][client][server_name]" => "%{[zeek_ssl][server_name]}" } }
        mutate { id => "mutate_add_field_ecs_zeek_tls_client_server_name_destination_domain"
                 add_field => { "[destination][domain]" => "%{[zeek_ssl][server_name]}" } }
      }

      if ([zeek_ssl][issuer_full]) {          mutate { id => "mutate_add_field_ecs_zeek_tls_issuer_full"
                                                       add_field => { "[tls][server][issuer]" => "%{[zeek_ssl][issuer_full]}" } } }

      if ([zeek_ssl][ja3s]) {                 mutate { id => "mutate_add_field_ecs_zeek_tls_server_ja3s"
                                                       add_field => { "[tls][server][ja3s]" => "%{[zeek_ssl][ja3s]}" } } }

      if ([zeek_ssl][subject_full]) {         mutate { id => "mutate_add_field_ecs_zeek_tls_subject_full"
                                                       add_field => { "[tls][server][subject]" => "%{[zeek_ssl][subject_full]}" } } }
    }

    # â˜ User agent - Fields to describe a browser user_agent string. - https://www.elastic.co/guide/en/ecs/current/ecs-user_agent.html
    #    - TODO: potentially more parsing could be done for user agent strings (.name, .device.name, .version)
    if ([zeek][user_agent]) { mutate { id => "mutate_merge_field_zeek_original_user_agent"
                                        merge => { "[user_agent][original]" => "[zeek][user_agent]" } } }

    # â˜ Agent - Fields about the monitoring agent. - https://www.elastic.co/guide/en/ecs/current/ecs-agent.html
    #   - agent will be set for logs coming from a sensor (hedgehog)
    #   - double-check agent set for local Malcolm filebeat Zeek logs to ensure it's set correctly, too
    # â˜ Observer - Fields describing an entity observing the event from outside the host. - https://www.elastic.co/guide/en/ecs/current/ecs-observer.html
    #   - anything useful we could get here from either Malcolm or Hedgehog?

    # â˜ Error - Fields about errors of any kind. - https://www.elastic.co/guide/en/ecs/current/ecs-error.html
    #   - There could be a lot of cases where there are errors, do we lump them all in here? we'd need to idenfity
    #     instances of error, error_msg, reply, status code, etc...
    # â˜ User - Fields to describe the user relevant to the event. - https://www.elastic.co/guide/en/ecs/current/ecs-user.html
    #   - a *lot* of the details ECS wants for the user (client, destination, email, domain, etc.) aren't provided by Zeek
    #     also, it appears that there is an issue with type mismatch between Arkime's "user" field and ECS "user.name", etc.
    # â˜ Vulnerability - Fields to describe the vulnerability relevant to an event. - https://www.elastic.co/guide/en/ecs/current/ecs-vulnerability.html
    #   - There are some CVE zeek plugins, they may be mappable to this (?)
    # â˜ VLAN - Fields to describe observed VLAN information. - https://www.elastic.co/guide/en/ecs/current/ecs-vlan.html
    #   - conflicts with Arkime's VLAN field:
    #       Can't merge a non object mapping [vlan] with an object mapping [vlan]", "caused_by"=>{"type"=>"illegal_argument_exception",
    #       "reason"=>"Can't merge a non object mapping [vlan] with an object mapping [vlan]

    # ðŸ—· Base - All fields defined directly at the top level - https://www.elastic.co/guide/en/ecs/current/ecs-base.html
    # ðŸ—· Cloud - Fields about the cloud resource. - https://www.elastic.co/guide/en/ecs/current/ecs-cloud.html
    # ðŸ—· Code Signature - These fields contain information about binary code signatures. - https://www.elastic.co/guide/en/ecs/current/ecs-code_signature.html
    # ðŸ—· Container - Fields describing the container that generated this event. - https://www.elastic.co/guide/en/ecs/current/ecs-container.html
    # ðŸ—· DLL - These fields contain information about code libraries dynamically loaded into processes. - https://www.elastic.co/guide/en/ecs/current/ecs-dll.html
    # ðŸ—· ECS - Meta-information specific to ECS. - https://www.elastic.co/guide/en/ecs/current/ecs-ecs.html
    # ðŸ—· Group - User's group relevant to the event. - https://www.elastic.co/guide/en/ecs/current/ecs-group.html
    # ðŸ—· Host - Fields describing the relevant computing instance. - https://www.elastic.co/guide/en/ecs/current/ecs-host.html
    # ðŸ—· Interface - Fields to describe observer interface information. - https://www.elastic.co/guide/en/ecs/current/ecs-interface.html
    # ðŸ—· Log - Details about the event's logging mechanism. - https://www.elastic.co/guide/en/ecs/current/ecs-log.html
    # ðŸ—· Operating System - OS fields contain information about the operating system. - https://www.elastic.co/guide/en/ecs/current/ecs-os.html
    # ðŸ—· Organization - Fields describing the organization or company the event is associated with. - https://www.elastic.co/guide/en/ecs/current/ecs-organization.html
    # ðŸ—· Package - These fields contain information about an installed software package. - https://www.elastic.co/guide/en/ecs/current/ecs-package.html
    #   - I almost mapped "software" to this but it doesn't really line up (installed packages vs. software network traffic observed)
    # ðŸ—· PE Header - These fields contain Windows Portable Executable (PE) metadata. - https://www.elastic.co/guide/en/ecs/current/ecs-pe.html
    #   - You would think zeek_pe would line up here, but this is just header stuff specific to windows executables and there's not much that lines up
    # ðŸ—· Process - These fields contain information about a process. - https://www.elastic.co/guide/en/ecs/current/ecs-process.html
    # ðŸ—· Registry - Fields related to Windows Registry operations. - https://www.elastic.co/guide/en/ecs/current/ecs-registry.html
    # ðŸ—· Service - Fields describing the service for or from which the data was collected. - https://www.elastic.co/guide/en/ecs/current/ecs-service.html
    # ðŸ—· Tracing - Fields related to distributed tracing. - https://www.elastic.co/guide/en/ecs/current/ecs-tracing.html

  } # end if ENV_LOGSTASH_ZEEK_TO_ECS

}
