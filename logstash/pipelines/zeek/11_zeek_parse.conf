######################## # zeek -> arkime session creation and enrichment
#
# see https://docs.zeek.org/en/stable/script-reference/log-files.html for Zeek logfile documentation
#
# see source.zeeklogs.js for the Arkime code that turns these into UI fields
#
# to profile, debug:
#   - get filters sorted by execution time (where in > 0)
#   $ docker-compose exec logstash curl -XGET http://localhost:9600/_node/stats/pipelines | jq -r '.. | .filters? // empty | .[] | objects | select (.events.in > 0) | [.id, .events.in, .events.out, .events.duration_in_millis] | join (";")' | sort -n -t ';' -k4
#   - get filters where in != out
#   $ docker-compose exec logstash curl -XGET http://localhost:9600/_node/stats/pipelines | jq -r '.. | .filters? // empty | .[] | objects | select (.events.in != .events.out) | [.id, .events.in, .events.out, .events.duration_in_millis] | join (";")'
#
# Copyright (c) 2023 Battelle Energy Alliance, LLC.  All rights reserved.
#######################

filter {

  # The Dissect is WAY faster than CSV, and quite a bit faster than mutate.split. However, it
  # is not as flexible when it comes to missing or extra columns
  # (See https://github.com/logstash-plugins/logstash-filter-dissect/issues/62)
  #
  # So, if the dissect filter fails, we're going to fall back to split-then-zip solution.
  # This should be a good tradeoff between performance (in the case where the Zeek logs
  # match what we think they should look like) and flexibility (when they don't).
  #
  # The one drawback is that if you make a change to the fields in dissect, make sure
  # you make the corresponding change in the ruby init code.

  if ([log_source] == "conn") {
    #############################################################################################################################
    # conn.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/conn/main.zeek.html#type-Conn::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap conn.log field configuration version 0
      #
      # Todo: I need to just bite the bullet and code this up in a Ruby block rather than hardcoding values.
      #
      # vlan + mac + community_id:  0x3ffffff / 67108863
      # vlan + mac:                 0x1ffffff / 33554431
      # mac + community_id:         0x39fffff / 60817407
      # mac only:                   0x19fffff / 27262975
      # vlan + community_id:        0x27fffff / 41943039
      # vlan only:                   0x7fffff /  8388607
      # community_id only:           0x1fffff /  2097151
      # no custom fields:

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 67108863) {
          # conn.log has vlans + macs + community_id
          dissect {
            id => "dissect_zeek_conn_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 33554431) {
          # conn.log has vlans + macs
          dissect {
            id => "dissect_zeek_conn_with_vlan_and_mac_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 60817407) {
          # conn.log has macs + community_id
          dissect {
            id => "dissect_zeek_conn_with_mac_and_community_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 27262975) {
          # conn.log has macs
          dissect {
            id => "dissect_zeek_conn_with_mac_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 41943039) {
          # conn.log has vlans + community_id
          dissect {
            id => "dissect_zeek_conn_with_vlan_and_community_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 8388607) {
          # conn.log has vlans
          dissect {
            id => "dissect_zeek_conn_with_vlan_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 2097151) {
          # conn.log has community_id
          dissect {
            id => "dissect_zeek_conn_with_community_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 2097151) {
          # conn.log has no custom fields
          dissect {
            id => "dissect_zeek_conn_with_minimal_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}"
            }
          }

        } else {
          # who knows? the conn.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_conn_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the conn.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_conn_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the conn.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_conn_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_conn"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_conn"
        init => "$zeek_conn_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'service', 'duration', 'orig_bytes', 'resp_bytes', 'conn_state', 'local_orig', 'local_resp', 'missed_bytes', 'history', 'orig_pkts', 'orig_ip_bytes', 'resp_pkts', 'resp_ip_bytes', 'tunnel_parents', 'vlan', 'inner_vlan', 'orig_l2_addr', 'resp_l2_addr', 'community_id' ]"
        code => "event.set('[zeek_cols]', $zeek_conn_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    # normalize service string(s)

    # some services are named like blah_udp/blah_tcp/blah_data, and we don't care about the suffix
    mutate { id => "mutate_gsub_field_zeek_conn_service_protocol_suffix"
             gsub => [ "[zeek_cols][service]", "[_-](tcp|udp|data)", "" ] }

    if ([zeek_cols][service] =~ /spicy_/) {
      # if it's coming from spicy, we don't care to have that in the service name
      mutate { id => "mutate_gsub_field_zeek_conn_service_spicy_prefix"
               gsub => [ "[zeek_cols][service]", "spicy_", "" ] }

      mutate { id => "mutate_gsub_field_zeek_conn_service_spicy_cipher_suffix"
               gsub => [ "[zeek_cols][service]", "(_hmac)?(_(sha|md)\d+)?$", "" ] }
    }

    if ([zeek_cols][orig_ip_bytes]) and ([zeek_cols][orig_ip_bytes] != '-') and ([zeek_cols][orig_ip_bytes] != '(empty)') and ([zeek_cols][orig_ip_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_srcBytes"
               add_field => { "[source][bytes]" => "%{[zeek_cols][orig_ip_bytes]}" } }
    }
    if ([zeek_cols][resp_ip_bytes]) and ([zeek_cols][resp_ip_bytes] != '-') and ([zeek_cols][resp_ip_bytes] != '(empty)') and ([zeek_cols][resp_ip_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_dstBytes"
               add_field => { "[destination][bytes]" => "%{[zeek_cols][resp_ip_bytes]}" } }
    }
    if ([zeek_cols][orig_pkts]) and ([zeek_cols][orig_pkts] != '-') and ([zeek_cols][orig_pkts] != '(empty)') and ([zeek_cols][orig_pkts] != '') {
      mutate { id => "mutate_add_field_zeek_srcPackets"
               add_field => { "[source][packets]" => "%{[zeek_cols][orig_pkts]}" } }
    }
    if ([zeek_cols][orig_bytes]) and ([zeek_cols][orig_bytes] != '-') and ([zeek_cols][orig_bytes] != '(empty)') and ([zeek_cols][orig_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_srcDataBytes"
               add_field => { "[client][bytes]" => "%{[zeek_cols][orig_bytes]}" } }
    }
    if ([zeek_cols][resp_pkts]) and ([zeek_cols][resp_pkts] != '-') and ([zeek_cols][resp_pkts] != '(empty)') and ([zeek_cols][resp_pkts] != '') {
      mutate { id => "mutate_add_field_zeek_dstPackets"
               add_field => { "[destination][packets]" => "%{[zeek_cols][resp_pkts]}" } }
    }
    if ([zeek_cols][resp_bytes]) and ([zeek_cols][resp_bytes] != '-') and ([zeek_cols][resp_bytes] != '(empty)') and ([zeek_cols][resp_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_dstDataBytes"
               add_field => { "[server][bytes]" => "%{[zeek_cols][resp_bytes]}" } }
    }
    if ([zeek_cols][tunnel_parents]) and ([zeek_cols][tunnel_parents] != '(empty)') and ([zeek_cols][tunnel_parents] != '-') and ([zeek_cols][tunnel_parents] != '') {
      mutate { id => "mutate_split_zeek_tunnel_parents"
               split => { "[zeek_cols][tunnel_parents]" => "," } }
      mutate { id => "mutate_add_field_zeek_conn_rootId"
               add_field => { "[rootId]" => "%{[zeek_cols][tunnel_parents][0]}" } }
    }

  } else if ([log_source] == "bacnet") {
    #############################################################################################################################
    # bacnet.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bacnet"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][bvlc_function]}	%{[zeek_cols][pdu_type]}	%{[zeek_cols][pdu_service]}	%{[zeek_cols][invoke_id]}	%{[zeek_cols][result_code]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bacnet"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bacnet"
        init => "$zeek_bacnet_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'is_orig', 'bvlc_function', 'pdu_type', 'pdu_service', 'invoke_id', 'result_code' ]"
        code => "event.set('[zeek_cols]', $zeek_bacnet_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bacnet"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bacnet"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bestguess") {
    #############################################################################################################################
    # bestguess.log

    dissect {
      id => "dissect_zeek_bestguess"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][name]}	%{[zeek_cols][category]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bestguess"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bestguess"
        init => "$zeek_bestguess_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'name', 'category' ]"
        code => "event.set('[zeek_cols]', $zeek_bestguess_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_tag_ics_best_guess_log"
             add_tag => [ "ics_best_guess" ] }

  } else if ([log_source] == "bsap_ip_header") {
    #############################################################################################################################
    # bsap_ip_header.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_ip_header"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][num_msg]}	%{[zeek_cols][type_name]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_ip_header"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_ip_header"
        init => "$zeek_bsap_ip_header_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'num_msg', 'type_name' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_ip_header_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_ip_header"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bsap"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bsap_ip_rdb") {
    #############################################################################################################################
    # bsap_ip_rdb.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_ip_rdb"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][header_size]}	%{[zeek_cols][mes_seq]}	%{[zeek_cols][res_seq]}	%{[zeek_cols][data_len]}	%{[zeek_cols][sequence]}	%{[zeek_cols][app_func_code]}	%{[zeek_cols][node_status]}	%{[zeek_cols][func_code]}	%{[zeek_cols][variable_count]}	%{[zeek_cols][variables]}	%{[zeek_cols][variable_value]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_ip_rdb"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_ip_rdb"
        init => "$zeek_bsap_ip_rdb_field_names = [ 'ts', 'uid', 'header_size', 'mes_seq', 'res_seq', 'data_len', 'sequence', 'app_func_code', 'node_status', 'func_code', 'variable_count', 'variables', 'variable_value' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_ip_rdb_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_ip_rdb"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bsap"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bsap_serial_header") {
    #############################################################################################################################
    # bsap_serial_header.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_serial_header"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][ser]}	%{[zeek_cols][dadd]}	%{[zeek_cols][sadd]}	%{[zeek_cols][ctl]}	%{[zeek_cols][dfun]}	%{[zeek_cols][seq]}	%{[zeek_cols][sfun]}	%{[zeek_cols][nsb]}	%{[zeek_cols][type_name]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_serial_header"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_serial_header"
        init => "$zeek_bsap_serial_header_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'ser', 'dadd', 'sadd', 'ctl', 'dfun', 'seq', 'sfun', 'nsb', 'type_name' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_serial_header_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_serial_header"
      add_field => {
        "[zeek_cols][proto]" => "serial"
        "[zeek_cols][service]" => "bsap"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bsap_serial_rdb") {
    #############################################################################################################################
    # bsap_serial_rdb.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_serial_rdb"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][func_code]}	%{[zeek_cols][variable_count]}	%{[zeek_cols][variables]}	%{[zeek_cols][variable_value]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_serial_rdb"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_serial_rdb"
        init => "$zeek_bsap_serial_rdb_field_names = [ 'ts', 'uid', 'func_code', 'variable_count', 'variables', 'variable_value' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_serial_rdb_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_serial_rdb"
      add_field => {
        "[zeek_cols][proto]" => "serial"
        "[zeek_cols][service]" => "bsap"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bsap_serial_rdb_ext") {
    #############################################################################################################################
    # bsap_serial_rdb_ext.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_serial_rdb_ext"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][dfun]}	%{[zeek_cols][seq]}	%{[zeek_cols][sfun]}	%{[zeek_cols][nsb]}	%{[zeek_cols][extfun]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_serial_rdb_ext"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_serial_rdb_ext"
        init => "$zeek_bsap_serial_rdb_ext_field_names = [ 'ts', 'uid', 'dfun', 'seq', 'sfun', 'nsb', 'extfun', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_serial_rdb_ext_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_serial_rdb_ext"
      add_field => {
        "[zeek_cols][proto]" => "serial"
        "[zeek_cols][service]" => "bsap"
      }
      add_tag => [ "ics" ]
    }

    # for now, drop hex-encoded binary data for size
    if ([zeek_cols][data]) {
      mutate { id => "mutate_remove_field_zeek_bsap_serial_rdb_ext_data"
               remove_field => [ "[zeek_cols][data]" ] }
    }

  } else if ([log_source] == "bacnet_device_control") {
    #############################################################################################################################
    # bacnet_device_control.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bacnet_device_control"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][invoke_id]}	%{[zeek_cols][pdu_service]}	%{[zeek_cols][time_duration]}	%{[zeek_cols][device_state]}	%{[zeek_cols][password]}	%{[zeek_cols][result]}	%{[zeek_cols][result_code]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bacnet_device_control"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bacnet_device_control"
        init => "$zeek_bacnet_device_control_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'is_orig', 'invoke_id', 'pdu_service', 'time_duration', 'device_state', 'password', 'result', 'result_code' ]"
        code => "event.set('[zeek_cols]', $zeek_bacnet_device_control_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bacnet_device_control"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bacnet"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bacnet_discovery") {
    #############################################################################################################################
    # bacnet_discovery.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bacnet_discovery"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][pdu_service]}	%{[zeek_cols][object_type]}	%{[zeek_cols][instance_number]}	%{[zeek_cols][vendor]}	%{[zeek_cols][range]}	%{[zeek_cols][object_name]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bacnet_discovery"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bacnet_discovery"
        init => "$zeek_bacnet_discovery_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'is_orig', 'pdu_service', 'object_type', 'instance_number', 'vendor', 'range', 'object_name' ]"
        code => "event.set('[zeek_cols]', $zeek_bacnet_discovery_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bacnet_discovery"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bacnet"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bacnet_property") {
    #############################################################################################################################
    # bacnet_property.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bacnet_property"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][invoke_id]}	%{[zeek_cols][pdu_service]}	%{[zeek_cols][object_type]}	%{[zeek_cols][instance_number]}	%{[zeek_cols][property]}	%{[zeek_cols][array_index]}	%{[zeek_cols][value]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bacnet_property"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bacnet_property"
        init => "$zeek_bacnet_property_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'is_orig', 'invoke_id', 'pdu_service', 'object_type', 'instance_number', 'property', 'array_index', 'value' ]"
        code => "event.set('[zeek_cols]', $zeek_bacnet_property_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bacnet_property"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bacnet"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "cip") {
    #############################################################################################################################
    # cip.log
    # https://github.com/cisagov/ICSNPP
    #
    # todo: class_id, instance_id is a hex integer, should it be converted to an integer?

    dissect {
      id => "dissect_zeek_cip"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][cip_sequence_count]}	%{[zeek_cols][direction]}	%{[zeek_cols][cip_service_code]}	%{[zeek_cols][cip_service]}	%{[zeek_cols][cip_status_code]}	%{[zeek_cols][cip_status]}	%{[zeek_cols][cip_extended_status_code]}	%{[zeek_cols][cip_extended_status]}	%{[zeek_cols][class_id]}	%{[zeek_cols][class_name]}	%{[zeek_cols][instance_id]}	%{[zeek_cols][attribute_id]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_cip"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_cip"
        init => "$zeek_cip_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'is_orig', 'cip_sequence_count', 'direction', 'cip_service_code', 'cip_service', 'cip_status_code', 'cip_status', 'cip_extended_status_code', 'cip_extended_status', 'class_id', 'class_name', 'instance_id', 'attribute_id' ]"
        code => "event.set('[zeek_cols]', $zeek_cip_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_cip"
      add_field => { "[zeek_cols][service]" => "cip" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "cip_identity") {
    #############################################################################################################################
    # cip_identity.log
    # https://github.com/cisagov/ICSNPP
    #
    # TODO: device_status and device_state are a hex int string, convert to int?

    dissect {
      id => "dissect_zeek_cip_identity"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][encapsulation_version]}	%{[zeek_cols][socket_address]}	%{[zeek_cols][socket_port]}	%{[zeek_cols][vendor_id]}	%{[zeek_cols][vendor_name]}	%{[zeek_cols][device_type_id]}	%{[zeek_cols][device_type_name]}	%{[zeek_cols][product_code]}	%{[zeek_cols][revision]}	%{[zeek_cols][device_status]}	%{[zeek_cols][serial_number]}	%{[zeek_cols][product_name]}	%{[zeek_cols][device_state]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_cip_identity"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_cip_identity"
        init => "$zeek_cip_identity_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'encapsulation_version', 'socket_address', 'socket_port', 'vendor_id', 'vendor_name', 'device_type_id', 'device_type_name', 'product_code', 'device_status', 'serial_number', 'product_name', 'device_state' ]"
        code => "event.set('[zeek_cols]', $zeek_cip_identity_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_cip_identity"
      add_field => { "[zeek_cols][service]" => "cip" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "cip_io") {
    #############################################################################################################################
    # cip_io.log
    # https://github.com/cisagov/ICSNPP
    #

    dissect {
      id => "dissect_zeek_cip_io"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][connection_id]}	%{[zeek_cols][sequence_number]}	%{[zeek_cols][data_length]}	%{[zeek_cols][io_data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_cip_io"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_cip_io"
        init => "$zeek_cip_io_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'is_orig', 'connection_id', 'sequence_number', 'data_length', 'io_data' ]"
        code => "event.set('[zeek_cols]', $zeek_cip_io_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_cip_io"
      add_field => { "[zeek_cols][service]" => "cip" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "dce_rpc") {
    #############################################################################################################################
    # dce_rpc.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/dce-rpc/main.zeek.html#type-DCE_RPC::Info

    dissect {
      id => "dissect_zeek_dce_rpc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][rtt]}	%{[zeek_cols][named_pipe]}	%{[zeek_cols][endpoint]}	%{[zeek_cols][operation]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dce_rpc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dce_rpc"
        init => "$zeek_dce_rpc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'rtt', 'named_pipe', 'endpoint', 'operation' ]"
        code => "event.set('[zeek_cols]', $zeek_dce_rpc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dce_rpc"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "dce_rpc"
      }
    }

  } else if ([log_source] == "dhcp") {
    #############################################################################################################################
    # dhcp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/dhcp/main.zeek.html#type-DHCP::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap dhcp.log field configuration version 0
      #
      # all fields               : 0x0001FFFF / 131071
      # all fields minus software: 0x00007FFF /  32767

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 131071) {
          dissect {
            id => "dissect_zeek_dhcp_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][host_name]}	%{[zeek_cols][client_fqdn]}	%{[zeek_cols][domain]}	%{[zeek_cols][requested_ip]}	%{[zeek_cols][assigned_ip]}	%{[zeek_cols][lease_time]}	%{[zeek_cols][client_message]}	%{[zeek_cols][server_message]}	%{[zeek_cols][msg_types]}	%{[zeek_cols][duration]}	%{[zeek_cols][client_software]}	%{[zeek_cols][server_software]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 32767) {
          dissect {
            id => "dissect_zeek_dhcp_with_all_fields_minus_software"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][host_name]}	%{[zeek_cols][client_fqdn]}	%{[zeek_cols][domain]}	%{[zeek_cols][requested_ip]}	%{[zeek_cols][assigned_ip]}	%{[zeek_cols][lease_time]}	%{[zeek_cols][client_message]}	%{[zeek_cols][server_message]}	%{[zeek_cols][msg_types]}	%{[zeek_cols][duration]}"
            }
          }

        } else {
          # who knows? the dhcp.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_dhcp_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the dhcp.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_dhcp_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the dhcp.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_dhcp_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dhcp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dhcp"
        init => "$zeek_dhcp_field_names = [ 'ts', 'uid', 'orig_h', 'resp_h', 'orig_l2_addr', 'host_name', 'client_fqdn', 'domain', 'requested_ip', 'assigned_ip', 'lease_time', 'client_message', 'server_message', 'msg_types', 'duration', 'client_software', 'server_software' ]"
        code => "event.set('[zeek_cols]', $zeek_dhcp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    if ([zeek_cols][uid]) and ([zeek_cols][uid] != '(empty)') and ([zeek_cols][uid] != '') {
      mutate { id => "mutate_split_zeek_dhcp_uids"
               split => { "[zeek_cols][uid]" => "," } }
    }
    if ([zeek_cols][uid] and [zeek_cols][uid][0]) {
      mutate { id => "mutate_add_field_zeek_dhcp_uids"
               add_field => { "[rootId]" => "%{[zeek_cols][uid][0]}" } }
    }

    if ((![zeek_cols][orig_p]) and (![zeek_cols][resp_p])) {
      mutate {
        id => "mutate_add_field_zeek_dhcp_ports"
        add_field => {
          "[zeek_cols][orig_p]" => 68
          "[zeek_cols][resp_p]" => 67
        }
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dhcp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "dhcp"
      }
    }

  } else if ([log_source] == "dnp3") {
    #############################################################################################################################
    # dnp3.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/dnp3/main.zeek.html#type-DNP3::Info

    dissect {
      id => "dissect_zeek_dnp3"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fc_request]}	%{[zeek_cols][fc_reply]}	%{[zeek_cols][iin]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dnp3"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dnp3"
        init => "$zeek_dnp3_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'fc_request', 'fc_reply', 'iin' ]"
        code => "event.set('[zeek_cols]', $zeek_dnp3_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dnp3"
      add_field => { "[zeek_cols][service]" => "dnp3" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "dnp3_control") {
    #############################################################################################################################
    # dnp3_control.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_dnp3_control"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][block_type]}	%{[zeek_cols][function_code]}	%{[zeek_cols][index_number]}	%{[zeek_cols][trip_control_code]}	%{[zeek_cols][operation_type]}	%{[zeek_cols][execute_count]}	%{[zeek_cols][on_time]}	%{[zeek_cols][off_time]}	%{[zeek_cols][status_code]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dnp3_control"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dnp3_control"
        init => "$zeek_dnp3_control_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'block_type', 'function_code', 'index_number', 'trip_control_code', 'operation_type', 'execute_count', 'on_time', 'off_time', 'status_code' ]"
        code => "event.set('[zeek_cols]', $zeek_dnp3_control_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dnp3_control"
      add_field => { "[zeek_cols][service]" => "dnp3" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "dnp3_objects") {
    #############################################################################################################################
    # dnp3_objects.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_dnp3_objects"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][function_code]}	%{[zeek_cols][object_type]}	%{[zeek_cols][object_count]}	%{[zeek_cols][range_low]}	%{[zeek_cols][range_high]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dnp3_objects"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dnp3_objects"
        init => "$zeek_dnp3_objects_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'function_code', 'object_type', 'object_count', 'range_low', 'range_high' ]"
        code => "event.set('[zeek_cols]', $zeek_dnp3_objects_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dnp3_objects"
      add_field => { "[zeek_cols][service]" => "dnp3" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "dns") {
    #############################################################################################################################
    # dns.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/dns/main.zeek.html#type-DNS::Info

    dissect {
      id => "dissect_zeek_dns"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][trans_id]}	%{[zeek_cols][rtt]}	%{[zeek_cols][query]}	%{[zeek_cols][qclass]}	%{[zeek_cols][qclass_name]}	%{[zeek_cols][qtype]}	%{[zeek_cols][qtype_name]}	%{[zeek_cols][rcode]}	%{[zeek_cols][rcode_name]}	%{[zeek_cols][AA]}	%{[zeek_cols][TC]}	%{[zeek_cols][RD]}	%{[zeek_cols][RA]}	%{[zeek_cols][Z]}	%{[zeek_cols][answers]}	%{[zeek_cols][TTLs]}	%{[zeek_cols][rejected]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dns"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dns"
        init => "$zeek_dns_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'trans_id', 'rtt', 'query', 'qclass', 'qclass_name', 'qtype', 'qtype_name', 'rcode', 'rcode_name', 'AA', 'TC', 'RD', 'RA', 'Z', 'answers', 'TTLs', 'rejected' ]"
        code => "event.set('[zeek_cols]', $zeek_dns_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    # remove C_ prefix from qclass_name
    mutate { id => "mutate_gsub_field_zeek_dns_qclass_name"
             gsub => [ "[zeek_cols][qclass_name]", "^C_", "" ] }

    mutate {
      id => "mutate_add_fields_zeek_dns"
      add_field => { "[zeek_cols][service]" => "dns" }
    }

  } else if ([log_source] == "dpd") {
    #############################################################################################################################
    # dpd.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/dpd/main.zeek.html#type-DPD::Info

    dissect {
      id => "dissect_zeek_dpd"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][failure_reason]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dpd"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dpd"
        init => "$zeek_dpd_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'service', 'failure_reason' ]"
        code => "event.set('[zeek_cols]', $zeek_dpd_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_lowercase_zeek_dpd_service"
             lowercase => [ "[zeek_cols][service]" ] }

    # normalize service string(s)
    if ([zeek_cols][service] =~ /^spicy_/) {
      # if it's coming from spicy, we don't care to have that in the service name
      mutate { id => "mutate_gsub_field_zeek_dpd_service_spicy_prefix"
               gsub => [ "[zeek_cols][service]", "^spicy_", "" ] }

      # some spicy services are named like blah_udp or blah_tcp,
      # and we don't care about the _udp/_tcp suffix
      mutate { id => "mutate_gsub_field_zeek_dpd_service_spicy_suffix"
               gsub => [ "[zeek_cols][service]", "_(tcp|udp)(_hmac)?(_(sha|md)\d+)?$", "" ] }
    }

  } else if ([log_source] == "enip") {
    #############################################################################################################################
    # enip.log
    # https://github.com/cisagov/ICSNPP
    #

    dissect {
      id => "dissect_zeek_enip"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][enip_command_code]}	%{[zeek_cols][enip_command]}	%{[zeek_cols][length]}	%{[zeek_cols][session_handle]}	%{[zeek_cols][enip_status]}	%{[zeek_cols][sender_context]}	%{[zeek_cols][options]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_enip"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_enip"
        init => "$zeek_enip_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'is_orig', 'enip_command', 'length', 'session_handle', 'enip_status', 'sender_context', 'options' ]"
        code => "event.set('[zeek_cols]', $zeek_enip_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_enip"
      add_field => { "[zeek_cols][service]" => "enip" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_registers") {
    #############################################################################################################################
    # ecat_registers.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_registers"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][command]}	%{[zeek_cols][server_addr]}	%{[zeek_cols][register_type]}	%{[zeek_cols][register_addr]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_registers"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_registers"
        init => "$zeek_ecat_registers_field_names = [ 'ts', 'orig_l2_addr', 'resp_l2_addr', 'command', 'server_addr', 'register_type', 'register_addr', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_registers_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_registers"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_log_address") {
    #############################################################################################################################
    # ecat_log_address.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_log_address"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][log_addr]}	%{[zeek_cols][length]}	%{[zeek_cols][command]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_log_address"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_log_address"
        init => "$zeek_ecat_log_address_field_names = [ 'ts', 'orig_l2_addr', 'resp_l2_addr', 'log_addr', 'length', 'command', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_log_address_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_log_address"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_dev_info") {
    #############################################################################################################################
    # ecat_dev_info.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_dev_info"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][server_id]}	%{[zeek_cols][revision]}	%{[zeek_cols][dev_type]}	%{[zeek_cols][build]}	%{[zeek_cols][fmmucnt]}	%{[zeek_cols][smcount]}	%{[zeek_cols][ports]}	%{[zeek_cols][dpram]}	%{[zeek_cols][features]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_dev_info"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_dev_info"
        init => "$zeek_ecat_dev_info_field_names = [ 'ts', 'server_id', 'revision', 'dev_type', 'build', 'fmmucnt', 'smcount', 'ports', 'dpram', 'features' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_dev_info_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_dev_info"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_aoe_info") {
    #############################################################################################################################
    # ecat_aoe_info.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_aoe_info"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][resp_port]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][orig_port]}	%{[zeek_cols][command]}	%{[zeek_cols][state]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_aoe_info"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_aoe_info"
        init => "$zeek_ecat_aoe_info_field_names = [ 'ts', 'resp_l2_addr', 'resp_port', 'orig_l2_addr', 'orig_port', 'command', 'state', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_aoe_info_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_aoe_info"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_coe_info") {
    #############################################################################################################################
    # ecat_coe_info.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_coe_info"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][number]}	%{[zeek_cols][type]}	%{[zeek_cols][req_resp]}	%{[zeek_cols][index]}	%{[zeek_cols][subindex]}	%{[zeek_cols][dataoffset]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_coe_info"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_coe_info"
        init => "$zeek_ecat_coe_info_field_names = [ 'ts', 'number', 'type', 'req_resp', 'index', 'subindex', 'dataoffset' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_coe_info_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_coe_info"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_foe_info") {
    #############################################################################################################################
    # ecat_foe_info.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_foe_info"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][opcode]}	%{[zeek_cols][reserved]}	%{[zeek_cols][packet_num]}	%{[zeek_cols][error_code]}	%{[zeek_cols][filename]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_foe_info"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_foe_info"
        init => "$zeek_ecat_foe_info_field_names = [ 'ts', 'opcode', 'reserved', 'packet_num', 'error_code', 'filename', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_foe_info_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_foe_info"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_soe_info") {
    #############################################################################################################################
    # ecat_soe_info.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_soe_info"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][opcode]}	%{[zeek_cols][incomplete]}	%{[zeek_cols][error]}	%{[zeek_cols][drive_num]}	%{[zeek_cols][element]}	%{[zeek_cols][index]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_soe_info"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_soe_info"
        init => "$zeek_ecat_soe_info_field_names = [ 'ts', 'opcode', 'incomplete', 'error', 'drive_num', 'element', 'index' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_soe_info_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_soe_info"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_arp_info") {
    #############################################################################################################################
    # ecat_arp_info.log
    # https://github.com/cisagov/icsnpp-ethercat
    #
    # NOTE: I currently have this disabled by including ecat_arp_info in drop_zeek_ignored_source
    # above, as it is including ALL arps and not just those from ethercat traffic which can
    # be misleading (i.e., indicating ecat traffic where there is none)

    dissect {
      id => "dissect_zeek_ecat_arp_info"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][arp_type]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][orig_proto_addr]}	%{[zeek_cols][orig_hw_addr]}	%{[zeek_cols][resp_proto_addr]}	%{[zeek_cols][resp_hw_addr]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_arp_info"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_arp_info"
        init => "$zeek_ecat_arp_info_field_names = [ 'ts', 'arp_type', 'orig_l2_addr', 'resp_l2_addr', 'orig_proto_addr', 'orig_hw_addr', 'resp_proto_addr', 'resp_hw_addr' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_arp_info_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_arp_info"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
    }

    # TODO: check orig_proto_addr/orig_hw_addr resp_proto_addr/resp_hw_addr and convert to ip, etc. if necessary?

  } else if ([log_source] == "files") {
    #############################################################################################################################
    # files.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/files/main.zeek.html#type-Files::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap files.log field configuration version 1
      #
      # all fields (v5.1+, with extracted file size info and spicy-zip's ftime)   : 0x0FFFFFFF / 268435455

      # bitmap files.log field configuration version 0
      # all fields (< v5.1+, with extracted file size info and spicy-zip's ftime) : 0x03FFFFFF /  67108863

      if ([@metadata][zeek_fields_bitmap_version] == 1) {

        if ([@metadata][zeek_fields_bitmap] == 268435455) {

          dissect {
            id => "dissect_zeek_v51_files_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][uid]}	%{[zeek_cols][id.orig_h]}	%{[zeek_cols][id.orig_p]}	%{[zeek_cols][id.resp_h]}	%{[zeek_cols][id.resp_p]}	%{[zeek_cols][source]}	%{[zeek_cols][depth]}	%{[zeek_cols][analyzers]}	%{[zeek_cols][mime_type]}	%{[zeek_cols][filename]}	%{[zeek_cols][duration]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][seen_bytes]}	%{[zeek_cols][total_bytes]}	%{[zeek_cols][missing_bytes]}	%{[zeek_cols][overflow_bytes]}	%{[zeek_cols][timedout]}	%{[zeek_cols][parent_fuid]}	%{[zeek_cols][md5]}	%{[zeek_cols][sha1]}	%{[zeek_cols][sha256]}	%{[zeek_cols][extracted]}	%{[zeek_cols][extracted_cutoff]}	%{[zeek_cols][extracted_size]}	%{[zeek_cols][ftime]}"
            }
          }

        } else {
          # who knows? the files.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_files_v51_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 67108863) {

          dissect {
            id => "dissect_zeek_files_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][tx_hosts]}	%{[zeek_cols][rx_hosts]}	%{[zeek_cols][conn_uids]}	%{[zeek_cols][source]}	%{[zeek_cols][depth]}	%{[zeek_cols][analyzers]}	%{[zeek_cols][mime_type]}	%{[zeek_cols][filename]}	%{[zeek_cols][duration]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][seen_bytes]}	%{[zeek_cols][total_bytes]}	%{[zeek_cols][missing_bytes]}	%{[zeek_cols][overflow_bytes]}	%{[zeek_cols][timedout]}	%{[zeek_cols][parent_fuid]}	%{[zeek_cols][md5]}	%{[zeek_cols][sha1]}	%{[zeek_cols][sha256]}	%{[zeek_cols][extracted]}	%{[zeek_cols][extracted_cutoff]}	%{[zeek_cols][extracted_size]}	%{[zeek_cols][ftime]}"
            }
          }

        } else {
          # who knows? the files.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_files_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the files.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_files_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the files.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_files_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_files"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_files"
        init => "$zeek_files_field_names = [ 'ts', 'fuid', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'source', 'depth', 'analyzers', 'mime_type', 'filename', 'duration', 'local_orig', 'is_orig', 'seen_bytes', 'total_bytes', 'missing_bytes', 'overflow_bytes', 'timedout', 'parent_fuid', 'md5', 'sha1', 'sha256', 'extracted', 'extracted_cutoff', 'extracted_size', 'ftime' ]"
        code => "event.set('[zeek_cols]', $zeek_files_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    if ([zeek_cols][conn_uids]) and ([zeek_cols][conn_uids] != '(empty)') and ([zeek_cols][conn_uids] != '') {
      mutate { id => "mutate_split_zeek_files_conn_uids"
               split => { "[zeek_cols][conn_uids]" => "," } }
    }
    if ([zeek_cols][tx_hosts]) and ([zeek_cols][tx_hosts] != '(empty)') and ([zeek_cols][tx_hosts] != '') {
      mutate { id => "mutate_split_zeek_files_tx_hosts"
               split => { "[zeek_cols][tx_hosts]" => "," } }
    }
    if ([zeek_cols][rx_hosts]) and ([zeek_cols][rx_hosts] != '(empty)') and ([zeek_cols][rx_hosts] != '') {
      mutate { id => "mutate_split_zeek_files_rx_hosts"
               split => { "[zeek_cols][rx_hosts]" => "," } }
    }

    if ([zeek_cols][conn_uids] and [zeek_cols][conn_uids][0]) {
      mutate {
        id => "mutate_add_field_zeek_files_conn_uids_to_uid"
        add_field => { "[rootId]"         => "%{[zeek_cols][conn_uids][0]}"
                       "[zeek_cols][uid]" => "%{[zeek_cols][conn_uids][0]}" }
        }
    } else if (![zeek_cols][uid]) {
      mutate {
        id => "mutate_add_fields_zeek_files_fuid_to_uid"
        add_field =>  { "[zeek_cols][uid]" => "%{[zeek_cols][fuid]}" }
      }
    }

    if ([zeek_cols][tx_hosts] and [zeek_cols][tx_hosts][0]) {
      mutate { id => "mutate_add_field_zeek_tx_hosts"
               add_field => { "[source][ip]" => "%{[zeek_cols][tx_hosts][0]}" } }
    }

    if ([zeek_cols][rx_hosts] and [zeek_cols][rx_hosts][0]) {
      mutate { id => "mutate_add_field_zeek_rx_hosts"
               add_field => { "[destination][ip]" => "%{[zeek_cols][rx_hosts][0]}" } }
    }


  } else if ([log_source] == "ftp") {
    #############################################################################################################################
    # ftp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/ftp/info.zeek.html#type-FTP::Info

    dissect {
      id => "dissect_zeek_ftp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][command]}	%{[zeek_cols][arg]}	%{[zeek_cols][mime_type]}	%{[zeek_cols][file_size]}	%{[zeek_cols][reply_code]}	%{[zeek_cols][reply_msg]}	%{[zeek_cols][data_channel_passive]}	%{[zeek_cols][data_channel_orig_h]}	%{[zeek_cols][data_channel_resp_h]}	%{[zeek_cols][data_channel_resp_p]}	%{[zeek_cols][fuid]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ftp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ftp"
        init => "$zeek_ftp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user', 'password', 'command', 'arg', 'mime_type', 'file_size', 'reply_code', 'reply_msg', 'data_channel_passive', 'data_channel_orig_h', 'data_channel_resp_h', 'data_channel_resp_p', 'fuid' ]"
        code => "event.set('[zeek_cols]', $zeek_ftp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ftp"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "ftp"
      }
    }

  } else if ([log_source] == "genisys") {
    #############################################################################################################################
    # genisys.log
    # https://github.com/cisagov/icsnpp-genisys

    dissect {
      id => "dissect_zeek_genisys"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][header]}	%{[zeek_cols][server]}	%{[zeek_cols][direction]}	%{[zeek_cols][crc_transmitted]}	%{[zeek_cols][crc_calculated]}	%{[zeek_cols][payload_raw]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_genisys"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_genisys"
        init => "$zeek_genisys_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'header', 'server', 'direction', 'crc_transmitted', 'crc_calculated', 'payload_raw' ]"
        code => "event.set('[zeek_cols]', $zeek_genisys_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_genisys"
      add_field => {
        "[zeek_cols][service]" => "genisys"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "gquic") {
    #############################################################################################################################
    # gquic.log
    # https://github.com/salesforce/GQUIC_Protocol_Analyzer/blob/master/scripts/Salesforce/GQUIC/main.bro

    dissect {
      id => "dissect_zeek_gquic"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][server_name]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][tag_count]}	%{[zeek_cols][cyu]}	%{[zeek_cols][cyutags]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_gquic"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_gquic"
        init => "$zeek_gquic_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'server_name', 'user_agent', 'tag_count', 'cyu', 'cyutags' ]"
        code => "event.set('[zeek_cols]', $zeek_gquic_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_gquic"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "quic"
      }
    }

  } else if ([log_source] == "http") {
    #############################################################################################################################
    # http.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/http/main.zeek.html#type-HTTP::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap http.log field configuration version 0
      # all fields:                                       0x7FFFFFFFF / 34359738367
      # minus fields added by zeek-sniffpass:             0x03FFFFFFF /  1073741823
      # minus origin and fields added by zeek-sniffpass:  0x03FFFDFFF /  1073733631

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 34359738367) {
          dissect {
            id => "dissect_zeek_http_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][host]}	%{[zeek_cols][uri]}	%{[zeek_cols][referrer]}	%{[zeek_cols][version]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][origin]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][info_code]}	%{[zeek_cols][info_msg]}	%{[zeek_cols][tags]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][proxied]}	%{[zeek_cols][orig_fuids]}	%{[zeek_cols][orig_filenames]}	%{[zeek_cols][orig_mime_types]}	%{[zeek_cols][resp_fuids]}	%{[zeek_cols][resp_filenames]}	%{[zeek_cols][resp_mime_types]}	%{[zeek_cols][post_username]}	%{[zeek_cols][post_password_plain]}	%{[zeek_cols][post_password_md5]}	%{[zeek_cols][post_password_sha1]}	%{[zeek_cols][post_password_sha256]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 1073741823) {
          dissect {
            id => "dissect_zeek_http_with_all_fields_minus_sniffpass"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][host]}	%{[zeek_cols][uri]}	%{[zeek_cols][referrer]}	%{[zeek_cols][version]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][origin]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][info_code]}	%{[zeek_cols][info_msg]}	%{[zeek_cols][tags]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][proxied]}	%{[zeek_cols][orig_fuids]}	%{[zeek_cols][orig_filenames]}	%{[zeek_cols][orig_mime_types]}	%{[zeek_cols][resp_fuids]}	%{[zeek_cols][resp_filenames]}	%{[zeek_cols][resp_mime_types]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 1073733631) {
          dissect {
            id => "dissect_zeek_http_with_all_fields_minus_origin"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][host]}	%{[zeek_cols][uri]}	%{[zeek_cols][referrer]}	%{[zeek_cols][version]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][info_code]}	%{[zeek_cols][info_msg]}	%{[zeek_cols][tags]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][proxied]}	%{[zeek_cols][orig_fuids]}	%{[zeek_cols][orig_filenames]}	%{[zeek_cols][orig_mime_types]}	%{[zeek_cols][resp_fuids]}	%{[zeek_cols][resp_filenames]}	%{[zeek_cols][resp_mime_types]}"
            }
          }

        } else {
          # who knows? the http.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_http_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the http.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_http_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the http.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_http_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_http"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_http"
        init => "$zeek_http_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'trans_depth', 'method', 'host', 'uri', 'referrer', 'version', 'user_agent', 'origin', 'request_body_len', 'response_body_len', 'status_code', 'status_msg', 'info_code', 'info_msg', 'tags', 'user', 'password', 'proxied', 'orig_fuids', 'orig_filenames', 'orig_mime_types', 'resp_fuids', 'resp_filenames', 'resp_mime_types', 'post_username', 'post_password_plain', 'post_password_md5', 'post_password_sha1', 'post_password_sha256' ]"
        code => "event.set('[zeek_cols]', $zeek_http_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_http"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "http"
      }
    }

  } else if ([log_source] == "intel") {
    #############################################################################################################################
    # intel.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/intel/main.zeek.html#type-Intel::Info

    dissect {
      id => "dissect_zeek_intel"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][seen_indicator]}	%{[zeek_cols][seen_indicator_type]}	%{[zeek_cols][seen_where]}	%{[zeek_cols][seen_node]}	%{[zeek_cols][matched]}	%{[zeek_cols][sources]}	%{[zeek_cols][fuid]}	%{[zeek_cols][file_mime_type]}	%{[zeek_cols][file_desc]}	%{[zeek_cols][cif_tags]}	%{[zeek_cols][cif_confidence]}	%{[zeek_cols][cif_source]}	%{[zeek_cols][cif_description]}	%{[zeek_cols][cif_firstseen]}	%{[zeek_cols][cif_lastseen]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_intel"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_intel"
        init => "$zeek_intel_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'seen_indicator', 'seen_indicator_type', 'seen_where', 'seen_node', 'matched', 'sources', 'fuid', 'file_mime_type', 'file_desc', 'cif_tags', 'cif_confidence', 'cif_source', 'cif_description', 'cif_firstseen', 'cif_lastseen' ]"
        code => "event.set('[zeek_cols]', $zeek_intel_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "ipsec") {
    #############################################################################################################################
    # ipsec.log
    # https://github.com/corelight/zeek-spicy-ipsec/blob/master/analyzer/main.zeek

    dissect {
      id => "dissect_zeek_ipsec"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][initiator_spi]}	%{[zeek_cols][responder_spi]}	%{[zeek_cols][maj_ver]}	%{[zeek_cols][min_ver]}	%{[zeek_cols][exchange_type]}	%{[zeek_cols][flag_e]}	%{[zeek_cols][flag_c]}	%{[zeek_cols][flag_a]}	%{[zeek_cols][flag_i]}	%{[zeek_cols][flag_v]}	%{[zeek_cols][flag_r]}	%{[zeek_cols][message_id]}	%{[zeek_cols][vendor_ids]}	%{[zeek_cols][notify_messages]}	%{[zeek_cols][transforms]}	%{[zeek_cols][ke_dh_groups]}	%{[zeek_cols][proposals]}	%{[zeek_cols][protocol_id]}	%{[zeek_cols][certificates]}	%{[zeek_cols][transform_attributes]}	%{[zeek_cols][length]}	%{[zeek_cols][hash]}	%{[zeek_cols][doi]}	%{[zeek_cols][situation]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ipsec"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ipsec"
        init => "$zeek_ipsec_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'is_orig', 'initiator_spi', 'responder_spi', 'maj_ver', 'min_ver', 'exchange_type', 'flag_e', 'flag_c', 'flag_a', 'flag_i', 'flag_v', 'flag_r', 'message_id', 'vendor_ids', 'notify_messages', 'transforms', 'ke_dh_groups', 'proposals', 'protocol_id', 'certificates', 'transform_attributes', 'length', 'hash', 'doi', 'situation' ]"
        code => "event.set('[zeek_cols]', $zeek_ipsec_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ipsec"
      add_field => {
        "[zeek_cols][service]" => "ipsec"
      }
    }

  } else if ([log_source] == "irc") {
    #############################################################################################################################
    # irc.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/irc/main.zeek.html#type-IRC::Info

    dissect {
      id => "dissect_zeek_irc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][nick]}	%{[zeek_cols][user]}	%{[zeek_cols][command]}	%{[zeek_cols][value]}	%{[zeek_cols][addl]}	%{[zeek_cols][dcc_file_name]}	%{[zeek_cols][dcc_file_size]}	%{[zeek_cols][dcc_mime_type]}	%{[zeek_cols][fuid]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_irc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_irc"
        init => "$zeek_irc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'nick', 'user', 'command', 'value', 'addl', 'dcc_file_name', 'dcc_file_size', 'dcc_mime_type', 'fuid' ]"
        code => "event.set('[zeek_cols]', $zeek_irc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_irc"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "irc"
      }
    }

  } else if ([log_source] == "cotp") {
    #############################################################################################################################
    # cotp.log
    # https://github.com/cisagov/icsnpp-s7comm

    dissect {
      id => "dissect_zeek_cotp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][pdu_code]}	%{[zeek_cols][pdu_name]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_cotp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_cotp"
        init => "$zeek_cotp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'is_orig', 'pdu_code', 'pdu_name' ]"
        code => "event.set('[zeek_cols]', $zeek_cotp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_cotp"
      add_field =>  {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "cotp"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "kerberos") {
    #############################################################################################################################
    # kerberos.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/krb/main.zeek.html#type-KRB::Info

    dissect {
      id => "dissect_zeek_kerberos"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][request_type]}	%{[zeek_cols][cname]}	%{[zeek_cols][sname]}	%{[zeek_cols][success]}	%{[zeek_cols][error_msg]}	%{[zeek_cols][from]}	%{[zeek_cols][till]}	%{[zeek_cols][cipher]}	%{[zeek_cols][forwardable]}	%{[zeek_cols][renewable]}	%{[zeek_cols][client_cert_subject]}	%{[zeek_cols][client_cert_fuid]}	%{[zeek_cols][server_cert_subject]}	%{[zeek_cols][server_cert_fuid]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_kerberos"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_kerberos"
        init => "$zeek_kerberos_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'request_type', 'cname', 'sname', 'success', 'error_msg', 'from', 'till', 'cipher', 'forwardable', 'renewable', 'client_cert_subject', 'client_cert_fuid', 'server_cert_subject', 'server_cert_fuid' ]"
        code => "event.set('[zeek_cols]', $zeek_kerberos_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_krb5"
      add_field =>  { "[zeek_cols][service]" => "krb" }
    }

  } else if ([log_source] == "known_certs") {
    #############################################################################################################################
    # known_certs.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/ssl/known-certs.zeek.html#type-Known::CertsInfo

    dissect {
      id => "dissect_zeek_known_certs"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][subject]}	%{[zeek_cols][issuer_subject]}	%{[zeek_cols][serial]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_certs"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_certs"
        init => "$zeek_known_certs_field_names = [ 'ts', 'orig_h', 'orig_p', 'subject', 'resp_h', 'issuer_subject', 'serial' ]"
        code => "event.set('[zeek_cols]', $zeek_known_certs_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_known_certs"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tls"
      }
    }

  } else if ([log_source] == "known_hosts") {
    #############################################################################################################################
    # known_hosts.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/conn/known-hosts.zeek.html#type-Known::HostsInfo

    dissect {
      id => "dissect_zeek_known_hosts"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_hosts"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_hosts"
        init => "$zeek_known_hosts_field_names = [ 'ts', 'orig_h' ]"
        code => "event.set('[zeek_cols]', $zeek_known_hosts_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "known_modbus") {
    #############################################################################################################################
    # known_modbus.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/modbus/known-masters-slaves.zeek.html#type-Known::ModbusInfo

    dissect {
      id => "dissect_zeek_known_modbus"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][device_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_modbus"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_modbus"
        init => "$zeek_known_modbus_field_names = [ 'ts', 'orig_h', 'device_type' ]"
        code => "event.set('[zeek_cols]', $zeek_known_modbus_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_gsub_zeek_known_modbus_device_type"
             gsub => [ "[zeek_cols][device_type]", "Known::", "" ] }

    mutate { id => "mutate_add_tag_ics_known_modbus_log"
             add_tag => [ "ics" ] }

  } else if ([log_source] == "known_services") {
    #############################################################################################################################
    # known_services.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/conn/known-services.zeek.html#type-Known::ServicesInfo

    dissect {
      id => "dissect_zeek_known_services"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_services"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_services"
        init => "$zeek_known_services_field_names = [ 'ts', 'resp_h', 'resp_p', 'proto', 'service' ]"
        code => "event.set('[zeek_cols]', $zeek_known_services_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_lowercase_zeek_known_services_service"
             lowercase => [ "[zeek_cols][service]" ] }

    # normalize service string(s)

    # some services are named like blah_udp/blah_tcp/blah_data, and we don't care about the suffix
    mutate { id => "mutate_gsub_field_zeek_known_services_protocol_suffix"
             gsub => [ "[zeek_cols][service]", "[_-](tcp|udp|data)", "" ] }

    if ([zeek_cols][service] =~ /^spicy_/) {
      # if it's coming from spicy, we don't care to have that in the service name
      mutate { id => "mutate_gsub_field_zeek_known_service_spicy_prefix"
               gsub => [ "[zeek_cols][service]", "^spicy_", "" ] }

      # some spicy services are named like blah_udp or blah_tcp,
      # and we don't care about the _udp/_tcp suffix
      mutate { id => "mutate_gsub_field_zeek_known_service_spicy_suffix"
               gsub => [ "[zeek_cols][service]", "(_hmac)?(_(sha|md)\d+)?$", "" ] }

    }

  } else if ([log_source] == "ldap") {
    #############################################################################################################################
    # ldap.log
    # https://github.com/zeek/spicy-ldap/blob/main/analyzer/main.zeek

    dissect {
      id => "dissect_zeek_ldap"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][message_id]}	%{[zeek_cols][version]}	%{[zeek_cols][operation]}	%{[zeek_cols][result_code]}	%{[zeek_cols][result_message]}	%{[zeek_cols][object]}	%{[zeek_cols][argument]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ldap"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ldap"
        init => "$zeek_ldap_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'message_id', 'version', 'operation', 'result_code', 'result_message', 'object', 'argument' ]"
        code => "event.set('[zeek_cols]', $zeek_ldap_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ldap"
      add_field =>  { "[zeek_cols][service]" => "ldap" }
    }

  } else if ([log_source] == "ldap_search") {
    #############################################################################################################################
    # ldap_search.log
    # https://github.com/zeek/spicy-ldap/blob/main/analyzer/main.zeek

    dissect {
      id => "dissect_zeek_ldap_search"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][message_id]}	%{[zeek_cols][scope]}	%{[zeek_cols][deref]}	%{[zeek_cols][base_object]}	%{[zeek_cols][result_count]}	%{[zeek_cols][result_code]}	%{[zeek_cols][result_message]}	%{[zeek_cols][filter]}	%{[zeek_cols][attributes]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ldap_search"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ldap_search"
        init => "$zeek_ldap_search_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'message_id', 'scope', 'deref', 'base_object', 'result_count', 'result_code', 'result_message', 'filter', 'attributes' ]"
        code => "event.set('[zeek_cols]', $zeek_ldap_search_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ldap_search"
      add_field =>  { "[zeek_cols][service]" => "ldap" }
    }

  } else if ([log_source] == "login") {
    #############################################################################################################################
    # login.log
    # custom login.log module (rudimentary, telnet/rlogin/rsh analyzers are old and not the greatest)

    dissect {
      id => "dissect_zeek_login"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][service]}	%{[zeek_cols][success]}	%{[zeek_cols][confused]}	%{[zeek_cols][user]}	%{[zeek_cols][client_user]}	%{[zeek_cols][password]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_login"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_login"
        init => "$zeek_login_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'service', 'success', 'confused', 'user', 'client_user', 'password' ]"
        code => "event.set('[zeek_cols]', $zeek_login_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "modbus") {
    #############################################################################################################################
    # modbus.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/modbus/main.zeek.html#type-Modbus::Info

    dissect {
      id => "dissect_zeek_modbus"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][func]}	%{[zeek_cols][exception]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus"
        init => "$zeek_modbus_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'func', 'exception' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_modbus"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "modbus_detailed") {
    #############################################################################################################################
    # modbus_detailed.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_modbus_detailed"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][unit_id]}	%{[zeek_cols][func]}	%{[zeek_cols][network_direction]}	%{[zeek_cols][address]}	%{[zeek_cols][quantity]}	%{[zeek_cols][values]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus_detailed"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus_detailed"
        init => "$zeek_modbus_detailed_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'unit_id', 'func', 'network_direction', 'address', 'quantity', 'values' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_detailed_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_modbus_detailed"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "modbus_mask_write_register") {
    #############################################################################################################################
    # modbus_mask_write_register.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_modbus_mask_write_register"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][unit_id]}	%{[zeek_cols][func]}	%{[zeek_cols][network_direction]}	%{[zeek_cols][address]}	%{[zeek_cols][and_mask]}	%{[zeek_cols][or_mask]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus_mask_write_register"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus_mask_write_register"
        init => "$zeek_modbus_mask_write_register_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'unit_id', 'func', 'network_direction', 'address', 'and_mask', 'or_mask' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_modbus_mask_write_register_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_modbus_mask_write_register"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "modbus_read_write_multiple_registers") {
    #############################################################################################################################
    # modbus_read_write_multiple_registers.log
    # https://github.com/cisagov/ICSNPP
    dissect {
      id => "dissect_zeek_modbus_read_write_multiple_registers"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][unit_id]}	%{[zeek_cols][func]}	%{[zeek_cols][network_direction]}	%{[zeek_cols][write_start_address]}	%{[zeek_cols][write_registers]}	%{[zeek_cols][read_start_address]}	%{[zeek_cols][read_quantity]}	%{[zeek_cols][read_registers]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus_read_write_multiple_registers"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus_read_write_multiple_registers"
        init => "$zeek_modbus_read_write_multiple_registers_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'unit_id', 'func', 'network_direction', 'write_start_address', 'write_registers', 'read_start_address', 'read_quantity', 'read_registers' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_read_write_multiple_registers_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_modbus_read_write_multiple_registers"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "mqtt_connect") {
    #############################################################################################################################
    # mqtt_connect.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/mqtt/main.zeek.html#type-MQTT::ConnectInfo

    dissect {
      id => "dissect_zeek_mqtt_connect"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto_name]}	%{[zeek_cols][proto_version]}	%{[zeek_cols][client_id]}	%{[zeek_cols][connect_status]}	%{[zeek_cols][will_topic]}	%{[zeek_cols][will_payload]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mqtt_connect"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mqtt_connect"
        init => "$zeek_mqtt_connect_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto_name', 'proto_version', 'client_id', 'connect_status', 'will_topic', 'will_payload' ]"
        code => "event.set('[zeek_cols]', $zeek_mqtt_connect_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mqtt_connect"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "mqtt"
      }
    }

  } else if ([log_source] == "mqtt_publish") {
    #############################################################################################################################
    # mqtt_publish.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/mqtt/main.zeek.html#type-MQTT::PublishInfo

    dissect {
      id => "dissect_zeek_mqtt_publish"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][from_client]}	%{[zeek_cols][retain]}	%{[zeek_cols][qos]}	%{[zeek_cols][status]}	%{[zeek_cols][topic]}	%{[zeek_cols][payload]}	%{[zeek_cols][payload_len]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mqtt_publish"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mqtt_publish"
        init => "$zeek_mqtt_publish_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'from_client', 'retain', 'qos', 'status', 'topic', 'payload', 'payload_len' ]"
        code => "event.set('[zeek_cols]', $zeek_mqtt_publish_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mqtt_publish"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "mqtt"
      }
    }

  } else if ([log_source] == "mqtt_subscribe") {
    #############################################################################################################################
    # mqtt_subscribe.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/mqtt/main.zeek.html#type-MQTT::SubscribeInfo

    dissect {
      id => "dissect_zeek_mqtt_subscribe"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][action]}	%{[zeek_cols][topics]}	%{[zeek_cols][qos_levels]}	%{[zeek_cols][granted_qos_level]}	%{[zeek_cols][ack]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mqtt_subscribe"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mqtt_subscribe"
        init => "$zeek_mqtt_subscribe_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'action', 'topics', 'qos_levels', 'granted_qos_level', 'ack' ]"
        code => "event.set('[zeek_cols]', $zeek_mqtt_subscribe_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mqtt_subscribe"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "mqtt"
      }
    }

    mutate { id => "mutate_gsub_zeek_mqtt_subscribe_action"
             gsub => [ "[zeek_cols][action]", "MQTT::", "" ] }

  } else if ([log_source] == "mysql") {
    #############################################################################################################################
    # mysql.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/mysql/main.zeek.html#type-MySQL::Info

    dissect {
      id => "dissect_zeek_mysql"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cmd]}	%{[zeek_cols][arg]}	%{[zeek_cols][success]}	%{[zeek_cols][rows]}	%{[zeek_cols][response]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mysql"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mysql"
        init => "$zeek_mysql_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'cmd', 'arg', 'success', 'rows', 'response' ]"
        code => "event.set('[zeek_cols]', $zeek_mysql_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mysql"
      add_field =>  { "[zeek_cols][service]" => "mysql" }
    }

  } else if ([log_source] == "notice") {
    #############################################################################################################################
    # notice.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/notice/main.zeek.html#type-Notice::Info

    dissect {
      id => "dissect_zeek_notice_with_all_fields"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fuid]}	%{[zeek_cols][file_mime_type]}	%{[zeek_cols][file_desc]}	%{[zeek_cols][proto]}	%{[zeek_cols][note]}	%{[zeek_cols][msg]}	%{[zeek_cols][sub]}	%{[zeek_cols][src]}	%{[zeek_cols][dst]}	%{[zeek_cols][p]}	%{[zeek_cols][n]}	%{[zeek_cols][peer_descr]}	%{[zeek_cols][actions]}	%{[zeek_cols][email_dest]}	%{[zeek_cols][suppress_for]}	%{[zeek_cols][remote_location_country_code]}	%{[zeek_cols][remote_location_region]}	%{[zeek_cols][remote_location_city]}	%{[zeek_cols][remote_location_latitude]}	%{[zeek_cols][remote_location_longitude]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_notice"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_notice"
        init => "$zeek_notice_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'fuid', 'file_mime_type', 'file_desc', 'proto', 'note', 'msg', 'sub', 'src', 'dst', 'p', 'n', 'peer_descr', 'actions', 'email_dest', 'suppress_for', 'remote_location_country_code', 'remote_location_region', 'remote_location_city', 'remote_location_latitude', 'remote_location_longitude' ]"
        code => "event.set('[zeek_cols]', $zeek_notice_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    if (![zeek_cols][orig_h])       or ([zeek_cols][orig_h] == '(empty)') or
       ([zeek_cols][orig_h] == '-') or ([zeek_cols][orig_h] == '') {
      mutate { id => "mutate_replace_zeek_notice_orig_h"
               replace => { "[zeek_cols][orig_h]" => "%{[zeek_cols][src]}" } }
    }
    if (![zeek_cols][resp_h])       or ([zeek_cols][resp_h] == '(empty)') or
       ([zeek_cols][resp_h] == '-') or ([zeek_cols][resp_h] == '') {
      mutate { id => "mutate_replace_zeek_notice_resp_h"
               replace => { "[zeek_cols][resp_h]" => "%{[zeek_cols][dst]}" } }
    }
    if (![zeek_cols][resp_p])       or ([zeek_cols][resp_p] == '(empty)') or
       ([zeek_cols][resp_p] == '-') or ([zeek_cols][resp_p] == '') {
      mutate { id => "mutate_replace_zeek_resp_p"
               replace => { "[zeek_cols][resp_p]" => "%{[zeek_cols][p]}" } }
    }

  } else if ([log_source] == "ntlm") {
    #############################################################################################################################
    # ntlm.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/ntlm/main.zeek.html#type-NTLM::Info

    dissect {
      id => "dissect_zeek_ntlm_with_all_fields"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][host]}	%{[zeek_cols][domain]}	%{[zeek_cols][server_nb_computer]}	%{[zeek_cols][server_dns_computer]}	%{[zeek_cols][server_tree]}	%{[zeek_cols][success]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ntlm"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ntlm"
        init => "$zeek_ntlm_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user', 'host', 'domain', 'server_nb_computer', 'server_dns_computer', 'server_tree', 'success' ]"
        code => "event.set('[zeek_cols]', $zeek_ntlm_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ntlm"
      add_field =>  { "[zeek_cols][service]" => "ntlm" }
    }

  } else if ([log_source] == "ntp") {
    #############################################################################################################################
    # ntp.log
    # https://docs.zeek.org/en/latest/scripts/base/protocols/ntp/main.zeek.html#type-NTP::Info

    dissect {
      id => "dissect_zeek_ntp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][mode]}	%{[zeek_cols][stratum]}	%{[zeek_cols][poll]}	%{[zeek_cols][precision]}	%{[zeek_cols][root_delay]}	%{[zeek_cols][root_disp]}	%{[zeek_cols][ref_id]}	%{[zeek_cols][ref_time]}	%{[zeek_cols][org_time]}	%{[zeek_cols][rec_time]}	%{[zeek_cols][xmt_time]}	%{[zeek_cols][num_exts]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ntp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ntp"
        init => "$zeek_ntp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'mode', 'stratum', 'poll', 'precision', 'root_delay', 'root_disp', 'ref_id', 'ref_time', 'org_time', 'rec_time', 'xmt_time', 'num_exts' ]"
        code => "event.set('[zeek_cols]', $zeek_ntp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ntp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "ntp"
      }
    }

  } else if ([log_source] == "ocsp") {
    #############################################################################################################################
    # ocsp.log
    # https://docs.zeek.org/en/stable/scripts/policy/files/x509/log-ocsp.zeek.html#type-OCSP::Info

    dissect {
      id => "dissect_zeek_ocsp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][hashAlgorithm]}	%{[zeek_cols][issuerNameHash]}	%{[zeek_cols][issuerKeyHash]}	%{[zeek_cols][serialNumber]}	%{[zeek_cols][certStatus]}	%{[zeek_cols][revoketime]}	%{[zeek_cols][revokereason]}	%{[zeek_cols][thisUpdate]}	%{[zeek_cols][nextUpdate]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ocsp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }

      ruby {
        id => "ruby_zip_zeek_ocsp"
        init => "$zeek_ocsp_field_names = [ 'ts', 'fuid', 'hashAlgorithm', 'issuerNameHash', 'issuerKeyHash', 'serialNumber', 'certStatus', 'revoketime', 'revokereason', 'thisUpdate', 'nextUpdate' ]"
        code => "event.set('[zeek_cols]', $zeek_ocsp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_fields_zeek_service_ocsp"
             add_field => { "[zeek_cols][service]" => "X.509" } }

  } else if ([log_source] == "ospf") {
    #############################################################################################################################
    # ospf.log
    # https://github.com/corelight/zeek-spicy-ospf

    dissect {
      id => "dissect_zeek_ospf"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][ospf_type]}	%{[zeek_cols][version]}	%{[zeek_cols][router_id]}	%{[zeek_cols][area_id]}	%{[zeek_cols][interface_id]}	%{[zeek_cols][netmask]}	%{[zeek_cols][desig_router]}	%{[zeek_cols][backup_router]}	%{[zeek_cols][neighbors]}	%{[zeek_cols][lsa_type]}	%{[zeek_cols][link_state_id]}	%{[zeek_cols][advert_router]}	%{[zeek_cols][routers]}	%{[zeek_cols][link_id]}	%{[zeek_cols][link_data]}	%{[zeek_cols][link_type]}	%{[zeek_cols][neighbor_router_id]}	%{[zeek_cols][metrics]}	%{[zeek_cols][fwd_addrs]}	%{[zeek_cols][route_tags]}	%{[zeek_cols][neighbor_interface_id]}	%{[zeek_cols][prefix]}	%{[zeek_cols][metric]}	%{[zeek_cols][dest_router_id]}	%{[zeek_cols][link_prefixes]}	%{[zeek_cols][intra_prefixes]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ospf"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }

      ruby {
        id => "ruby_zip_zeek_ospf"
        init => "$zeek_ospf_field_names = [ 'ts', 'orig_h', 'resp_h', 'ospf_type', 'version', 'router_id', 'area_id', 'interface_id', 'netmask', 'desig_router', 'backup_router', 'neighbors', 'lsa_type', 'link_state_id', 'advert_router', 'routers', 'link_id', 'link_data', 'link_type', 'neighbor_router_id', 'metrics', 'fwd_addrs', 'route_tags', 'neighbor_interface_id', 'prefix', 'metric', 'dest_router_id', 'link_prefixes', 'intra_prefixes' ]"
        code => "event.set('[zeek_cols]', $zeek_ospf_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ospf"
      add_field => {
        "[zeek_cols][proto]" => "ospf"
        "[zeek_cols][service]" => "ospf"
      }
    }

  } else if ([log_source] == "pe") {
    #############################################################################################################################
    # pe.log
    # https://docs.zeek.org/en/stable/scripts/base/files/pe/main.zeek.html#type-PE::Info

    dissect {
      id => "dissect_zeek_pe"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][machine]}	%{[zeek_cols][compile_ts]}	%{[zeek_cols][os]}	%{[zeek_cols][subsystem]}	%{[zeek_cols][is_exe]}	%{[zeek_cols][is_64bit]}	%{[zeek_cols][uses_aslr]}	%{[zeek_cols][uses_dep]}	%{[zeek_cols][uses_code_integrity]}	%{[zeek_cols][uses_seh]}	%{[zeek_cols][has_import_table]}	%{[zeek_cols][has_export_table]}	%{[zeek_cols][has_cert_table]}	%{[zeek_cols][has_debug_data]}	%{[zeek_cols][section_names]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_pe"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_pe"
        init => "$zeek_pe_field_names = [ 'ts', 'fuid', 'machine', 'compile_ts', 'os', 'subsystem', 'is_exe', 'is_64bit', 'uses_aslr', 'uses_dep', 'uses_code_integrity', 'uses_seh', 'has_import_table', 'has_export_table', 'has_cert_table', 'has_debug_data', 'section_names' ]"
        code => "event.set('[zeek_cols]', $zeek_pe_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "profinet") {
    #############################################################################################################################
    # profinet.log
    # https://github.com/amzn/zeek-plugin-profinet/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_profinet"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][operation_type]}	%{[zeek_cols][block_version]}	%{[zeek_cols][slot_number]}	%{[zeek_cols][subslot_number]}	%{[zeek_cols][index]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_profinet"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_profinet"
        init => "$zeek_profinet_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'operation_type', 'block_version', 'slot_number', 'subslot_number', 'index' ]"
        code => "event.set('[zeek_cols]', $zeek_profinet_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_profinet"
      add_field =>  { "[zeek_cols][service]" => "profinet" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "profinet_dce_rpc") {
    #############################################################################################################################
    # profinet_dce_rpc.log
    # https://github.com/amzn/zeek-plugin-profinet/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_profinet_dce_rpc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][packet_type]}	%{[zeek_cols][object_uuid]}	%{[zeek_cols][interface_uuid]}	%{[zeek_cols][activity_uuid]}	%{[zeek_cols][server_boot_time]}	%{[zeek_cols][operation]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_profinet_dce_rpc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_profinet_dce_rpc"
        init => "$zeek_profinet_dce_rpc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'packet_type', 'object_uuid', 'interface_uuid', 'activity_uuid', 'server_boot_time', 'operation' ]"
        code => "event.set('[zeek_cols]', $zeek_profinet_dce_rpc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_profinet_dce_rpc"
      add_field =>  { "[zeek_cols][service]" => "profinet_dce_rpc" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "radius") {
    #############################################################################################################################
    # radius.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/radius/main.zeek.html#type-RADIUS::Info

    dissect {
      id => "dissect_zeek_radius"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][mac]}	%{[zeek_cols][framed_addr]}	%{[zeek_cols][tunnel_client]}	%{[zeek_cols][connect_info]}	%{[zeek_cols][reply_msg]}	%{[zeek_cols][result]}	%{[zeek_cols][ttl]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_radius"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_radius"
        init => "$zeek_radius_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user', 'mac', 'framed_addr', 'tunnel_client', 'connect_info', 'reply_msg', 'result', 'ttl' ]"
        code => "event.set('[zeek_cols]', $zeek_radius_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_radius"
      add_field =>  { "[zeek_cols][service]" => "radius" }
    }

  } else if ([log_source] == "rdp") {
    #############################################################################################################################
    # rdp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/rdp/main.zeek.html#type-RDP::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap rdp.log field configuration version 0
      # all fields:             0x03FFFFF / 4194303
      # minus client_channels:  0x03FFDFF / 4193791

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 4194303) {
          dissect {
            id => "dissect_zeek_rdp_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cookie]}	%{[zeek_cols][result]}	%{[zeek_cols][security_protocol]}	%{[zeek_cols][client_channels]}	%{[zeek_cols][keyboard_layout]}	%{[zeek_cols][client_build]}	%{[zeek_cols][client_name]}	%{[zeek_cols][client_dig_product_id]}	%{[zeek_cols][desktop_width]}	%{[zeek_cols][desktop_height]}	%{[zeek_cols][requested_color_depth]}	%{[zeek_cols][cert_type]}	%{[zeek_cols][cert_count]}	%{[zeek_cols][cert_permanent]}	%{[zeek_cols][encryption_level]}	%{[zeek_cols][encryption_method]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 4193791) {
          dissect {
            id => "dissect_zeek_rdp_with_all_fields_minus_client_channels"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cookie]}	%{[zeek_cols][result]}	%{[zeek_cols][security_protocol]}	%{[zeek_cols][keyboard_layout]}	%{[zeek_cols][client_build]}	%{[zeek_cols][client_name]}	%{[zeek_cols][client_dig_product_id]}	%{[zeek_cols][desktop_width]}	%{[zeek_cols][desktop_height]}	%{[zeek_cols][requested_color_depth]}	%{[zeek_cols][cert_type]}	%{[zeek_cols][cert_count]}	%{[zeek_cols][cert_permanent]}	%{[zeek_cols][encryption_level]}	%{[zeek_cols][encryption_method]}"
            }
          }

        } else {
          # who knows? the rdp.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_rdp_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the rdp.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_rdp_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the rdp.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_rdp_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_rdp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_rdp"
        init => "$zeek_rdp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'cookie', 'result', 'security_protocol', 'client_channels', 'keyboard_layout', 'client_build', 'client_name', 'client_dig_product_id', 'desktop_width', 'desktop_height', 'requested_color_depth', 'cert_type', 'cert_count', 'cert_permanent', 'encryption_level', 'encryption_method' ]"
        code => "event.set('[zeek_cols]', $zeek_rdp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_rdp"
      add_field =>  { "[zeek_cols][service]" => "rdp" }
    }

    # remove RDP prefix from client_build (version)
    mutate { id => "mutate_gsub_field_zeek_rdp_client_build"
             gsub => [ "[zeek_cols][client_build]", "^RDP ", "" ] }

  } else if ([log_source] == "rfb") {
    #############################################################################################################################
    # rfb.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/rfb/main.zeek.html#type-RFB::Info

    dissect {
      id => "dissect_zeek_rfb"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][client_major_version]}	%{[zeek_cols][client_minor_version]}	%{[zeek_cols][server_major_version]}	%{[zeek_cols][server_minor_version]}	%{[zeek_cols][authentication_method]}	%{[zeek_cols][auth]}	%{[zeek_cols][share_flag]}	%{[zeek_cols][desktop_name]}	%{[zeek_cols][width]}	%{[zeek_cols][height]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_rfb"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_rfb"
        init => "$zeek_rfb_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'client_major_version', 'client_minor_version', 'server_major_version', 'server_minor_version', 'authentication_method', 'auth', 'share_flag', 'desktop_name', 'width', 'height' ]"
        code => "event.set('[zeek_cols]', $zeek_rfb_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_rfb"
      add_field =>  { "[zeek_cols][service]" => "rfb" }
    }

  } else if ([log_source] == "s7comm") {
    #############################################################################################################################
    # s7comm.log
    # https://github.com/cisagov/icsnpp-s7comm

    dissect {
      id => "dissect_zeek_s7comm"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][rosctr_code]}	%{[zeek_cols][rosctr_name]}	%{[zeek_cols][pdu_reference]}	%{[zeek_cols][function_code]}	%{[zeek_cols][function_name]}	%{[zeek_cols][subfunction_code]}	%{[zeek_cols][subfunction_name]}	%{[zeek_cols][error_class]}	%{[zeek_cols][error_code]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_s7comm"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_s7comm"
        init => "$zeek_s7comm_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'is_orig', 'rosctr_code', 'rosctr_name', 'pdu_reference', 'function_code', 'function_name', 'subfunction_code', 'subfunction_name', 'error_class', 'error_code' ]"
        code => "event.set('[zeek_cols]', $zeek_s7comm_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_s7comm"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "s7comm"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "s7comm_plus") {
    #############################################################################################################################
    # s7comm_plus.log
    # https://github.com/cisagov/icsnpp-s7comm

    dissect {
      id => "dissect_zeek_s7comm_plus"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][version]}	%{[zeek_cols][opcode]}	%{[zeek_cols][opcode_name]}	%{[zeek_cols][function_code]}	%{[zeek_cols][function_name]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_s7comm_plus"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_s7comm_plus"
        init => "$zeek_s7comm_plus_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'is_orig', 'version', 'opcode', 'opcode_name', 'function_code', 'function_name' ]"
        code => "event.set('[zeek_cols]', $zeek_s7comm_plus_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_s7comm_plus"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "s7comm_plus"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "s7comm_read_szl") {
    #############################################################################################################################
    # s7comm_read_szl.log
    # https://github.com/cisagov/icsnpp-s7comm

    dissect {
      id => "dissect_zeek_s7comm_read_szl"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][pdu_reference]}	%{[zeek_cols][method]}	%{[zeek_cols][szl_id]}	%{[zeek_cols][szl_id_name]}	%{[zeek_cols][szl_index]}	%{[zeek_cols][return_code]}	%{[zeek_cols][return_code_name]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_s7comm_read_szl"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_s7comm_read_szl"
        init => "$zeek_s7comm_read_szl_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'pdu_reference', 'method', 'szl_id', 'szl_id_name', 'szl_index', 'return_code', 'return_code_name' ]"
        code => "event.set('[zeek_cols]', $zeek_s7comm_read_szl_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_s7comm_read_szl"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "s7comm"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "s7comm_upload_download") {
    #############################################################################################################################
    # s7comm_upload_download.log
    # https://github.com/cisagov/icsnpp-s7comm

    dissect {
      id => "dissect_zeek_s7comm_upload_download"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][rosctr_name]}	%{[zeek_cols][pdu_reference]}	%{[zeek_cols][function_name]}	%{[zeek_cols][function_status]}	%{[zeek_cols][session_id]}	%{[zeek_cols][blocklength]}	%{[zeek_cols][filename]}	%{[zeek_cols][block_type]}	%{[zeek_cols][block_number]}	%{[zeek_cols][destination_filesystem]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_s7comm_upload_download"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_s7comm_upload_download"
        init => "$zeek_s7comm_upload_download_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'rosctr_name', 'pdu_reference', 'function_name', 'function_status', 'session_id', 'blocklength', 'filename', 'block_type', 'block_number', 'destination_filesystem' ]"
        code => "event.set('[zeek_cols]', $zeek_s7comm_upload_download_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_s7comm_upload_download"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "s7comm"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "signatures") {
    #############################################################################################################################
    # signatures.log

    dissect {
      id => "dissect_zeek_signatures"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][note]}	%{[zeek_cols][signature_id]}	%{[zeek_cols][event_message]}	%{[zeek_cols][sub_message]}	%{[zeek_cols][signature_count]}	%{[zeek_cols][host_count]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_signatures"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_signatures"
        init => "$zeek_signatures_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'note', 'signature_id', 'event_message', 'sub_message', 'signature_count', 'host_count' ]"
        code => "event.set('[zeek_cols]', $zeek_signatures_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "sip") {
    #############################################################################################################################
    # sip.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/sip/main.zeek.html#type-SIP::Info

    dissect {
      id => "dissect_zeek_sip"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][uri]}	%{[zeek_cols][date]}	%{[zeek_cols][request_from]}	%{[zeek_cols][request_to]}	%{[zeek_cols][response_from]}	%{[zeek_cols][response_to]}	%{[zeek_cols][reply_to]}	%{[zeek_cols][call_id]}	%{[zeek_cols][seq]}	%{[zeek_cols][subject]}	%{[zeek_cols][request_path]}	%{[zeek_cols][response_path]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][warning]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][content_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_sip"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_sip"
        init => "$zeek_sip_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'trans_depth', 'method', 'uri', 'date', 'request_from', 'request_to', 'response_from', 'response_to', 'reply_to', 'call_id', 'seq', 'subject', 'request_path', 'response_path', 'user_agent', 'status_code', 'status_msg', 'warning', 'request_body_len', 'response_body_len', 'content_type' ]"
        code => "event.set('[zeek_cols]', $zeek_sip_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_sip"
      add_field =>  { "[zeek_cols][service]" => "sip" }
    }

  } else if ([log_source] == "smb_cmd") {
    #############################################################################################################################
    # smb_cmd.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/smb/main.zeek.html#type-SMB::CmdInfo
    #
    # note that smb_cmd.referenced_file is exactly the same structure as the log line for smb_files. later on it will be
    # merged up as its own top-level entity so I don't have to duplicate the parsing effort below

    dissect {
      id => "dissect_zeek_smb_cmd"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][command]}	%{[zeek_cols][sub_command]}	%{[zeek_cols][argument]}	%{[zeek_cols][status]}	%{[zeek_cols][rtt]}	%{[zeek_cols][version]}	%{[zeek_cols][user]}	%{[zeek_cols][tree]}	%{[zeek_cols][tree_service]}	%{[zeek_cols][referenced_file][ts]}	%{[zeek_cols][referenced_file][uid]}	%{[zeek_cols][referenced_file][orig_h]}	%{[zeek_cols][referenced_file][orig_p]}	%{[zeek_cols][referenced_file][resp_h]}	%{[zeek_cols][referenced_file][resp_p]}	%{[zeek_cols][referenced_file][fuid]}	%{[zeek_cols][referenced_file][action]}	%{[zeek_cols][referenced_file][path]}	%{[zeek_cols][referenced_file][name]}	%{[zeek_cols][referenced_file][size]}	%{[zeek_cols][referenced_file][prev_name]}	%{[zeek_cols][referenced_file][times_modified]}	%{[zeek_cols][referenced_file][times_accessed]}	%{[zeek_cols][referenced_file][times_created]}	%{[zeek_cols][referenced_file][times_changed]}	%{[zeek_cols][referenced_file][data_offset_req]}	%{[zeek_cols][referenced_file][data_len_req]}	%{[zeek_cols][referenced_file][data_len_rsp]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smb_cmd"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smb_cmd"
        init => "$zeek_smb_cmd_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'command', 'sub_command', 'argument', 'status', 'rtt', 'version', 'user', 'tree', 'tree_service', 'referenced_file.ts', 'referenced_file.uid', 'referenced_file.orig_h', 'referenced_file.orig_p', 'referenced_file.resp_h', 'referenced_file.resp_p', 'referenced_file.fuid', 'referenced_file.action', 'referenced_file.path', 'referenced_file.name', 'referenced_file.size', 'referenced_file.prev_name', 'referenced_file.times_modified', 'referenced_file.times_accessed', 'referenced_file.times_created', 'referenced_file.times_changed', 'referenced_file.data_offset_req', 'referenced_file.data_len_req', 'referenced_file.data_len_rsp' ]"
        code => "event.set('[zeek_cols]', $zeek_smb_cmd_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smb_cmd"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smb"
      }
    }

    # remove SMB prefix from version
    mutate { id => "mutate_gsub_field_zeek_smb_cmd_version"
             gsub => [ "[zeek_cols][version]", "^SMB", "" ] }

    mutate { id => "mutate_gsub_zeek_smb_cmd_command"
             gsub => [ "[zeek_cols][command]", "^SMB::", "" ] }

  } else if ([log_source] == "smb_files") {
    #############################################################################################################################
    # smb_files.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/smb/main.zeek.html#type-SMB::FileInfo

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap smb_files.log field configuration version 0
      #
      # smb_files.log without data_offset_req, data_len_req, data_len_rsp : 0x0000FFFF / 65535
      # smb_files.log with data_offset_req, data_len_req, data_len_rsp :    0x0007FFFF / 524287

      # smb_files.log with data_offset_req, data_len_req, data_len_rsp

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 524287) {

          dissect {
            id => "dissect_zeek_smb_files_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fuid]}	%{[zeek_cols][action]}	%{[zeek_cols][path]}	%{[zeek_cols][name]}	%{[zeek_cols][size]}	%{[zeek_cols][prev_name]}	%{[zeek_cols][times_modified]}	%{[zeek_cols][times_accessed]}	%{[zeek_cols][times_created]}	%{[zeek_cols][times_changed]}	%{[zeek_cols][data_offset_req]}	%{[zeek_cols][data_len_req]}	%{[zeek_cols][data_len_rsp]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 65535) {

          dissect {
            id => "dissect_zeek_smb_files_without_data_lens"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fuid]}	%{[zeek_cols][action]}	%{[zeek_cols][path]}	%{[zeek_cols][name]}	%{[zeek_cols][size]}	%{[zeek_cols][prev_name]}	%{[zeek_cols][times_modified]}	%{[zeek_cols][times_accessed]}	%{[zeek_cols][times_created]}	%{[zeek_cols][times_changed]}"
            }
          }

        } else {
          # who knows? the smb_files.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_smb_files_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the smb_files.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_smb_files_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the smb_files.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_smb_files_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smb_files"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smb_files"
        init => "$zeek_smb_files_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'fuid', 'action', 'path', 'name', 'size', 'prev_name', 'times_modified', 'times_accessed', 'times_created', 'times_changed', 'data_offset_req', 'data_len_req', 'data_len_rsp' ]"
        code => "event.set('[zeek_cols]', $zeek_smb_files_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smb_files"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smb"
      }
    }

    mutate { id => "mutate_gsub_zeek_smb_files_action"
             gsub => [ "[zeek_cols][action]", "^SMB::", "" ] }

  } else if ([log_source] == "smb_mapping") {
    #############################################################################################################################
    # smb_mapping.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/smb/main.zeek.html#type-SMB::TreeInfo

    dissect {
      id => "dissect_zeek_smb_mapping"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][path]}	%{[zeek_cols][resource_type]}	%{[zeek_cols][native_file_system]}	%{[zeek_cols][share_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smb_mapping"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smb_mapping"
        init => "$zeek_smb_mapping_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'path', 'resource_type', 'native_file_system', 'share_type' ]"
        code => "event.set('[zeek_cols]', $zeek_smb_mapping_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smb_mapping"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smb"
      }
    }

  } else if ([log_source] == "smtp") {
    #############################################################################################################################
    # smtp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/smtp/main.zeek.html#type-SMTP::Info

    dissect {
      id => "dissect_zeek_smtp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][helo]}	%{[zeek_cols][mailfrom]}	%{[zeek_cols][rcptto]}	%{[zeek_cols][date]}	%{[zeek_cols][from]}	%{[zeek_cols][to]}	%{[zeek_cols][cc]}	%{[zeek_cols][reply_to]}	%{[zeek_cols][msg_id]}	%{[zeek_cols][in_reply_to]}	%{[zeek_cols][subject]}	%{[zeek_cols][x_originating_ip]}	%{[zeek_cols][first_received]}	%{[zeek_cols][second_received]}	%{[zeek_cols][last_reply]}	%{[zeek_cols][path]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][tls]}	%{[zeek_cols][fuid]}	%{[zeek_cols][is_webmail]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smtp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smtp"
        init => "$zeek_smtp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'trans_depth', 'helo', 'mailfrom', 'rcptto', 'date', 'from', 'to', 'cc', 'reply_to', 'msg_id', 'in_reply_to', 'subject', 'x_originating_ip', 'first_received', 'second_received', 'last_reply', 'path', 'user_agent', 'tls', 'fuid', 'is_webmail' ]"
        code => "event.set('[zeek_cols]', $zeek_smtp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smtp"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smtp"
      }
    }

  } else if ([log_source] == "snmp") {
    #############################################################################################################################
    # snmp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/snmp/main.zeek.html#type-SNMP::Info

    dissect {
      id => "dissect_zeek_snmp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][duration]}	%{[zeek_cols][version]}	%{[zeek_cols][community]}	%{[zeek_cols][get_requests]}	%{[zeek_cols][get_bulk_requests]}	%{[zeek_cols][get_responses]}	%{[zeek_cols][set_requests]}	%{[zeek_cols][display_string]}	%{[zeek_cols][up_since]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_snmp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_snmp"
        init => "$zeek_snmp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'duration', 'version', 'community', 'get_requests', 'get_bulk_requests', 'get_responses', 'set_requests', 'display_string', 'up_since' ]"
        code => "event.set('[zeek_cols]', $zeek_snmp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_snmp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "snmp"
      }
    }

  } else if ([log_source] == "socks") {
    #############################################################################################################################
    # socks.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/socks/main.zeek.html#type-SOCKS::Info

    dissect {
      id => "dissect_zeek_socks"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][server_status]}	%{[zeek_cols][request_host]}	%{[zeek_cols][request_name]}	%{[zeek_cols][request_port]}	%{[zeek_cols][bound_host]}	%{[zeek_cols][bound_name]}	%{[zeek_cols][bound_port]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_socks"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_socks"
        init => "$zeek_socks_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'user', 'password', 'server_status', 'request_host', 'request_name', 'request_port', 'bound_host', 'bound_name', 'bound_port' ]"
        code => "event.set('[zeek_cols]', $zeek_socks_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_socks"
      add_field =>  { "[zeek_cols][service]" => "socks" }
    }

  } else if ([log_source] == "software") {
    #############################################################################################################################
    # software.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/software/main.zeek.html#type-Software::Info

    dissect {
      id => "dissect_zeek_software"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][software_type]}	%{[zeek_cols][name]}	%{[zeek_cols][version_major]}	%{[zeek_cols][version_minor]}	%{[zeek_cols][version_minor2]}	%{[zeek_cols][version_minor3]}	%{[zeek_cols][version_addl]}	%{[zeek_cols][unparsed_version]}	%{[zeek_cols][url]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_software"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_software"
        init => "$zeek_software_field_names = [ 'ts', 'orig_h', 'orig_p', 'software_type', 'name', 'version_major', 'version_minor', 'version_minor2', 'version_minor3', 'version_addl', 'unparsed_version', 'url' ]"
        code => "event.set('[zeek_cols]', $zeek_software_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "wireguard") {
    #############################################################################################################################
    # wireguard.log
    # https://github.com/corelight/zeek-spicy-wireguard/blob/master/analyzer/main.zeek

    dissect {
      id => "dissect_zeek_wireguard"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][established]}	%{[zeek_cols][initiations]}	%{[zeek_cols][responses]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_wireguard"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_wireguard"
        init => "$zeek_wireguard_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'established', 'initiations', 'responses' ]"
        code => "event.set('[zeek_cols]', $zeek_wireguard_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_gsub_zeek_wireguard_packet_type"
             gsub => [ "[zeek_cols][packet_type]", "Wireguard::WG_", "" ] }

    mutate {
      id => "mutate_add_field_zeek_service_wireguard"
      add_field =>  {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "wireguard"
      }
    }

  } else if ([log_source] == "ssh") {
    #############################################################################################################################
    # ssh.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/ssh/main.zeek.html#type-SSH::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap ssh.log field configuration version 0
      #
      # standard ssh.log without HASSH fingerprinting add-on script : 0x007FFFFF / 8388607
      # ssh.log with HASSH fingerprinting add-on script :             0x3FFFFFFF / 1073741823

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 1073741823) {

          dissect {
            id => "dissect_zeek_ssh_with_all_fields_with_hassh"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][auth_success]}	%{[zeek_cols][auth_attempts]}	%{[zeek_cols][direction]}	%{[zeek_cols][client]}	%{[zeek_cols][server]}	%{[zeek_cols][cipher_alg]}	%{[zeek_cols][mac_alg]}	%{[zeek_cols][compression_alg]}	%{[zeek_cols][kex_alg]}	%{[zeek_cols][host_key_alg]}	%{[zeek_cols][host_key]}	%{[zeek_cols][remote_location_country_code]}	%{[zeek_cols][remote_location_region]}	%{[zeek_cols][remote_location_city]}	%{[zeek_cols][remote_location_latitude]}	%{[zeek_cols][remote_location_longitude]}	%{[zeek_cols][hasshVersion]}	%{[zeek_cols][hassh]}	%{[zeek_cols][hasshServer]}	%{[zeek_cols][cshka]}	%{[zeek_cols][hasshAlgorithms]}	%{[zeek_cols][sshka]}	%{[zeek_cols][hasshServerAlgorithms]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 8388607) {

          dissect {
            id => "dissect_zeek_ssh_with_all_fields_no_hassh"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][auth_success]}	%{[zeek_cols][auth_attempts]}	%{[zeek_cols][direction]}	%{[zeek_cols][client]}	%{[zeek_cols][server]}	%{[zeek_cols][cipher_alg]}	%{[zeek_cols][mac_alg]}	%{[zeek_cols][compression_alg]}	%{[zeek_cols][kex_alg]}	%{[zeek_cols][host_key_alg]}	%{[zeek_cols][host_key]}	%{[zeek_cols][remote_location_country_code]}	%{[zeek_cols][remote_location_region]}	%{[zeek_cols][remote_location_city]}	%{[zeek_cols][remote_location_latitude]}	%{[zeek_cols][remote_location_longitude]}"
            }
          }

        } else {
          # who knows? the ssh.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_ssh_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the ssh.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_ssh_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the ssh.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_ssh_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ssh"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ssh"
        init => "$zeek_ssh_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'auth_success', 'auth_attempts', 'direction', 'client', 'server', 'cipher_alg', 'mac_alg', 'compression_alg', 'kex_alg', 'host_key_alg', 'host_key', 'remote_location_country_code', 'remote_location_region', 'remote_location_city', 'remote_location_latitude', 'remote_location_longitude', 'hasshVersion', 'hassh', 'hasshServer', 'cshka', 'hasshAlgorithms', 'sshka', 'hasshServerAlgorithms' ]"
        code => "event.set('[zeek_cols]', $zeek_ssh_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ssh"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "ssh"
      }
    }

  } else if ([log_source] == "ssl") {
    #############################################################################################################################
    # ssl.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/ssl/main.zeek.html#type-SSL::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap ssl.log (v4.1.0+) field configuration version 0
      #
      # standard ssl.log fields without add-on JA3 fingerprinting script :  0x0007FFFF /  524287
      # ssl.log fields with add-on JA3 fingerprinting script :              0x001FFFFF / 2097151

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 2097151) {

          dissect {
            id => "dissect_zeek_ssl_v1_with_ja3"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][ssl_version]}	%{[zeek_cols][cipher]}	%{[zeek_cols][curve]}	%{[zeek_cols][server_name]}	%{[zeek_cols][resumed]}	%{[zeek_cols][last_alert]}	%{[zeek_cols][next_protocol]}	%{[zeek_cols][established]}	%{[zeek_cols][ssl_history]}	%{[zeek_cols][cert_chain_fps]}	%{[zeek_cols][client_cert_chain_fps]}	%{[zeek_cols][sni_matches_cert]}	%{[zeek_cols][validation_status]}	%{[zeek_cols][ja3]}	%{[zeek_cols][ja3s]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 524287) {

          dissect {
            id => "dissect_zeek_ssl_v1_without_ja3"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][ssl_version]}	%{[zeek_cols][cipher]}	%{[zeek_cols][curve]}	%{[zeek_cols][server_name]}	%{[zeek_cols][resumed]}	%{[zeek_cols][last_alert]}	%{[zeek_cols][next_protocol]}	%{[zeek_cols][established]}	%{[zeek_cols][ssl_history]}	%{[zeek_cols][cert_chain_fps]}	%{[zeek_cols][client_cert_chain_fps]}	%{[zeek_cols][sni_matches_cert]}	%{[zeek_cols][validation_status]}"
            }
          }

        } else {
          # who knows? the ssl.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_ssl_v1_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the ssl.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_ssl_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the ssl.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_ssl_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ssl"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ssl"
        init => "$zeek_ssl_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'ssl_version', 'cipher', 'curve', 'server_name', 'resumed', 'last_alert', 'next_protocol', 'established', 'ssl_history', 'cert_chain_fps', 'client_cert_chain_fps', 'sni_matches_cert', 'validation_status', 'ja3', 'ja3s' ]"
        code => "event.set('[zeek_cols]', $zeek_ssl_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ssl"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tls"
      }
    }

  } else if ([log_source] == "stun") {
    #############################################################################################################################
    # stun.log
    # https://github.com/corelight/zeek-spicy-stun/blob/master/analyzer/main.zeek

    dissect {
      id => "dissect_zeek_stun"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][trans_id]}	%{[zeek_cols][method]}	%{[zeek_cols][class]}	%{[zeek_cols][attr_type]}	%{[zeek_cols][attr_val]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_stun"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_stun"
        init => "$zeek_stun_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'is_orig', 'trans_id', 'method', 'class', 'attr_type', 'attr_val' ]"
        code => "event.set('[zeek_cols]', $zeek_stun_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_stun"
      add_field => {
        "[zeek_cols][service]" => "stun"
      }
    }

  } else if ([log_source] == "stun_nat") {
    #############################################################################################################################
    # stun.log
    # https://github.com/corelight/zeek-spicy-stun/blob/master/analyzer/main.zeek

    dissect {
      id => "dissect_zeek_stun_nat"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][wan_addr]}	%{[zeek_cols][wan_port]}	%{[zeek_cols][lan_addr]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_stun_nat"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_stun_nat"
        init => "$zeek_stun_nat_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'is_orig', 'wan_addr', 'wan_port', 'lan_addr' ]"
        code => "event.set('[zeek_cols]', $zeek_stun_nat_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_stun_nat"
      add_field => {
        "[zeek_cols][service]" => "stun"
      }
    }

  } else if ([log_source] == "synchrophasor") {
    #############################################################################################################################
    # synchrophasor.log
    # main.zeek (https://github.com/cisagov/icsnpp-synchrophasor)

    dissect {
      id => "dissect_zeek_synchrophasor"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][version]}	%{[zeek_cols][data_stream_id]}	%{[zeek_cols][history]}	%{[zeek_cols][frame_size_min]}	%{[zeek_cols][frame_size_max]}	%{[zeek_cols][frame_size_tot]}	%{[zeek_cols][data_frame_count]}	%{[zeek_cols][data_rate]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_synchrophasor"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_synchrophasor"
        init => "$zeek_synchrophasor_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'version', 'data_stream_id', 'history', 'frame_size_min', 'frame_size_max', 'frame_size_tot', 'data_frame_count', 'data_rate' ]"
        code => "event.set('[zeek_cols]', $zeek_synchrophasor_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_synchrophasor"
      add_field => {
        "[zeek_cols][service]" => "synchrophasor"
      }
      add_tag => [ "ics" ]
    }


  } else if ([log_source] == "synchrophasor_cmd") {
    #############################################################################################################################
    # synchrophasor_cmd.log
    # main.zeek (https://github.com/cisagov/icsnpp-synchrophasor)

    dissect {
      id => "dissect_zeek_synchrophasor_cmd"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][frame_type]}	%{[zeek_cols][frame_size]}	%{[zeek_cols][header_time_stamp]}	%{[zeek_cols][command]}	%{[zeek_cols][extframe]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_synchrophasor_cmd"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_synchrophasor_cmd"
        init => "$zeek_synchrophasor_cmd_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'frame_type', 'frame_size', 'header_time_stamp', 'command', 'extframe' ]"
        code => "event.set('[zeek_cols]', $zeek_synchrophasor_cmd_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_synchrophasor_cmd"
      add_field => {
        "[zeek_cols][service]" => "synchrophasor"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "synchrophasor_cfg") {
    #############################################################################################################################
    # synchrophasor_cfg.log
    # main.zeek (https://github.com/cisagov/icsnpp-synchrophasor)

    dissect {
      id => "dissect_zeek_synchrophasor_cfg"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][frame_type]}	%{[zeek_cols][frame_size]}	%{[zeek_cols][header_time_stamp]}	%{[zeek_cols][cont_idx]}	%{[zeek_cols][pmu_count_expected]}	%{[zeek_cols][pmu_count_actual]}	%{[zeek_cols][data_rate]}	%{[zeek_cols][cfg_frame_id]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_synchrophasor_cfg"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_synchrophasor_cfg"
        init => "$zeek_synchrophasor_cfg_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'frame_type', 'frame_size', 'header_time_stamp', 'cont_idx', 'pmu_count_expected', 'pmu_count_actual', 'data_rate', 'cfg_frame_id' ]"
        code => "event.set('[zeek_cols]', $zeek_synchrophasor_cfg_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_synchrophasor_cfg"
      add_field => {
        "[zeek_cols][service]" => "synchrophasor"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "synchrophasor_cfg_detail") {
    #############################################################################################################################
    # synchrophasor_cfg_detail.log
    # main.zeek (https://github.com/cisagov/icsnpp-synchrophasor)

    dissect {
      id => "dissect_zeek_synchrophasor_cfg_detail"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][frame_type]}	%{[zeek_cols][header_time_stamp]}	%{[zeek_cols][cfg_frame_id]}	%{[zeek_cols][pmu_idx]}	%{[zeek_cols][svc_class]}	%{[zeek_cols][station_name]}	%{[zeek_cols][data_source_id]}	%{[zeek_cols][global_pmuid]}	%{[zeek_cols][phasor_shape]}	%{[zeek_cols][phasor_format]}	%{[zeek_cols][analog_format]}	%{[zeek_cols][freq_format]}	%{[zeek_cols][phnmr]}	%{[zeek_cols][annmr]}	%{[zeek_cols][dgnmr]}	%{[zeek_cols][phnam]}	%{[zeek_cols][annam]}	%{[zeek_cols][dgnam]}	%{[zeek_cols][phasor_conv_phunit]}	%{[zeek_cols][phasor_conv_phvalue]}	%{[zeek_cols][phasor_conv_upsampled_interpolation]}	%{[zeek_cols][phasor_conv_upsampled_extrapolation]}	%{[zeek_cols][phasor_conv_downsampled_reselection]}	%{[zeek_cols][phasor_conv_downsampled_fir_filter]}	%{[zeek_cols][phasor_conv_downsampled_no_fir_filter]}	%{[zeek_cols][phasor_conv_filtered_without_changing_sampling]}	%{[zeek_cols][phasor_conv_calibration_mag_adj]}	%{[zeek_cols][phasor_conv_calibration_phas_adj]}	%{[zeek_cols][phasor_conv_rotation_phase_adj]}	%{[zeek_cols][phasor_conv_pseudo_phasor_val]}	%{[zeek_cols][phasor_conv_mod_appl]}	%{[zeek_cols][phasor_conv_phasor_component]}	%{[zeek_cols][phasor_conv_phasor_type]}	%{[zeek_cols][phasor_conv_user_def]}	%{[zeek_cols][phasor_conv_scale_factor]}	%{[zeek_cols][phasor_conv_angle_adj]}	%{[zeek_cols][analog_conv_analog_flags]}	%{[zeek_cols][analog_conv_user_defined_scaling]}	%{[zeek_cols][analog_conv_mag_scale]}	%{[zeek_cols][analog_conv_offset]}	%{[zeek_cols][digital_conv_normal_status_mask]}	%{[zeek_cols][digital_conv_valid_inputs_mask]}	%{[zeek_cols][pmu_lat]}	%{[zeek_cols][pmu_lon]}	%{[zeek_cols][pmu_elev]}	%{[zeek_cols][window]}	%{[zeek_cols][group_delay]}	%{[zeek_cols][fnom]}	%{[zeek_cols][cfgcnt]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_synchrophasor_cfg_detail"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_synchrophasor_cfg_detail"
        init => "$zeek_synchrophasor_cfg_detail_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'frame_type', 'header_time_stamp', 'cfg_frame_id', 'pmu_idx', 'svc_class', 'station_name', 'data_source_id', 'global_pmuid', 'phasor_shape', 'phasor_format', 'analog_format', 'freq_format', 'phnmr', 'annmr', 'dgnmr', 'phnam', 'annam', 'dgnam', 'phasor_conv_phunit', 'phasor_conv_phvalue', 'phasor_conv_upsampled_interpolation', 'phasor_conv_upsampled_extrapolation', 'phasor_conv_downsampled_reselection', 'phasor_conv_downsampled_fir_filter', 'phasor_conv_downsampled_no_fir_filter', 'phasor_conv_filtered_without_changing_sampling', 'phasor_conv_calibration_mag_adj', 'phasor_conv_calibration_phas_adj', 'phasor_conv_rotation_phase_adj', 'phasor_conv_pseudo_phasor_val', 'phasor_conv_mod_appl', 'phasor_conv_phasor_component', 'phasor_conv_phasor_type', 'phasor_conv_user_def', 'phasor_conv_scale_factor', 'phasor_conv_angle_adj', 'analog_conv_analog_flags', 'analog_conv_user_defined_scaling', 'analog_conv_mag_scale', 'analog_conv_offset', 'digital_conv_normal_status_mask', 'digital_conv_valid_inputs_mask', 'pmu_lat', 'pmu_lon', 'pmu_elev', 'window', 'group_delay', 'fnom', 'cfgcnt' ]"
        code => "event.set('[zeek_cols]', $zeek_synchrophasor_cfg_detail_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_synchrophasor_cfg_detail"
      add_field => {
        "[zeek_cols][service]" => "synchrophasor"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "synchrophasor_data") {
    #############################################################################################################################
    # synchrophasor_data.log
    # main.zeek (https://github.com/cisagov/icsnpp-synchrophasor)

    dissect {
      id => "dissect_zeek_synchrophasor_data"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][frame_type]}	%{[zeek_cols][frame_size]}	%{[zeek_cols][header_time_stamp]}	%{[zeek_cols][pmu_count_expected]}	%{[zeek_cols][pmu_count_actual]}	%{[zeek_cols][data_frame_id]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_synchrophasor_data"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_synchrophasor_data"
        init => "$zeek_synchrophasor_data_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'frame_type', 'frame_size', 'header_time_stamp', 'pmu_count_expected', 'pmu_count_actual', 'data_frame_id' ]"
        code => "event.set('[zeek_cols]', $zeek_synchrophasor_data_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_synchrophasor_data"
      add_field => {
        "[zeek_cols][service]" => "synchrophasor"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "synchrophasor_data_detail") {
    #############################################################################################################################
    # synchrophasor_data_detail.log
    # main.zeek (https://github.com/cisagov/icsnpp-synchrophasor)

    dissect {
      id => "dissect_zeek_synchrophasor_data_detail"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][frame_type]}	%{[zeek_cols][header_time_stamp]}	%{[zeek_cols][data_frame_id]}	%{[zeek_cols][pmu_idx]}	%{[zeek_cols][trigger_reason]}	%{[zeek_cols][unlocked_time]}	%{[zeek_cols][pmu_time_quality]}	%{[zeek_cols][data_modified]}	%{[zeek_cols][config_change]}	%{[zeek_cols][pmu_trigger_pickup]}	%{[zeek_cols][data_sorting_type]}	%{[zeek_cols][pmu_sync_error]}	%{[zeek_cols][data_error_indicator]}	%{[zeek_cols][est_rectangular_real]}	%{[zeek_cols][est_rectangular_imaginary]}	%{[zeek_cols][est_polar_magnitude]}	%{[zeek_cols][est_polar_angle]}	%{[zeek_cols][freq_dev_mhz]}	%{[zeek_cols][rocof]}	%{[zeek_cols][analog_data]}	%{[zeek_cols][digital]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_synchrophasor_data_detail"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_synchrophasor_data_detail"
        init => "$zeek_synchrophasor_data_detail_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'frame_type', 'header_time_stamp', 'data_frame_id', 'pmu_idx', 'trigger_reason', 'unlocked_time', 'pmu_time_quality', 'data_modified', 'config_change', 'pmu_trigger_pickup', 'data_sorting_type', 'pmu_sync_error', 'data_error_indicator', 'est_rectangular_real', 'est_rectangular_imaginary', 'est_polar_magnitude', 'est_polar_angle', 'freq_dev_mhz', 'rocof', 'analog_data', 'digital' ]"
        code => "event.set('[zeek_cols]', $zeek_synchrophasor_data_detail_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_synchrophasor_data_detail"
      add_field => {
        "[zeek_cols][service]" => "synchrophasor"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "synchrophasor_hdr") {
    #############################################################################################################################
    # synchrophasor_hdr.log
    # main.zeek (https://github.com/cisagov/icsnpp-synchrophasor)

    dissect {
      id => "dissect_zeek_synchrophasor_hdr"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][frame_type]}	%{[zeek_cols][frame_size]}	%{[zeek_cols][header_time_stamp]}	%{[zeek_cols][data]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_synchrophasor_hdr"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_synchrophasor_hdr"
        init => "$zeek_synchrophasor_hdr_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'frame_type', 'frame_size', 'header_time_stamp', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_synchrophasor_hdr_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_synchrophasor_hdr"
      add_field => {
        "[zeek_cols][service]" => "synchrophasor"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "syslog") {
    #############################################################################################################################
    # syslog.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/syslog/main.zeek.html#type-Syslog::Info

    dissect {
      id => "dissect_zeek_syslog"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][facility]}	%{[zeek_cols][severity]}	%{[zeek_cols][message]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_syslog"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_syslog"
        init => "$zeek_syslog_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'facility', 'severity', 'message' ]"
        code => "event.set('[zeek_cols]', $zeek_syslog_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_syslog"
      add_field =>  { "[zeek_cols][service]" => "syslog" }
    }

  } else if ([log_source] == "tds") {
    #############################################################################################################################
    # tds.log
    # https://github.com/amzn/zeek-plugin-tds/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_tds"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][command]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tds"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tds"
        init => "$zeek_tds_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'command' ]"
        code => "event.set('[zeek_cols]', $zeek_tds_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tds"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tds"
      }
    }

  } else if ([log_source] == "tds_rpc") {
    #############################################################################################################################
    # tds_rpc.log
    # https://github.com/amzn/zeek-plugin-tds/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_tds_rpc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][procedure_name]}	%{[zeek_cols][parameter]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tds_rpc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tds_rpc"
        init => "$zeek_tds_rpc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'procedure_name', 'parameter' ]"
        code => "event.set('[zeek_cols]', $zeek_tds_rpc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tds_rpc"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tds"
      }
    }

  } else if ([log_source] == "tds_sql_batch") {
    #############################################################################################################################
    # tds_sql_batch.log
    # https://github.com/amzn/zeek-plugin-tds/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_tds_sql_batch"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][header_type]}	%{[zeek_cols][query]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tds_sql_batch"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tds_sql_batch"
        init => "$zeek_tds_sql_batch_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'header_type', 'query' ]"
        code => "event.set('[zeek_cols]', $zeek_tds_sql_batch_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tds_sql_batch"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tds"
      }
    }

  } else if ([log_source] == "tftp") {
    #############################################################################################################################
    # tftp.log
    # https://github.com/zeek/spicy-tftp

    dissect {
      id => "dissect_zeek_tftp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][wrq]}	%{[zeek_cols][fname]}	%{[zeek_cols][mode]}	%{[zeek_cols][uid_data]}	%{[zeek_cols][size]}	%{[zeek_cols][block_sent]}	%{[zeek_cols][block_acked]}	%{[zeek_cols][error_code]}	%{[zeek_cols][error_msg]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tftp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tftp"
        init => "$zeek_tftp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'wrq', 'fname', 'mode', 'uid_data', 'size', 'block_sent', 'block_acked', 'error_code', 'error_msg' ]"
        code => "event.set('[zeek_cols]', $zeek_tftp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tftp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "tftp"
      }
    }

  } else if ([log_source] == "tunnel") {
    #############################################################################################################################
    # tunnel.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/tunnels/main.zeek.html#type-Tunnel::Info

    dissect {
      id => "dissect_zeek_tunnel"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][tunnel_type]}	%{[zeek_cols][action]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tunnel"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tunnel"
        init => "$zeek_tunnel_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'tunnel_type', 'action' ]"
        code => "event.set('[zeek_cols]', $zeek_tunnel_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_gsub_zeek_tunnel_action"
             gsub => [ "[zeek_cols][action]", "Tunnel::", "" ] }

    mutate { id => "mutate_gsub_zeek_tunnel_type"
             gsub => [ "[zeek_cols][tunnel_type]", "Tunnel::", "" ] }

    mutate {
      id => "mutate_add_fields_zeek_tunnel"
      add_field =>  { "[zeek_cols][service]" => "%{[zeek_cols][tunnel_type]}" }
    }

    mutate { id => "mutate_lowercase_zeek_tunnel_service"
             lowercase => [ "[zeek_cols][service]" ] }

  } else if ([log_source] == "weird") {
    #############################################################################################################################
    # weird.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/notice/weird.zeek.html#type-Weird::Info

    dissect {
      id => "dissect_zeek_weird"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][name]}	%{[zeek_cols][addl]}	%{[zeek_cols][notice]}	%{[zeek_cols][peer]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_weird"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_weird"
        init => "$zeek_weird_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'name', 'addl', 'notice', 'peer' ]"
        code => "event.set('[zeek_cols]', $zeek_weird_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "x509") {
    #############################################################################################################################
    # x509.log
    # https://docs.zeek.org/en/stable/scripts/base/files/x509/main.zeek.html#type-X509::Info

    dissect {
      id => "dissect_zeek_x509_v1"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fingerprint]}	%{[zeek_cols][certificate_version]}	%{[zeek_cols][certificate_serial]}	%{[zeek_cols][certificate_subject]}	%{[zeek_cols][certificate_issuer]}	%{[zeek_cols][certificate_not_valid_before]}	%{[zeek_cols][certificate_not_valid_after]}	%{[zeek_cols][certificate_key_alg]}	%{[zeek_cols][certificate_sig_alg]}	%{[zeek_cols][certificate_key_type]}	%{[zeek_cols][certificate_key_length]}	%{[zeek_cols][certificate_exponent]}	%{[zeek_cols][certificate_curve]}	%{[zeek_cols][san_dns]}	%{[zeek_cols][san_uri]}	%{[zeek_cols][san_email]}	%{[zeek_cols][san_ip]}	%{[zeek_cols][basic_constraints_ca]}	%{[zeek_cols][basic_constraints_path_len]}	%{[zeek_cols][host_cert]}	%{[zeek_cols][client_cert]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_x509"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_x509"
        init => "$zeek_x509_field_names = [ 'ts', 'fuid', 'certificate_version', 'certificate_serial', 'certificate_subject', 'certificate_issuer', 'certificate_not_valid_before', 'certificate_not_valid_after', 'certificate_key_alg', 'certificate_sig_alg', 'certificate_key_type', 'certificate_key_length', 'certificate_exponent', 'certificate_curve', 'san_dns', 'san_uri', 'san_email', 'san_ip', 'basic_constraints_ca', 'basic_constraints_path_len', 'host_cert', 'client_cert' ]"
        code => "event.set('[zeek_cols]', $zeek_x509_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_fields_zeek_x509"
             add_field => { "[zeek_cols][service]" => "X.509" } }

  } else if ([log_source] =~ /^opcua_binary/) {

      if ([log_source] == "opcua_binary") {
      #############################################################################################################################
      # opcua_binary.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_link_id]}	%{[zeek_cols][msg_type]}	%{[zeek_cols][is_final]}	%{[zeek_cols][msg_size]}	%{[zeek_cols][error]}	%{[zeek_cols][reason]}	%{[zeek_cols][version]}	%{[zeek_cols][rcv_buf_size]}	%{[zeek_cols][snd_buf_size]}	%{[zeek_cols][max_msg_size]}	%{[zeek_cols][max_chunk_cnt]}	%{[zeek_cols][endpoint_url]}	%{[zeek_cols][sec_channel_id]}	%{[zeek_cols][sec_policy_uri_len]}	%{[zeek_cols][sec_policy_uri]}	%{[zeek_cols][snd_cert_len]}	%{[zeek_cols][snd_cert]}	%{[zeek_cols][rcv_cert_len]}	%{[zeek_cols][rcv_cert]}	%{[zeek_cols][seq_number]}	%{[zeek_cols][request_id]}	%{[zeek_cols][encoding_mask]}	%{[zeek_cols][namespace_idx]}	%{[zeek_cols][identifier]}	%{[zeek_cols][identifier_str]}	%{[zeek_cols][req_hdr_node_id_type]}	%{[zeek_cols][req_hdr_node_id_namespace_idx]}	%{[zeek_cols][req_hdr_node_id_numeric]}	%{[zeek_cols][req_hdr_node_id_string]}	%{[zeek_cols][req_hdr_node_id_guid]}	%{[zeek_cols][req_hdr_node_id_opaque]}	%{[zeek_cols][req_hdr_timestamp]}	%{[zeek_cols][req_hdr_request_handle]}	%{[zeek_cols][req_hdr_return_diag]}	%{[zeek_cols][req_hdr_audit_entry_id]}	%{[zeek_cols][req_hdr_timeout_hint]}	%{[zeek_cols][req_hdr_add_hdr_type_id]}	%{[zeek_cols][req_hdr_add_hdr_enc_mask]}	%{[zeek_cols][res_hdr_timestamp]}	%{[zeek_cols][res_hdr_request_handle]}	%{[zeek_cols][status_code_link_id]}	%{[zeek_cols][res_hdr_service_diag_encoding]}	%{[zeek_cols][res_hdr_add_hdr_type_id]}	%{[zeek_cols][res_hdr_add_hdr_enc_mask]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary"
          init => "$zeek_opcua_binary_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_link_id', 'msg_type', 'is_final', 'msg_size', 'error', 'reason', 'version', 'rcv_buf_size', 'snd_buf_size', 'max_msg_size', 'max_chunk_cnt', 'endpoint_url', 'sec_channel_id', 'sec_policy_uri_len', 'sec_policy_uri', 'snd_cert_len', 'snd_cert', 'rcv_cert_len', 'rcv_cert', 'seq_number', 'request_id', 'encoding_mask', 'namespace_idx', 'identifier', 'identifier_str', 'req_hdr_node_id_type', 'req_hdr_node_id_namespace_idx', 'req_hdr_node_id_numeric', 'req_hdr_node_id_string', 'req_hdr_node_id_guid', 'req_hdr_node_id_opaque', 'req_hdr_timestamp', 'req_hdr_request_handle', 'req_hdr_return_diag', 'req_hdr_audit_entry_id', 'req_hdr_timeout_hint', 'req_hdr_add_hdr_type_id', 'req_hdr_add_hdr_enc_mask', 'res_hdr_timestamp', 'res_hdr_request_handle', 'status_code_link_id', 'res_hdr_service_diag_encoding', 'res_hdr_add_hdr_type_id', 'res_hdr_add_hdr_enc_mask' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_activate_session") {
      #############################################################################################################################
      # opcua_binary_activate_session.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_activate_session"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_link_id]}	%{[zeek_cols][client_algorithm]}	%{[zeek_cols][client_signature]}	%{[zeek_cols][client_software_cert_link_id]}	%{[zeek_cols][opcua_locale_link_id]}	%{[zeek_cols][ext_obj_type_id_encoding_mask]}	%{[zeek_cols][ext_obj_type_id_namespace_idx]}	%{[zeek_cols][ext_obj_type_id_numeric]}	%{[zeek_cols][ext_obj_type_id_string]}	%{[zeek_cols][ext_obj_type_id_guid]}	%{[zeek_cols][ext_obj_type_id_opaque]}	%{[zeek_cols][ext_obj_type_id_str]}	%{[zeek_cols][ext_obj_encoding]}	%{[zeek_cols][ext_obj_policy_id]}	%{[zeek_cols][ext_obj_user_name]}	%{[zeek_cols][ext_obj_password]}	%{[zeek_cols][ext_obj_encryption_algorithom]}	%{[zeek_cols][ext_obj_certificate_data]}	%{[zeek_cols][ext_obj_token_data]}	%{[zeek_cols][user_token_algorithm]}	%{[zeek_cols][user_token_signature]}	%{[zeek_cols][server_nonce]}	%{[zeek_cols][status_code_link_id]}	%{[zeek_cols][activate_session_diag_info_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_activate_session"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_activate_session"
          init => "$zeek_opcua_binary_activate_session_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_link_id', 'client_algorithm', 'client_signature', 'client_software_cert_link_id', 'opcua_locale_link_id', 'ext_obj_type_id_encoding_mask', 'ext_obj_type_id_namespace_idx', 'ext_obj_type_id_numeric', 'ext_obj_type_id_string', 'ext_obj_type_id_guid', 'ext_obj_type_id_opaque', 'ext_obj_type_id_str', 'ext_obj_encoding', 'ext_obj_policy_id', 'ext_obj_user_name', 'ext_obj_password', 'ext_obj_encryption_algorithom', 'ext_obj_certificate_data', 'ext_obj_token_data', 'user_token_algorithm', 'user_token_signature', 'server_nonce', 'status_code_link_id', 'activate_session_diag_info_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_activate_session_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_activate_session"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_activate_session_client_software_cert") {
      #############################################################################################################################
      # opcua_binary_activate_session_client_software_cert.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_activate_session_client_software_cert"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][client_software_cert_link_id]}	%{[zeek_cols][cert_data]}	%{[zeek_cols][cert_signature]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_activate_session_client_software_cert"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_activate_session_client_software_cert"
          init => "$zeek_opcua_binary_activate_session_client_software_cert_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'client_software_cert_link_id', 'cert_data', 'cert_signature' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_activate_session_client_software_cert_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_activate_session_client_software_cert"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_activate_session_locale_id") {
      #############################################################################################################################
      # opcua_binary_activate_session_locale_id.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_activate_session_locale_id"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_locale_link_id]}	%{[zeek_cols][local_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_activate_session_locale_id"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_activate_session_locale_id"
          init => "$zeek_opcua_binary_activate_session_locale_id_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_locale_link_id', 'local_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_activate_session_locale_id_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_activate_session_locale_id"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_aggregate_filter") {
      #############################################################################################################################
      # opcua_binary_aggregate_filter.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_aggregate_filter"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][monitored_parameters_link_id]}	%{[zeek_cols][start_time]}	%{[zeek_cols][start_time_str]}	%{[zeek_cols][aggregate_type_encoding_mask]}	%{[zeek_cols][aggregate_type_namespace_idx]}	%{[zeek_cols][aggregate_type_numeric]}	%{[zeek_cols][aggregate_type_string]}	%{[zeek_cols][aggregate_type_guid]}	%{[zeek_cols][aggregate_type_opaque]}	%{[zeek_cols][processing_interval]}	%{[zeek_cols][use_server_capabilities_default]}	%{[zeek_cols][treat_uncertain_as_bad]}	%{[zeek_cols][percent_data_good]}	%{[zeek_cols][percent_data_bad]}	%{[zeek_cols][use_slopped_extrapolation]}	%{[zeek_cols][revised_start_time]}	%{[zeek_cols][revised_start_time_str]}	%{[zeek_cols][revised_processing_interval]}	%{[zeek_cols][revised_use_server_capabilities_default]}	%{[zeek_cols][revised_treat_uncertain_as_bad]}	%{[zeek_cols][revised_percent_data_good]}	%{[zeek_cols][revised_percent_data_bad]}	%{[zeek_cols][revised_use_slopped_extrapolation]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_aggregate_filter"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_aggregate_filter"
          init => "$zeek_opcua_binary_aggregate_filter_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'monitored_parameters_link_id', 'start_time', 'start_time_str', 'aggregate_type_encoding_mask', 'aggregate_type_namespace_idx', 'aggregate_type_numeric', 'aggregate_type_string', 'aggregate_type_guid', 'aggregate_type_opaque', 'processing_interval', 'use_server_capabilities_default', 'treat_uncertain_as_bad', 'percent_data_good', 'percent_data_bad', 'use_slopped_extrapolation', 'revised_start_time', 'revised_start_time_str', 'revised_processing_interval', 'revised_use_server_capabilities_default', 'revised_treat_uncertain_as_bad', 'revised_percent_data_good', 'revised_percent_data_bad', 'revised_use_slopped_extrapolation' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_aggregate_filter_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_aggregate_filter"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_event_filter_attribute_operand") {
      #############################################################################################################################
      # opcua_binary_event_filter_attribute_operand.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_event_filter_attribute_operand"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][content_filter_filter_operand_link_id]}	%{[zeek_cols][node_id_encoding_mask]}	%{[zeek_cols][node_id_namespace_idx]}	%{[zeek_cols][node_id_numeric]}	%{[zeek_cols][node_id_string]}	%{[zeek_cols][node_id_guid]}	%{[zeek_cols][node_id_opaque]}	%{[zeek_cols][alias]}	%{[zeek_cols][browse_path_element_link_id]}	%{[zeek_cols][attribute]}	%{[zeek_cols][index_range]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_event_filter_attribute_operand"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_event_filter_attribute_operand"
          init => "$zeek_opcua_binary_event_filter_attribute_operand_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'content_filter_filter_operand_link_id', 'node_id_encoding_mask', 'node_id_namespace_idx', 'node_id_numeric', 'node_id_string', 'node_id_guid', 'node_id_opaque', 'alias', 'browse_path_element_link_id', 'attribute', 'index_range' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_event_filter_attribute_operand_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_event_filter_attribute_operand"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_event_filter_attribute_operand_browse_paths") {
      #############################################################################################################################
      # opcua_binary_event_filter_attribute_operand_browse_paths.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_event_filter_attribute_operand_browse_paths"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][browse_path_element_link_id]}	%{[zeek_cols][type_id_encoding_mask]}	%{[zeek_cols][type_id_namespace_idx]}	%{[zeek_cols][type_id_numeric]}	%{[zeek_cols][type_id_string]}	%{[zeek_cols][type_id_guid]}	%{[zeek_cols][type_id_opaque]}	%{[zeek_cols][is_inverse]}	%{[zeek_cols][include_subtypes]}	%{[zeek_cols][target_name_namespace_idx]}	%{[zeek_cols][target_name]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_event_filter_attribute_operand_browse_paths"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_event_filter_attribute_operand_browse_paths"
          init => "$zeek_opcua_binary_event_filter_attribute_operand_browse_paths_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'browse_path_element_link_id', 'type_id_encoding_mask', 'type_id_namespace_idx', 'type_id_numeric', 'type_id_string', 'type_id_guid', 'type_id_opaque', 'is_inverse', 'include_subtypes', 'target_name_namespace_idx', 'target_name' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_event_filter_attribute_operand_browse_paths_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_event_filter_attribute_operand_browse_paths"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_browse") {
      #############################################################################################################################
      # opcua_binary_browse.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_browse"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_link_id]}	%{[zeek_cols][browse_service_type]}	%{[zeek_cols][browse_view_id_encoding_mask]}	%{[zeek_cols][browse_view_id_namespace_idx]}	%{[zeek_cols][browse_view_id_numeric]}	%{[zeek_cols][browse_view_id_string]}	%{[zeek_cols][browse_view_id_guid]}	%{[zeek_cols][browse_view_id_opaque]}	%{[zeek_cols][browse_view_description_timestamp]}	%{[zeek_cols][browse_view_description_view_version]}	%{[zeek_cols][req_max_ref_nodes]}	%{[zeek_cols][browse_description_link_id]}	%{[zeek_cols][browse_next_release_continuation_point]}	%{[zeek_cols][browse_next_link_id]}	%{[zeek_cols][browse_response_link_id]}	%{[zeek_cols][browse_diag_info_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_browse"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_browse"
          init => "$zeek_opcua_binary_browse_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_link_id', 'browse_service_type', 'browse_view_id_encoding_mask', 'browse_view_id_namespace_idx', 'browse_view_id_numeric', 'browse_view_id_string', 'browse_view_id_guid', 'browse_view_id_opaque', 'browse_view_description_timestamp', 'browse_view_description_view_version', 'req_max_ref_nodes', 'browse_description_link_id', 'browse_next_release_continuation_point', 'browse_next_link_id', 'browse_response_link_id', 'browse_diag_info_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_browse_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_browse"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_browse_description") {
      #############################################################################################################################
      # opcua_binary_browse_description.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_browse_description"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][browse_description_link_id]}	%{[zeek_cols][browse_description_encoding_mask]}	%{[zeek_cols][browse_description_namespace_idx]}	%{[zeek_cols][browse_description_numeric]}	%{[zeek_cols][browse_description_string]}	%{[zeek_cols][browse_description_guid]}	%{[zeek_cols][browse_description_opaque]}	%{[zeek_cols][browse_direction]}	%{[zeek_cols][browse_description_ref_encoding_mask]}	%{[zeek_cols][browse_description_ref_namespace_idx]}	%{[zeek_cols][browse_description_ref_numeric]}	%{[zeek_cols][browse_description_ref_string]}	%{[zeek_cols][browse_description_ref_guid]}	%{[zeek_cols][browse_description_ref_opaque]}	%{[zeek_cols][browse_description_include_subtypes]}	%{[zeek_cols][browse_node_class_mask]}	%{[zeek_cols][browse_result_mask]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_browse_description"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_browse_description"
          init => "$zeek_opcua_binary_browse_description_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'browse_description_link_id', 'browse_description_encoding_mask', 'browse_description_namespace_idx', 'browse_description_numeric', 'browse_description_string', 'browse_description_guid', 'browse_description_opaque', 'browse_direction', 'browse_description_ref_encoding_mask', 'browse_description_ref_namespace_idx', 'browse_description_ref_numeric', 'browse_description_ref_string', 'browse_description_ref_guid', 'browse_description_ref_opaque', 'browse_description_include_subtypes', 'browse_node_class_mask', 'browse_result_mask' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_browse_description_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_browse_description"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_browse_response_references") {
      #############################################################################################################################
      # opcua_binary_browse_response_references.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_browse_response_references"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][browse_reference_link_id]}	%{[zeek_cols][browse_response_ref_encoding_mask]}	%{[zeek_cols][browse_response_ref_namespace_idx]}	%{[zeek_cols][browse_response_ref_numeric]}	%{[zeek_cols][browse_response_ref_string]}	%{[zeek_cols][browse_response_ref_guid]}	%{[zeek_cols][browse_response_ref_opaque]}	%{[zeek_cols][browse_response_is_forward]}	%{[zeek_cols][browse_response_ref_type_encoding_mask]}	%{[zeek_cols][browse_response_ref_type_namespace_idx]}	%{[zeek_cols][browse_response_ref_type_numeric]}	%{[zeek_cols][browse_response_ref_type_string]}	%{[zeek_cols][browse_response_ref_type_guid]}	%{[zeek_cols][browse_response_ref_type_opaque]}	%{[zeek_cols][browse_response_ref_type_namespace_uri]}	%{[zeek_cols][browse_response_ref_type_server_idx]}	%{[zeek_cols][browse_response_ref_name_idx]}	%{[zeek_cols][browse_response_ref_name]}	%{[zeek_cols][browse_response_display_name_mask]}	%{[zeek_cols][browse_response_display_name_locale]}	%{[zeek_cols][browse_response_display_name_text]}	%{[zeek_cols][browse_response_node_class]}	%{[zeek_cols][browse_response_type_def_encoding_mask]}	%{[zeek_cols][browse_response_type_def_namespace_idx]}	%{[zeek_cols][browse_response_type_def_numeric]}	%{[zeek_cols][browse_response_type_def_string]}	%{[zeek_cols][browse_response_type_def_guid]}	%{[zeek_cols][browse_response_type_def_opaque]}	%{[zeek_cols][browse_response_type_def_namespace_uri]}	%{[zeek_cols][browse_response_type_def_server_idx]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_browse_response_references"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_browse_response_references"
          init => "$zeek_opcua_binary_browse_response_references_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'browse_reference_link_id', 'browse_response_ref_encoding_mask', 'browse_response_ref_namespace_idx', 'browse_response_ref_numeric', 'browse_response_ref_string', 'browse_response_ref_guid', 'browse_response_ref_opaque', 'browse_response_is_forward', 'browse_response_ref_type_encoding_mask', 'browse_response_ref_type_namespace_idx', 'browse_response_ref_type_numeric', 'browse_response_ref_type_string', 'browse_response_ref_type_guid', 'browse_response_ref_type_opaque', 'browse_response_ref_type_namespace_uri', 'browse_response_ref_type_server_idx', 'browse_response_ref_name_idx', 'browse_response_ref_name', 'browse_response_display_name_mask', 'browse_response_display_name_locale', 'browse_response_display_name_text', 'browse_response_node_class', 'browse_response_type_def_encoding_mask', 'browse_response_type_def_namespace_idx', 'browse_response_type_def_numeric', 'browse_response_type_def_string', 'browse_response_type_def_guid', 'browse_response_type_def_opaque', 'browse_response_type_def_namespace_uri', 'browse_response_type_def_server_idx' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_browse_response_references_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_browse_response_references"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_browse_request_continuation_point") {
      #############################################################################################################################
      # opcua_binary_browse_request_continuation_point.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_browse_request_continuation_point"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][browse_next_link_id]}	%{[zeek_cols][continuation_point]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_browse_request_continuation_point"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_browse_request_continuation_point"
          init => "$zeek_opcua_binary_browse_request_continuation_point_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'browse_next_link_id', 'continuation_point' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_browse_request_continuation_point_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_browse_request_continuation_point"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_browse_result") {
      #############################################################################################################################
      # opcua_binary_browse_result.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_browse_result"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][browse_response_link_id]}	%{[zeek_cols][status_code_link_id]}	%{[zeek_cols][browse_result_continuation_point]}	%{[zeek_cols][browse_reference_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_browse_result"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_browse_result"
          init => "$zeek_opcua_binary_browse_result_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'browse_response_link_id', 'status_code_link_id', 'browse_result_continuation_point', 'browse_reference_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_browse_result_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_browse_result"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_close_session") {
      #############################################################################################################################
      # opcua_binary_close_session.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_close_session"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_link_id]}	%{[zeek_cols][del_subscriptions]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_close_session"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_close_session"
          init => "$zeek_opcua_binary_close_session_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_link_id', 'del_subscriptions' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_close_session_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_close_session"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_event_filter_where_clause") {
      #############################################################################################################################
      # opcua_binary_event_filter_where_clause.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_event_filter_where_clause"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][where_clause_link_id]}	%{[zeek_cols][content_filter_element_link_id]}	%{[zeek_cols][content_filter_status_code_link_id]}	%{[zeek_cols][content_filter_diag_info_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_event_filter_where_clause"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_event_filter_where_clause"
          init => "$zeek_opcua_binary_event_filter_where_clause_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'where_clause_link_id', 'content_filter_element_link_id', 'content_filter_status_code_link_id', 'content_filter_diag_info_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_event_filter_where_clause_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_event_filter_where_clause"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_event_filter_where_clause_elements") {
      #############################################################################################################################
      # opcua_binary_event_filter_where_clause_elements.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_event_filter_where_clause_elements"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][content_filter_element_link_id]}	%{[zeek_cols][filter_operator]}	%{[zeek_cols][content_filter_filter_operand_type_id_node_id_encoding_mask]}	%{[zeek_cols][content_filter_filter_operand_type_id_node_id_namespace_idx]}	%{[zeek_cols][content_filter_filter_operand_type_id_node_id_numeric]}	%{[zeek_cols][content_filter_filter_operand_type_id_node_id_string]}	%{[zeek_cols][content_filter_filter_operand_type_id_node_id_guid]}	%{[zeek_cols][content_filter_filter_operand_type_id_node_id_opaque]}	%{[zeek_cols][content_filter_filter_operand_type_id_string]}	%{[zeek_cols][content_filter_filter_operand_type_id_encoding]}	%{[zeek_cols][content_filter_filter_operand_link_id]}	%{[zeek_cols][content_filter_operand_status_code_link_id]}	%{[zeek_cols][content_filter_operand_diag_info_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_event_filter_where_clause_elements"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_event_filter_where_clause_elements"
          init => "$zeek_opcua_binary_event_filter_where_clause_elements_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'content_filter_element_link_id', 'filter_operator', 'content_filter_filter_operand_type_id_node_id_encoding_mask', 'content_filter_filter_operand_type_id_node_id_namespace_idx', 'content_filter_filter_operand_type_id_node_id_numeric', 'content_filter_filter_operand_type_id_node_id_string', 'content_filter_filter_operand_type_id_node_id_guid', 'content_filter_filter_operand_type_id_node_id_opaque', 'content_filter_filter_operand_type_id_string', 'content_filter_filter_operand_type_id_encoding', 'content_filter_filter_operand_link_id', 'content_filter_operand_status_code_link_id', 'content_filter_operand_diag_info_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_event_filter_where_clause_elements_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_event_filter_where_clause_elements"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_create_monitored_items") {
      #############################################################################################################################
      # opcua_binary_create_monitored_items.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_create_monitored_items"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_link_id]}	%{[zeek_cols][subscription_id]}	%{[zeek_cols][timestamps_to_return]}	%{[zeek_cols][timestamps_to_return_str]}	%{[zeek_cols][create_item_link_id]}	%{[zeek_cols][create_monitored_items_diag_info_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_create_monitored_items"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_create_monitored_items"
          init => "$zeek_opcua_binary_create_monitored_items_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_link_id', 'subscription_id', 'timestamps_to_return', 'timestamps_to_return_str', 'create_item_link_id', 'create_monitored_items_diag_info_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_create_monitored_items_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_create_monitored_items"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_create_monitored_items_create_item") {
      #############################################################################################################################
      # opcua_binary_create_monitored_items_create_item.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_create_monitored_items_create_item"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][create_item_link_id]}	%{[zeek_cols][item_to_monitor_node_id_encoding_mask]}	%{[zeek_cols][item_to_monitor_node_id_namespace_idx]}	%{[zeek_cols][item_to_monitor_node_id_numeric]}	%{[zeek_cols][item_to_monitor_node_id_string]}	%{[zeek_cols][item_to_monitor_node_id_guid]}	%{[zeek_cols][item_to_monitor_node_id_opaque]}	%{[zeek_cols][item_to_monitor_attribute_id]}	%{[zeek_cols][item_to_monitor_index_range]}	%{[zeek_cols][item_to_monitor_namespace_idx]}	%{[zeek_cols][item_to_monitor_name]}	%{[zeek_cols][monitoring_mode]}	%{[zeek_cols][monitoring_parameters_client_handle]}	%{[zeek_cols][monitoring_parameters_sampling_interval]}	%{[zeek_cols][monitoring_parameters_queue_size]}	%{[zeek_cols][monitoring_parameters_discard_oldest]}	%{[zeek_cols][monitoring_parameters_filter_info_type_id_node_id_encoding_mask]}	%{[zeek_cols][monitoring_parameters_filter_info_type_id_node_id_namespace_idx]}	%{[zeek_cols][monitoring_parameters_filter_info_type_id_node_id_numeric]}	%{[zeek_cols][monitoring_parameters_filter_info_type_id_node_id_string]}	%{[zeek_cols][monitoring_parameters_filter_info_type_id_node_id_guid]}	%{[zeek_cols][monitoring_parameters_filter_info_type_id_node_id_opaque]}	%{[zeek_cols][monitoring_parameters_filter_info_type_id_string]}	%{[zeek_cols][monitoring_parameters_filter_info_type_id_encoding]}	%{[zeek_cols][filter_info_details_link_id]}	%{[zeek_cols][monitoring_parameters_status_code_link_id]}	%{[zeek_cols][monitored_item_index_id]}	%{[zeek_cols][monitoring_parameters_revised_sampling_interval]}	%{[zeek_cols][monitoring_parameters_revised_queue_size]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_create_monitored_items_create_item"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_create_monitored_items_create_item"
          init => "$zeek_opcua_binary_create_monitored_items_create_item_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'create_item_link_id', 'item_to_monitor_node_id_encoding_mask', 'item_to_monitor_node_id_namespace_idx', 'item_to_monitor_node_id_numeric', 'item_to_monitor_node_id_string', 'item_to_monitor_node_id_guid', 'item_to_monitor_node_id_opaque', 'item_to_monitor_attribute_id', 'item_to_monitor_index_range', 'item_to_monitor_namespace_idx', 'item_to_monitor_name', 'monitoring_mode', 'monitoring_parameters_client_handle', 'monitoring_parameters_sampling_interval', 'monitoring_parameters_queue_size', 'monitoring_parameters_discard_oldest', 'monitoring_parameters_filter_info_type_id_node_id_encoding_mask', 'monitoring_parameters_filter_info_type_id_node_id_namespace_idx', 'monitoring_parameters_filter_info_type_id_node_id_numeric', 'monitoring_parameters_filter_info_type_id_node_id_string', 'monitoring_parameters_filter_info_type_id_node_id_guid', 'monitoring_parameters_filter_info_type_id_node_id_opaque', 'monitoring_parameters_filter_info_type_id_string', 'monitoring_parameters_filter_info_type_id_encoding', 'filter_info_details_link_id', 'monitoring_parameters_status_code_link_id', 'monitored_item_index_id', 'monitoring_parameters_revised_sampling_interval', 'monitoring_parameters_revised_queue_size' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_create_monitored_items_create_item_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_create_monitored_items_create_item"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_create_session") {
      #############################################################################################################################
      # opcua_binary_create_session.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_create_session"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_link_id]}	%{[zeek_cols][application_uri]}	%{[zeek_cols][product_uri]}	%{[zeek_cols][encoding_mask]}	%{[zeek_cols][locale]}	%{[zeek_cols][text]}	%{[zeek_cols][application_type]}	%{[zeek_cols][gateway_server_uri]}	%{[zeek_cols][discovery_profile_uri]}	%{[zeek_cols][discovery_profile_link_id]}	%{[zeek_cols][server_uri]}	%{[zeek_cols][endpoint_url]}	%{[zeek_cols][session_name]}	%{[zeek_cols][client_nonce]}	%{[zeek_cols][client_cert_size]}	%{[zeek_cols][client_cert]}	%{[zeek_cols][req_session_timeout]}	%{[zeek_cols][max_res_msg_size]}	%{[zeek_cols][session_id_encoding_mask]}	%{[zeek_cols][session_id_namespace_idx]}	%{[zeek_cols][session_id_numeric]}	%{[zeek_cols][session_id_string]}	%{[zeek_cols][session_id_guid]}	%{[zeek_cols][session_id_opaque]}	%{[zeek_cols][auth_token_encoding_mask]}	%{[zeek_cols][auth_token_namespace_idx]}	%{[zeek_cols][auth_token_numeric]}	%{[zeek_cols][auth_token_string]}	%{[zeek_cols][auth_token_guid]}	%{[zeek_cols][auth_token_opaque]}	%{[zeek_cols][revised_session_timeout]}	%{[zeek_cols][server_nonce]}	%{[zeek_cols][server_cert_size]}	%{[zeek_cols][server_cert]}	%{[zeek_cols][endpoint_link_id]}	%{[zeek_cols][algorithm]}	%{[zeek_cols][signature]}	%{[zeek_cols][max_req_msg_size]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_create_session"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_create_session"
          init => "$zeek_opcua_binary_create_session_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_link_id', 'application_uri', 'product_uri', 'encoding_mask', 'locale', 'text', 'application_type', 'gateway_server_uri', 'discovery_profile_uri', 'discovery_profile_link_id', 'server_uri', 'endpoint_url', 'session_name', 'client_nonce', 'client_cert_size', 'client_cert', 'req_session_timeout', 'max_res_msg_size', 'session_id_encoding_mask', 'session_id_namespace_idx', 'session_id_numeric', 'session_id_string', 'session_id_guid', 'session_id_opaque', 'auth_token_encoding_mask', 'auth_token_namespace_idx', 'auth_token_numeric', 'auth_token_string', 'auth_token_guid', 'auth_token_opaque', 'revised_session_timeout', 'server_nonce', 'server_cert_size', 'server_cert', 'endpoint_link_id', 'algorithm', 'signature', 'max_req_msg_size' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_create_session_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_create_session"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_create_session_discovery") {
      #############################################################################################################################
      # opcua_binary_create_session_discovery.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_create_session_discovery"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][discovery_profile_link_id]}	%{[zeek_cols][discovery_profile_uri]}	%{[zeek_cols][discovery_profile_url]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_create_session_discovery"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_create_session_discovery"
          init => "$zeek_opcua_binary_create_session_discovery_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'discovery_profile_link_id', 'discovery_profile_uri', 'discovery_profile_url' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_create_session_discovery_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_create_session_discovery"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_create_session_endpoints") {
      #############################################################################################################################
      # opcua_binary_create_session_endpoints.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_create_session_endpoints"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][endpoint_link_id]}	%{[zeek_cols][endpoint_url]}	%{[zeek_cols][application_uri]}	%{[zeek_cols][product_uri]}	%{[zeek_cols][encoding_mask]}	%{[zeek_cols][locale]}	%{[zeek_cols][text]}	%{[zeek_cols][application_type]}	%{[zeek_cols][gateway_server_uri]}	%{[zeek_cols][discovery_profile_uri]}	%{[zeek_cols][discovery_profile_link_id]}	%{[zeek_cols][cert_size]}	%{[zeek_cols][server_cert]}	%{[zeek_cols][message_security_mode]}	%{[zeek_cols][security_policy_uri]}	%{[zeek_cols][user_token_link_id]}	%{[zeek_cols][transport_profile_uri]}	%{[zeek_cols][security_level]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_create_session_endpoints"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_create_session_endpoints"
          init => "$zeek_opcua_binary_create_session_endpoints_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'endpoint_link_id', 'endpoint_url', 'application_uri', 'product_uri', 'encoding_mask', 'locale', 'text', 'application_type', 'gateway_server_uri', 'discovery_profile_uri', 'discovery_profile_link_id', 'cert_size', 'server_cert', 'message_security_mode', 'security_policy_uri', 'user_token_link_id', 'transport_profile_uri', 'security_level' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_create_session_endpoints_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_create_session_endpoints"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_create_session_user_token") {
      #############################################################################################################################
      # opcua_binary_create_session_user_token.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_create_session_user_token"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user_token_link_id]}	%{[zeek_cols][user_token_policy_id]}	%{[zeek_cols][user_token_type]}	%{[zeek_cols][user_token_issued_type]}	%{[zeek_cols][user_token_endpoint_url]}	%{[zeek_cols][user_token_sec_policy_uri]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_create_session_user_token"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_create_session_user_token"
          init => "$zeek_opcua_binary_create_session_user_token_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user_token_link_id', 'user_token_policy_id', 'user_token_type', 'user_token_issued_type', 'user_token_endpoint_url', 'user_token_sec_policy_uri' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_create_session_user_token_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_create_session_user_token"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_create_subscription") {
      #############################################################################################################################
      # opcua_binary_create_subscription.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_create_subscription"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_link_id]}	%{[zeek_cols][requested_publishing_interval]}	%{[zeek_cols][requested_lifetime_count]}	%{[zeek_cols][requested_max_keep_alive_count]}	%{[zeek_cols][max_notifications_per_publish]}	%{[zeek_cols][publishing_enabled]}	%{[zeek_cols][priority]}	%{[zeek_cols][subscription_id]}	%{[zeek_cols][revised_publishing_interval]}	%{[zeek_cols][revised_lifetime_count]}	%{[zeek_cols][revised_max_keep_alive_count]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_create_subscription"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_create_subscription"
          init => "$zeek_opcua_binary_create_subscription_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_link_id', 'requested_publishing_interval', 'requested_lifetime_count', 'requested_max_keep_alive_count', 'max_notifications_per_publish', 'publishing_enabled', 'priority', 'subscription_id', 'revised_publishing_interval', 'revised_lifetime_count', 'revised_max_keep_alive_count' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_create_subscription_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_create_subscription"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_data_change_filter") {
      #############################################################################################################################
      # opcua_binary_data_change_filter.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_data_change_filter"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][monitored_parameters_link_id]}	%{[zeek_cols][trigger]}	%{[zeek_cols][deadband_type]}	%{[zeek_cols][deadband_value]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_data_change_filter"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_data_change_filter"
          init => "$zeek_opcua_binary_data_change_filter_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'monitored_parameters_link_id', 'trigger', 'deadband_type', 'deadband_value' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_data_change_filter_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_data_change_filter"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_diag_info_detail") {
      #############################################################################################################################
      # opcua_binary_diag_info_detail.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_diag_info_detail"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][diag_info_link_id]}	%{[zeek_cols][root_object_id]}	%{[zeek_cols][source]}	%{[zeek_cols][source_str]}	%{[zeek_cols][inner_diag_level]}	%{[zeek_cols][has_symbolic_id]}	%{[zeek_cols][symbolic_id]}	%{[zeek_cols][symbolic_id_str]}	%{[zeek_cols][has_namespace_uri]}	%{[zeek_cols][namespace_uri]}	%{[zeek_cols][namespace_uri_str]}	%{[zeek_cols][has_locale]}	%{[zeek_cols][locale]}	%{[zeek_cols][locale_str]}	%{[zeek_cols][has_locale_txt]}	%{[zeek_cols][locale_txt]}	%{[zeek_cols][locale_txt_str]}	%{[zeek_cols][has_addl_info]}	%{[zeek_cols][addl_info]}	%{[zeek_cols][has_inner_stat_code]}	%{[zeek_cols][inner_stat_code]}	%{[zeek_cols][has_inner_diag_info]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_diag_info_detail"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_diag_info_detail"
          init => "$zeek_opcua_binary_diag_info_detail_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'diag_info_link_id', 'root_object_id', 'source', 'source_str', 'inner_diag_level', 'has_symbolic_id', 'symbolic_id', 'symbolic_id_str', 'has_namespace_uri', 'namespace_uri', 'namespace_uri_str', 'has_locale', 'locale', 'locale_str', 'has_locale_txt', 'locale_txt', 'locale_txt_str', 'has_addl_info', 'addl_info', 'has_inner_stat_code', 'inner_stat_code', 'has_inner_diag_info' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_diag_info_detail_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_diag_info_detail"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_event_filter_element_operand") {
      #############################################################################################################################
      # opcua_binary_event_filter_element_operand.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_event_filter_element_operand"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][content_filter_filter_operand_link_id]}	%{[zeek_cols][element_index]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_event_filter_element_operand"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_event_filter_element_operand"
          init => "$zeek_opcua_binary_event_filter_element_operand_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'content_filter_filter_operand_link_id', 'element_index' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_event_filter_element_operand_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_event_filter_element_operand"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_event_filter") {
      #############################################################################################################################
      # opcua_binary_event_filter.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_event_filter"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][monitored_parameters_link_id]}	%{[zeek_cols][select_clause_link_id]}	%{[zeek_cols][where_clause_content_filter_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_event_filter"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_event_filter"
          init => "$zeek_opcua_binary_event_filter_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'monitored_parameters_link_id', 'select_clause_link_id', 'where_clause_content_filter_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_event_filter_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_event_filter"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_get_endpoints") {
      #############################################################################################################################
      # opcua_binary_get_endpoints.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_get_endpoints"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_link_id]}	%{[zeek_cols][endpoint_url]}	%{[zeek_cols][locale_link_id]}	%{[zeek_cols][profile_uri_link_id]}	%{[zeek_cols][endpoint_description_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_get_endpoints"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_get_endpoints"
          init => "$zeek_opcua_binary_get_endpoints_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_link_id', 'endpoint_url', 'locale_link_id', 'profile_uri_link_id', 'endpoint_description_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_get_endpoints_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_get_endpoints"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_get_endpoints_description") {
      #############################################################################################################################
      # opcua_binary_get_endpoints_description.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_get_endpoints_description"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][endpoint_description_link_id]}	%{[zeek_cols][endpoint_uri]}	%{[zeek_cols][application_uri]}	%{[zeek_cols][product_uri]}	%{[zeek_cols][encoding_mask]}	%{[zeek_cols][locale]}	%{[zeek_cols][text]}	%{[zeek_cols][application_type]}	%{[zeek_cols][gateway_server_uri]}	%{[zeek_cols][discovery_profile_uri]}	%{[zeek_cols][discovery_profile_link_id]}	%{[zeek_cols][cert_size]}	%{[zeek_cols][server_cert]}	%{[zeek_cols][message_security_mode]}	%{[zeek_cols][security_policy_uri]}	%{[zeek_cols][user_token_link_id]}	%{[zeek_cols][transport_profile_uri]}	%{[zeek_cols][security_level]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_get_endpoints_description"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_get_endpoints_description"
          init => "$zeek_opcua_binary_get_endpoints_description_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'endpoint_description_link_id', 'endpoint_uri', 'application_uri', 'product_uri', 'encoding_mask', 'locale', 'text', 'application_type', 'gateway_server_uri', 'discovery_profile_uri', 'discovery_profile_link_id', 'cert_size', 'server_cert', 'message_security_mode', 'security_policy_uri', 'user_token_link_id', 'transport_profile_uri', 'security_level' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_get_endpoints_description_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_get_endpoints_description"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_get_endpoints_discovery") {
      #############################################################################################################################
      # opcua_binary_get_endpoints_discovery.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_get_endpoints_discovery"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][discovery_profile_link_id]}	%{[zeek_cols][discovery_profile_url]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_get_endpoints_discovery"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_get_endpoints_discovery"
          init => "$zeek_opcua_binary_get_endpoints_discovery_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'discovery_profile_link_id', 'discovery_profile_url' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_get_endpoints_discovery_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_get_endpoints_discovery"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_get_endpoints_locale_id") {
      #############################################################################################################################
      # opcua_binary_get_endpoints_locale_id.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_get_endpoints_locale_id"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][locale_link_id]}	%{[zeek_cols][locale_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_get_endpoints_locale_id"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_get_endpoints_locale_id"
          init => "$zeek_opcua_binary_get_endpoints_locale_id_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'locale_link_id', 'locale_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_get_endpoints_locale_id_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_get_endpoints_locale_id"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_get_endpoints_profile_uri") {
      #############################################################################################################################
      # opcua_binary_get_endpoints_profile_uri.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_get_endpoints_profile_uri"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][profile_uri_link_id]}	%{[zeek_cols][profile_uri]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_get_endpoints_profile_uri"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_get_endpoints_profile_uri"
          init => "$zeek_opcua_binary_get_endpoints_profile_uri_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'profile_uri_link_id', 'profile_uri' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_get_endpoints_profile_uri_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_get_endpoints_profile_uri"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_get_endpoints_user_token") {
      #############################################################################################################################
      # opcua_binary_get_endpoints_user_token.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_get_endpoints_user_token"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user_token_link_id]}	%{[zeek_cols][user_token_policy_id]}	%{[zeek_cols][user_token_type]}	%{[zeek_cols][user_token_issued_type]}	%{[zeek_cols][user_token_endpoint_url]}	%{[zeek_cols][user_token_sec_policy_uri]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_get_endpoints_user_token"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_get_endpoints_user_token"
          init => "$zeek_opcua_binary_get_endpoints_user_token_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user_token_link_id', 'user_token_policy_id', 'user_token_type', 'user_token_issued_type', 'user_token_endpoint_url', 'user_token_sec_policy_uri' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_get_endpoints_user_token_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_get_endpoints_user_token"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_event_filter_literal_operand") {
      #############################################################################################################################
      # opcua_binary_event_filter_literal_operand.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_event_filter_literal_operand"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][content_filter_filter_operand_link_id]}	%{[zeek_cols][literal_operand_variant_link]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_event_filter_literal_operand"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_event_filter_literal_operand"
          init => "$zeek_opcua_binary_event_filter_literal_operand_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'content_filter_filter_operand_link_id', 'literal_operand_variant_link' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_event_filter_literal_operand_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_event_filter_literal_operand"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_opensecure_channel") {
      #############################################################################################################################
      # opcua_binary_opensecure_channel.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_opensecure_channel"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_link_id]}	%{[zeek_cols][client_proto_ver]}	%{[zeek_cols][sec_token_request_type]}	%{[zeek_cols][message_security_mode]}	%{[zeek_cols][client_nonce]}	%{[zeek_cols][req_lifetime]}	%{[zeek_cols][server_proto_ver]}	%{[zeek_cols][sec_token_sec_channel_id]}	%{[zeek_cols][sec_token_id]}	%{[zeek_cols][sec_token_created_at]}	%{[zeek_cols][sec_token_revised_time]}	%{[zeek_cols][server_nonce]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_opensecure_channel"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_opensecure_channel"
          init => "$zeek_opcua_binary_opensecure_channel_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_link_id', 'client_proto_ver', 'sec_token_request_type', 'message_security_mode', 'client_nonce', 'req_lifetime', 'server_proto_ver', 'sec_token_sec_channel_id', 'sec_token_id', 'sec_token_created_at', 'sec_token_revised_time', 'server_nonce' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_opensecure_channel_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_opensecure_channel"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_read") {
      #############################################################################################################################
      # opcua_binary_read.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_read"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_link_id]}	%{[zeek_cols][max_age]}	%{[zeek_cols][timestamps_to_return]}	%{[zeek_cols][timestamps_to_return_str]}	%{[zeek_cols][nodes_to_read_link_id]}	%{[zeek_cols][read_results_link_id]}	%{[zeek_cols][diag_info_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_read"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_read"
          init => "$zeek_opcua_binary_read_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_link_id', 'max_age', 'timestamps_to_return', 'timestamps_to_return_str', 'nodes_to_read_link_id', 'read_results_link_id', 'diag_info_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_read_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_read"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_read_nodes_to_read") {
      #############################################################################################################################
      # opcua_binary_read_nodes_to_read.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_read_nodes_to_read"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][nodes_to_read_link_id]}	%{[zeek_cols][node_id_encoding_mask]}	%{[zeek_cols][node_id_namespace_idx]}	%{[zeek_cols][node_id_numeric]}	%{[zeek_cols][node_id_string]}	%{[zeek_cols][node_id_guid]}	%{[zeek_cols][node_id_opaque]}	%{[zeek_cols][attribute_id]}	%{[zeek_cols][attribute_id_str]}	%{[zeek_cols][index_range]}	%{[zeek_cols][data_encoding_name_idx]}	%{[zeek_cols][data_encoding_name]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_read_nodes_to_read"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_read_nodes_to_read"
          init => "$zeek_opcua_binary_read_nodes_to_read_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'nodes_to_read_link_id', 'node_id_encoding_mask', 'node_id_namespace_idx', 'node_id_numeric', 'node_id_string', 'node_id_guid', 'node_id_opaque', 'attribute_id', 'attribute_id_str', 'index_range', 'data_encoding_name_idx', 'data_encoding_name' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_read_nodes_to_read_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_read_nodes_to_read"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_read_results") {
      #############################################################################################################################
      # opcua_binary_read_results.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_read_results"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][results_link_id]}	%{[zeek_cols][level]}	%{[zeek_cols][data_value_encoding_mask]}	%{[zeek_cols][status_code_link_id]}	%{[zeek_cols][source_timestamp]}	%{[zeek_cols][source_pico_sec]}	%{[zeek_cols][server_timestamp]}	%{[zeek_cols][server_pico_sec]}	%{[zeek_cols][read_results_variant_metadata_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_read_results"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_read_results"
          init => "$zeek_opcua_binary_read_results_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'results_link_id', 'level', 'data_value_encoding_mask', 'status_code_link_id', 'source_timestamp', 'source_pico_sec', 'server_timestamp', 'server_pico_sec', 'read_results_variant_metadata_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_read_results_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_read_results"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_event_filter_select_clause") {
      #############################################################################################################################
      # opcua_binary_event_filter_select_clause.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_event_filter_select_clause"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][select_clause_link_id]}	%{[zeek_cols][type_id_encoding_mask]}	%{[zeek_cols][type_id_namespace_idx]}	%{[zeek_cols][type_id_numeric]}	%{[zeek_cols][type_id_string]}	%{[zeek_cols][type_id_guid]}	%{[zeek_cols][type_id_opaque]}	%{[zeek_cols][simple_attribute_operand_browse_path_link_id]}	%{[zeek_cols][attribute_id]}	%{[zeek_cols][index_range]}	%{[zeek_cols][select_clause_status_code_link_id]}	%{[zeek_cols][select_clause_diagnostic_info_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_event_filter_select_clause"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_event_filter_select_clause"
          init => "$zeek_opcua_binary_event_filter_select_clause_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'select_clause_link_id', 'type_id_encoding_mask', 'type_id_namespace_idx', 'type_id_numeric', 'type_id_string', 'type_id_guid', 'type_id_opaque', 'simple_attribute_operand_browse_path_link_id', 'attribute_id', 'index_range', 'select_clause_status_code_link_id', 'select_clause_diagnostic_info_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_event_filter_select_clause_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_event_filter_select_clause"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_event_filter_simple_attribute_operand") {
      #############################################################################################################################
      # opcua_binary_event_filter_simple_attribute_operand.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_event_filter_simple_attribute_operand"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][content_filter_filter_operand_link_id]}	%{[zeek_cols][type_id_encoding_mask]}	%{[zeek_cols][type_id_namespace_idx]}	%{[zeek_cols][type_id_numeric]}	%{[zeek_cols][type_id_string]}	%{[zeek_cols][type_id_guid]}	%{[zeek_cols][type_id_opaque]}	%{[zeek_cols][simple_attribute_operand_browse_path_link_id]}	%{[zeek_cols][attribute_id]}	%{[zeek_cols][index_range]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_event_filter_simple_attribute_operand"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_event_filter_simple_attribute_operand"
          init => "$zeek_opcua_binary_event_filter_simple_attribute_operand_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'content_filter_filter_operand_link_id', 'type_id_encoding_mask', 'type_id_namespace_idx', 'type_id_numeric', 'type_id_string', 'type_id_guid', 'type_id_opaque', 'simple_attribute_operand_browse_path_link_id', 'attribute_id', 'index_range' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_event_filter_simple_attribute_operand_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_event_filter_simple_attribute_operand"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_event_filter_simple_attribute_operand_browse_paths") {
      #############################################################################################################################
      # opcua_binary_event_filter_simple_attribute_operand_browse_paths.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_event_filter_simple_attribute_operand_browse_paths"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][simple_attribute_operand_browse_path_link_id]}	%{[zeek_cols][browse_path_src]}	%{[zeek_cols][namespace_index]}	%{[zeek_cols][name]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_event_filter_simple_attribute_operand_browse_paths"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_event_filter_simple_attribute_operand_browse_paths"
          init => "$zeek_opcua_binary_event_filter_simple_attribute_operand_browse_paths_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'simple_attribute_operand_browse_path_link_id', 'browse_path_src', 'namespace_index', 'name' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_event_filter_simple_attribute_operand_browse_paths_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_event_filter_simple_attribute_operand_browse_paths"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_status_code_detail") {
      #############################################################################################################################
      # opcua_binary_status_code_detail.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_status_code_detail"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][status_code_link_id]}	%{[zeek_cols][source]}	%{[zeek_cols][source_str]}	%{[zeek_cols][source_level]}	%{[zeek_cols][status_code]}	%{[zeek_cols][severity]}	%{[zeek_cols][severity_str]}	%{[zeek_cols][sub_code]}	%{[zeek_cols][sub_code_str]}	%{[zeek_cols][structure_changed]}	%{[zeek_cols][semantics_changed]}	%{[zeek_cols][info_type]}	%{[zeek_cols][info_type_str]}	%{[zeek_cols][limit_bits]}	%{[zeek_cols][limit_bits_str]}	%{[zeek_cols][overflow]}	%{[zeek_cols][historian_bits]}	%{[zeek_cols][historian_bits_str]}	%{[zeek_cols][historianpartial]}	%{[zeek_cols][historianextradata]}	%{[zeek_cols][historianmultivalue]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_status_code_detail"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_status_code_detail"
          init => "$zeek_opcua_binary_status_code_detail_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'status_code_link_id', 'source', 'source_str', 'source_level', 'status_code', 'severity', 'severity_str', 'sub_code', 'sub_code_str', 'structure_changed', 'semantics_changed', 'info_type', 'info_type_str', 'limit_bits', 'limit_bits_str', 'overflow', 'historian_bits', 'historian_bits_str', 'historianpartial', 'historianextradata', 'historianmultivalue' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_status_code_detail_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_status_code_detail"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_variant_array_dims") {
      #############################################################################################################################
      # opcua_binary_variant_array_dims.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_variant_array_dims"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][array_dim_link_id]}	%{[zeek_cols][dimension]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_variant_array_dims"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_variant_array_dims"
          init => "$zeek_opcua_binary_variant_array_dims_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'array_dim_link_id', 'dimension' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_variant_array_dims_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_variant_array_dims"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_variant_data") {
      #############################################################################################################################
      # opcua_binary_variant_data.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_variant_data"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][variant_data_link_id]}	%{[zeek_cols][variant_data_value_signed_numeric]}	%{[zeek_cols][variant_data_value_unsigned_numeric]}	%{[zeek_cols][variant_data_value_string]}	%{[zeek_cols][variant_data_node_id_encoding_mask]}	%{[zeek_cols][variant_data_node_id_namespace_idx]}	%{[zeek_cols][variant_data_node_id_numeric]}	%{[zeek_cols][variant_data_node_id_string]}	%{[zeek_cols][variant_data_node_id_guid]}	%{[zeek_cols][variant_data_node_id_opaque]}	%{[zeek_cols][variant_data_node_id_namespace_uri]}	%{[zeek_cols][variant_data_node_id_server_idx]}	%{[zeek_cols][variant_data_value_time]}	%{[zeek_cols][variant_data_encoding_name_idx]}	%{[zeek_cols][variant_data_encoding_name]}	%{[zeek_cols][variant_data_mask]}	%{[zeek_cols][variant_data_locale]}	%{[zeek_cols][variant_data_text]}	%{[zeek_cols][variant_data_value_decimal]}	%{[zeek_cols][variant_data_status_code_link_id]}	%{[zeek_cols][variant_data_diag_info_link_id]}	%{[zeek_cols][variant_data_ext_obj_link_id]}	%{[zeek_cols][variant_metadata_data_link_id]}	%{[zeek_cols][variant_data_value_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_variant_data"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_variant_data"
          init => "$zeek_opcua_binary_variant_data_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'variant_data_link_id', 'variant_data_value_signed_numeric', 'variant_data_value_unsigned_numeric', 'variant_data_value_string', 'variant_data_node_id_encoding_mask', 'variant_data_node_id_namespace_idx', 'variant_data_node_id_numeric', 'variant_data_node_id_string', 'variant_data_node_id_guid', 'variant_data_node_id_opaque', 'variant_data_node_id_namespace_uri', 'variant_data_node_id_server_idx', 'variant_data_value_time', 'variant_data_encoding_name_idx', 'variant_data_encoding_name', 'variant_data_mask', 'variant_data_locale', 'variant_data_text', 'variant_data_value_decimal', 'variant_data_status_code_link_id', 'variant_data_diag_info_link_id', 'variant_data_ext_obj_link_id', 'variant_metadata_data_link_id', 'variant_data_value_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_variant_data_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_variant_data"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_variant_data_value") {
      #############################################################################################################################
      # opcua_binary_variant_data_value.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_variant_data_value"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][variant_data_value_source_link]}	%{[zeek_cols][data_value_encoding_mask]}	%{[zeek_cols][status_code_link_id]}	%{[zeek_cols][source_timestamp]}	%{[zeek_cols][source_pico_sec]}	%{[zeek_cols][server_timestamp]}	%{[zeek_cols][server_pico_sec]}	%{[zeek_cols][variant_metadata_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_variant_data_value"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_variant_data_value"
          init => "$zeek_opcua_binary_variant_data_value_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'variant_data_value_source_link', 'data_value_encoding_mask', 'status_code_link_id', 'source_timestamp', 'source_pico_sec', 'server_timestamp', 'server_pico_sec', 'variant_metadata_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_variant_data_value_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_variant_data_value"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_variant_extension_object") {
      #############################################################################################################################
      # opcua_binary_variant_extension_object.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_variant_extension_object"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][ext_obj_link_id]}	%{[zeek_cols][ext_obj_node_id_encoding_mask]}	%{[zeek_cols][ext_obj_node_id_namespace_idx]}	%{[zeek_cols][ext_obj_node_id_numeric]}	%{[zeek_cols][ext_obj_node_id_string]}	%{[zeek_cols][ext_obj_node_id_guid]}	%{[zeek_cols][ext_obj_node_id_opaque]}	%{[zeek_cols][ext_obj_type_id_str]}	%{[zeek_cols][ext_obj_encoding]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_variant_extension_object"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_variant_extension_object"
          init => "$zeek_opcua_binary_variant_extension_object_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'ext_obj_link_id', 'ext_obj_node_id_encoding_mask', 'ext_obj_node_id_namespace_idx', 'ext_obj_node_id_numeric', 'ext_obj_node_id_string', 'ext_obj_node_id_guid', 'ext_obj_node_id_opaque', 'ext_obj_type_id_str', 'ext_obj_encoding' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_variant_extension_object_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_variant_extension_object"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else if ([log_source] == "opcua_binary_variant_metadata") {
      #############################################################################################################################
      # opcua_binary_variant_metadata.log
      # variant-types.zeek (https://github.com/cisagov/icsnpp-opcua-binary)

      dissect {
        id => "dissect_zeek_opcua_binary_variant_metadata"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        mapping => {
          "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][variant_source_data_link_id]}	%{[zeek_cols][variant_data_source]}	%{[zeek_cols][variant_data_source_str]}	%{[zeek_cols][dara_variant_encoding_mask]}	%{[zeek_cols][data_variant_data_type]}	%{[zeek_cols][data_variant_data_type_str]}	%{[zeek_cols][built_in_data_type]}	%{[zeek_cols][built_in_data_type_str]}	%{[zeek_cols][variant_data_link_id]}	%{[zeek_cols][variant_data_array_dim]}	%{[zeek_cols][variant_data_array_multi_dim_link_id]}"
        }
      }

      if ("_dissectfailure" in [tags]) {
        mutate {
          id => "mutate_split_zeek_opcua_binary_variant_metadata"
          # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
          split => { "[message]" => "	" }
        }
        ruby {
          id => "ruby_zip_zeek_opcua_binary_variant_metadata"
          init => "$zeek_opcua_binary_variant_metadata_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'variant_source_data_link_id', 'variant_data_source', 'variant_data_source_str', 'dara_variant_encoding_mask', 'data_variant_data_type', 'data_variant_data_type_str', 'built_in_data_type', 'built_in_data_type_str', 'variant_data_link_id', 'variant_data_array_dim', 'variant_data_array_multi_dim_link_id' ]"
          code => "event.set('[zeek_cols]', $zeek_opcua_binary_variant_metadata_field_names.zip(event.get('[message]')).to_h)"
        }
      }

      mutate {
        id => "mutate_add_fields_zeek_opcua_binary_variant_metadata"
        add_field => {
          "[zeek_cols][proto]" => "tcp"
          "[zeek_cols][service]" => "opcua-binary"
        }
        add_tag => [ "ics" ]
      }

    } else {
      # some other unknown zeek opcua- log file. should start with ts at least!
      csv {
        id => "csv_zeek_unknown_opcua"
        columns => ["ts"]

        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        separator => "	"
        # there's no way to *disable* the csv quote char, so set it to something we'll never see
        quote_char => ""

        target => "[zeek_cols]"
      }

      mutate { id => "mutate_add_tag_zeek_unknown_opcua"
               add_field => {
                 "[zeek_cols][proto]" => "tcp"
                 "[zeek_cols][service]" => "opcua-binary"
               }
               add_tag => [ "_unknown_log_type" ]
      }

    } # if / else if for opcua log types

  } else {
    # some other unknown zeek log file. should start with ts at least!
    csv {
      id => "csv_zeek_unknown"
      columns => ["ts"]

      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      separator => "	"
      # there's no way to *disable* the csv quote char, so set it to something we'll never see
      quote_char => ""

      target => "[zeek_cols]"
    }

    mutate { id => "mutate_add_tag_zeek_unknown"
             add_tag => [ "_unknown_log_type" ] }

  } # if / else if for source type (conn.log, dns.log, etc.)

} # end Filter
