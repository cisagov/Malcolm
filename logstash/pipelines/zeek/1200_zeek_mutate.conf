# Copyright (c) 2025 Battelle Energy Alliance, LLC.  All rights reserved.

filter {

  if ([zeek_cols]) {
    # remove unset (-) or "(empty)" top-level field values
    ruby {
      id => "ruby_zeek_remove_empty_values"
      path => "/usr/share/logstash/malcolm-ruby/compact_event.rb"
    }
  } else {
    drop { id => "drop_dissect_error" }
  }

  # ECS - "zeek" -> event.provider
  if (![event][provider]) { mutate { id => "mutate_add_field_event_provider_zeek"
                                     add_field => { "[event][provider]" => "zeek" } } }

  if (![host][name]) and ([agent][hostname]) {
    mutate { id => "mutate_zeek_add_field_host_name_agent_hostname"
             add_field => { "[host][name]" => "%{[agent][hostname]}" } }
  }

  # rename the zeek child array to match the log type
  mutate { id => "mutate_rename_zeek_log_type"
           rename => { "[zeek_cols]" => "[zeek][%{[log_source]}]" } }

  # move "up" some fields that are considered to be "multi-log" fields (eg., they
  # show up in many types of logs)
  mutate {
    id => "mutate_rename_zeek_common_fields"
    rename => { "[zeek][%{[log_source]}][ts]"              => "[zeek][ts]" }
    rename => { "[zeek][%{[log_source]}][uid]"             => "[zeek][uid]" }
    rename => { "[zeek][%{[log_source]}][fuid]"            => "[zeek][fuid]" }
    rename => { "[zeek][%{[log_source]}][is_orig]"         => "[network][is_orig]" }
    rename => { "[zeek][%{[log_source]}][orig_h]"          => "[source][ip]" }
    rename => { "[zeek][%{[log_source]}][orig_p]"          => "[source][port]" }
    rename => { "[zeek][%{[log_source]}][orig_l2_addr]"    => "[source][mac]" }
    rename => { "[zeek][%{[log_source]}][resp_h]"          => "[destination][ip]" }
    rename => { "[zeek][%{[log_source]}][resp_p]"          => "[destination][port]" }
    rename => { "[zeek][%{[log_source]}][resp_l2_addr]"    => "[destination][mac]" }
    rename => { "[zeek][%{[log_source]}][proto]"           => "[network][transport]" }
    rename => { "[zeek][%{[log_source]}][service]"         => "[network][protocol]" }
    rename => { "[zeek][%{[log_source]}][user]"            => "[related][user]" }
    rename => { "[zeek][%{[log_source]}][password]"        => "[related][password]" }
    rename => { "[zeek][%{[log_source]}][community_id]"    => "[network][community_id]" }
  }

  # we'll just save the "true" source and destination fields.
  #   see, for example, https://github.com/cisagov/icsnpp-bacnet#source-and-destination-fields
  mutate { id => "mutate_remove_zeek_common_fields"
           remove_field => [
            "[zeek][%{[log_source]}][drop_orig_h]",
            "[zeek][%{[log_source]}][drop_orig_p]",
            "[zeek][%{[log_source]}][drop_resp_h]",
            "[zeek][%{[log_source]}][drop_resp_p]" ] }

  if ("_jsonparsesuccess" not in [tags]) {
    mutate { id => "mutate_split_zeek_commas_post_parse"
             split => { "[source][mac]" => ","
                        "[destination][mac]" => ","
                        "[zeek][fuid]" => ","
                        "[related][user]" => ","
                        "[network][protocol]" => "," } }
  }

  if ([zeek][uid]) {
    # set zeek connection UID as "rootId" (see logstash.conf output section)
    if (![rootId]) { mutate { id => "mutate_add_field_zeek_rootId"
                              add_field => { "[rootId]" => "%{[zeek][uid]}" } } }

    # ECS - zeek.uid -> event.id
    mutate { id => "mutate_add_field_ecs_id_uid"
             merge => { "[event][id]" => "[zeek][uid]" } }
  }

  if ([zeek][ts]) {

    if ([zeek][ts] == "0.000000") {
      # missing packet timestamp, set to "now." not sure what a better option would be
      ruby {
        id => "ruby_zeek_empty_timestamp_set"
        init => "require 'time'"
        code => "event.set('[zeek][ts]', Time.now.to_f)"
      }
      mutate { id => "tag_zeek_empty_timestamp_set"
               add_tag => [ "_missing_timestamp" ] }
    }

    # set firstPacket to timestamp, lastPacket to timestamp + duration
    # timestamp, firstPacket, lastPacket are UNIX epoch milliseconds
    ruby {
      id => "ruby_zeek_timestamp_calc"
      init => "require 'time'"
      code => "msTime = (1000*event.get('[zeek][ts]').to_f).round(0)
               event.set('[timestamp]', msTime)
               event.set('[@timestamp]', LogStash::Timestamp.at(Time.strptime(msTime.to_s, '%Q')))
               event.set('[firstPacket]', msTime)"
    }

    if ([zeek][conn]) and ([zeek][conn][duration]) {
      # convert duration (floating-point seconds) to milliseconds
      ruby {
        id => "ruby_zeek_duration_calc"
        code => "event.set('[length]', (1000*event.get('[zeek][conn][duration]').to_f).round(0))
                 event.set('[lastPacket]', event.get('[timestamp]').to_i + event.get('[length]').to_i)"
      }
      # ECS - zeek.conn.duration -> event.duration
      ruby {
        id => "ruby_zeek_duration_to_ecs_event_duration"
        code => "event.set('[event][duration]', (1000000000 * event.get('[zeek][conn][duration]').to_f).round(0))"
      }
    } else {
      mutate { id => "mutate_add_field_zeek_lastPacket"
               add_field => { "[lastPacket]" => "%{timestamp}" } }
      mutate { id => "mutate_add_field_zeek_length"
               add_field => { "[length]" => "0" } }
    }

    # set the ts back as something more readable
    mutate { id => "mutate_replace_zeek_ts"
             replace => { "[zeek][ts]" => "%{[@timestamp]}" } }
  } # if ([zeek][ts])

  # set user and transport- and application-level protocols if specified
  if ([network][transport]) {
    if (![ipProtocol]) {
      translate {
        id => "translate_zeek_proto"
        source => "[network][transport]"
        target => "[ipProtocol]"
        dictionary_path => "/etc/ip_protocol_name_to_number.yaml"
      }
    }
    if ("_jsonparsesuccess" not in [tags]) {
      mutate { id => "mutate_split_zeek_proto"
               split => { "[network][transport]" => "," } }
    }
    mutate { id => "mutate_merge_zeek_proto"
             merge => { "[protocol]" => "[network][transport]" } }
  }

  if ([log_source] == "conn") {
    #############################################################################################################################
    # conn.log specific logic

    translate {
      id => "translate_zeek_conn_state"
      source => "[zeek][conn][conn_state]"
      target => "[zeek][conn][conn_state_description]"
      dictionary_path => "/etc/conn_states.yaml"
      # TODO: can we normalize this with suricata.flow.state somewhere?
    }

    if ([zeek][conn][vlan] or [zeek][conn][inner_vlan]) {
      # ECS - zeek.conn.vlan -> network.vlan.id
      if ([zeek][conn][vlan]) {
        mutate { id => "mutate_merge_zeek_conn_vlan"
                 merge => { "[network][vlan][id]" => "[zeek][conn][vlan]" } }
      }
      if ([zeek][conn][inner_vlan]) {
        # ECS - zeek.conn.inner_vlan -> network.inner.vlan.id
        mutate { id => "mutate_merge_zeek_conn_inner_vlan"
                 merge => { "[network][inner][vlan][id]" => "[zeek][conn][inner_vlan]" } }
      }
    }

    # rename conn.log's TCP JA4 fields to what Arkime uses
    if ([zeek][conn][ja4l]) {
      mutate { id => "mutate_merge_zeek_tcp_ja4l"
               merge => { "[tcp][ja4l]" => "[zeek][conn][ja4l]" } }
    }

    if ([zeek][conn][ja4ls]) {
      mutate { id => "mutate_merge_zeek_tcp_ja4ls"
               merge => { "[tcp][ja4ls]" => "[zeek][conn][ja4ls]" } }
    }

    if ([zeek][conn][ja4t]) {
      mutate { id => "mutate_merge_zeek_tcp_ja4t"
               merge => { "[tcp][ja4t]" => "[zeek][conn][ja4t]" } }
    }

    if ([zeek][conn][ja4ts]) {
      mutate { id => "mutate_merge_zeek_tcp_ja4ts"
               merge => { "[tcp][ja4ts]" => "[zeek][conn][ja4ts]" } }
    }

    # aggregate total bytes and packets
    ruby {
      id => "ruby_zeek_bytes_and_packets_calc"
      code => "event.set('[totDataBytes]', event.get('[client][bytes]').to_i + event.get('[server][bytes]').to_i)
               event.set('[network][bytes]', event.get('[source][bytes]').to_i + event.get('[destination][bytes]').to_i)
               event.set('[network][packets]', event.get('[source][packets]').to_i + event.get('[destination][packets]').to_i)"
    }

    if ([zeek][conn][history]) {
      ruby {
        id => "ruby_zeek_conn_history"
        # see https://www.zeek.org/sphinx/scripts/base/protocols/conn/main.bro.html#type-Conn::Info
        code => "historyStr = event.get('[zeek][conn][history]').upcase
                 sCnt = [historyStr.count('S'), 19].min
                 hCnt = [historyStr.count('H'), 19].min
                 aCnt = [historyStr.count('A'), 19].min
                 fCnt = [historyStr.count('F'), 19].min
                 rCnt = [historyStr.count('R'), 19].min
                 event.set('[tcpflags][syn]',     10**(sCnt-1)) if sCnt > 0
                 event.set('[tcpflags][syn-ack]', 10**(hCnt-1)) if hCnt > 0
                 event.set('[tcpflags][ack]',     10**(aCnt-1)) if aCnt > 0
                 event.set('[tcpflags][fin]',     10**(fCnt-1)) if fCnt > 0
                 event.set('[tcpflags][rst]',     10**(rCnt-1)) if rCnt > 0"
      }
    }

  } else if ([log_source] =~ /^bacnet/) {

    if ([log_source] == "bacnet_discovery") {
      #############################################################################################################################
      # bacnet_discovery.log specific logic

      # bacnet_discovery.range can be split into a min/max (All, 12345-12350, etc.)
      if ([zeek][bacnet_discovery][range]) {
        if ([zeek][bacnet_discovery][range] == "All") {
          mutate { id => "mutate_add_field_zeek_bacnet_discovery_range_low"
                   add_field => { "[zeek][bacnet_discovery][range_low]" => "0" } }
          mutate { id => "mutate_add_field_zeek_bacnet_discovery_range_high"
                   add_field => { "[zeek][bacnet_discovery][range_high]" => "4194300" } }
        } else if ([zeek][bacnet_discovery][range] =~ /^\d+-\d+$/) {
          ruby {
            id => "ruby_bacnet_discovery_range_split"
            code => "
              if (bacnetRange = event.get('[zeek][bacnet_discovery][range]').split('-')) and (bacnetRange.length == 2) then
                event.set('[zeek][bacnet_discovery][range_low]', bacnetRange[0])
                event.set('[zeek][bacnet_discovery][range_high]', bacnetRange[1])
              end"
          }
        }
      }
    }

    mutate {
      id => "mutate_rename_bacnet_fields"
      rename => { "[zeek][bacnet_device_control][invoke_id]" => "[zeek][bacnet][invoke_id]" }
      rename => { "[zeek][bacnet_property][invoke_id]" => "[zeek][bacnet][invoke_id]" }
      rename => { "[zeek][bacnet_discovery][instance_number]" => "[zeek][bacnet][instance_number]" }
      rename => { "[zeek][bacnet_property][instance_number]" => "[zeek][bacnet][instance_number]" }
      rename => { "[zeek][bacnet_device_control][pdu_service]" => "[zeek][bacnet][pdu_service]" }
      rename => { "[zeek][bacnet_discovery][pdu_service]" => "[zeek][bacnet][pdu_service]" }
      rename => { "[zeek][bacnet_property][pdu_service]" => "[zeek][bacnet][pdu_service]" }
    }

  } else if ([log_source] == "bsap_ip_rdb") {
    #############################################################################################################################
    # bsap_ip_rdb.log specific logic

    ruby {
      id => "ruby_bsap_ip_rdb_variables"
      init => "@bsap_ip_rdb_fields = [ :var, :val ]"
      code => "
        vars = event.get('[zeek][bsap_ip_rdb][variables]')
        values = event.get('[zeek][bsap_ip_rdb][variable_value]')
        if !vars.is_a?(Array) then
          vars = vars.to_s.split(',')
        end
        if !values.is_a?(Array) then
          values = values.to_s.split(',')
        end
        vars = vars.zip(values).map{ |x| @bsap_ip_rdb_fields.zip(x).to_h }
        event.set('[zeek][bsap_ip_rdb][variables]', vars)
        event.set('[zeek][bsap_ip_rdb][variable_count]', vars.length)
      "
    }
    mutate { id => "mutate_remove_field_zeek_bsap_ip_rdb_variable_value"
             remove_field => [ "[zeek][bsap_ip_rdb][variable_value]",
                               "[zeek][bsap_ip_rdb][data_len]" ] }


  } else if ([log_source] == "bsap_serial_rdb") {
    #############################################################################################################################
    # bsap_serial_rdb.log specific logic

    ruby {
      id => "ruby_bsap_serial_rdb_variables"
      init => "@bsap_serial_rdb_fields = [ :var, :val ]"
      code => "
        vars = event.get('[zeek][bsap_serial_rdb][variables]')
        values = event.get('[zeek][bsap_serial_rdb][variable_value]')
        if !vars.is_a?(Array) then
          vars = vars.to_s.split(',')
        end
        if !values.is_a?(Array) then
          values = values.to_s.split(',')
        end
        vars = vars.zip(values).map{ |x| @bsap_serial_rdb_fields.zip(x).to_h }
        event.set('[zeek][bsap_serial_rdb][variables]', vars)
        event.set('[zeek][bsap_serial_rdb][variable_count]', vars.length)
      "
    }
    mutate { id => "mutate_remove_field_zeek_bsap_serial_rdb_variable_value"
             remove_field => [ "[zeek][bsap_serial_rdb][variable_value]",
                               "[zeek][bsap_serial_rdb][data_len]" ] }

  } else if ([log_source] =~ /^c1222/) {

    #############################################################################################################################
    # c1222_*.log specific logic

    mutate {
      id => "mutate_rename_c1222_linkage_fields"
      rename => { "[zeek][c1222][services]" => "[zeek][c1222][epsem_service]" }
      rename => { "[zeek][c1222_dereg_reg_service][ap_title]" => "[zeek][c1222][ap_title]" }
      rename => { "[zeek][c1222_dereg_reg_service][req_resp]" => "[zeek][c1222][req_resp]" }
      rename => { "[zeek][c1222_dereg_reg_service][service_type]" => "[zeek][c1222][epsem_service]" }
      rename => { "[zeek][c1222_identification_service][req_resp]" => "[zeek][c1222][req_resp]" }
      rename => { "[zeek][c1222_logon_security_service][req_resp]" => "[zeek][c1222][req_resp]" }
      rename => { "[zeek][c1222_logon_security_service][service_type]" => "[zeek][c1222][epsem_service]" }
      rename => { "[zeek][c1222_read_write_service][req_resp]" => "[zeek][c1222][req_resp]" }
      rename => { "[zeek][c1222_read_write_service][service_type]" => "[zeek][c1222][epsem_service]" }
      rename => { "[zeek][c1222_resolve_service][ap_title]" => "[zeek][c1222][ap_title]" }
      rename => { "[zeek][c1222_resolve_service][req_resp]" => "[zeek][c1222][req_resp]" }
      rename => { "[zeek][c1222_service_error][epsem_service]" => "[zeek][c1222][epsem_service]" }
      rename => { "[zeek][c1222_trace_service][ap_titles]" => "[zeek][c1222][ap_title]" }
      rename => { "[zeek][c1222_trace_service][req_resp]" => "[zeek][c1222][req_resp]" }
      rename => { "[zeek][c1222_user_information][services]" => "[zeek][c1222][epsem_service]" }
      rename => { "[zeek][c1222_wait_service][req_resp]" => "[zeek][c1222][req_resp]" }
    }

  } else if ([log_source] == "cip_io") {
    #############################################################################################################################
    # cip_io.log specific logic

    if ([zeek][cip_io][packet_correlation_id]) {
      mutate {
        id => "mutate_rename_cip_io_packet_correlation_id"
        rename => { "[zeek][cip_io][packet_correlation_id]" => "[zeek][cip][packet_correlation_id]" }
      }
    }

  } else if ([log_source] == "cip_identity") {
    #############################################################################################################################
    # cip_identity.log specific logic

    if ([zeek][cip_identity][packet_correlation_id]) {
      mutate {
        id => "mutate_rename_cip_identity_packet_correlation_id"
        rename => { "[zeek][cip_identity][packet_correlation_id]" => "[zeek][cip][packet_correlation_id]" }
      }
    }

    if ([zeek][cip_identity][socket_address]) {

      # if this is a zeek_cip_identity record with socket_address, ASN/GeoIP it as well
      geoip {
        id => "geoip_zeek_cip_identity_socket_address"
        default_database_type => "ASN"
        source => "[zeek][cip_identity][socket_address]"
        target => "[@metadata][zeek_cip_identity_asn]"
      }
      if ([@metadata][zeek_cip_identity_asn] and [@metadata][zeek_cip_identity_asn][as_org] and [@metadata][zeek_cip_identity_asn][asn]) {
        # this is stupid, the %{} doesn't seem to be liked by mutate.merge
        mutate { id => "mutate_add_field_zeek_cip_identity_asn"
                 add_field => { "[@metadata][cip_asn_str]" => "AS%{[@metadata][zeek_cip_identity_asn][asn]} %{[@metadata][zeek_cip_identity_asn][as_org]}" } }
        mutate { id => "mutate_merge_zeek_cip_identity_asn"
                 merge => { "[zeek][cip_identity][socket_address_asn]" => "[@metadata][cip_asn_str]" } }
      }
      geoip {
        id => "geoip_zeek_cip_identity_socket_address_geo"
        source => "[zeek][cip_identity][socket_address]"
        target => "[zeek][cip_identity][socket_address_geo]"
      }

    }

  } else if ([log_source] == "dhcp") {
    #############################################################################################################################
    # dhcp.log specific logic

    if ([source][mac]) {
      mutate {
        id => "mutate_add_fields_zeek_dhcp_mac"
        add_field =>  { "[zeek][dhcp][mac]" => "%{[source][mac]}" }
      }
      mutate { id => "mutate_merge_zeek_dhcp_mac"
               merge => { "[dhcp][mac]" => "[source][mac]" } }
    }

    if ([zeek][dhcp][msg_types]) {
      ruby {
        id => "ruby_zeek_dhcp_msg_types"
        path => "/usr/share/logstash/malcolm-ruby/make_unique_array.rb"
        script_params => {
          "field" => "[zeek][dhcp][msg_types]"
        }
      }
      mutate { id => "mutate_merge_zeek_dhcp_type"
               merge => { "[dhcp][type]" => "[zeek][dhcp][msg_types]" } }
    }

    if ([zeek][dhcp][trans_id]) {
      mutate { id => "mutate_merge_zeek_dhcp_id"
               merge => { "[dhcp][id]" => "[zeek][dhcp][trans_id]" } }
    }

    if ([zeek][dhcp][host_name]) {
      mutate { id => "mutate_merge_zeek_dhcp_host_name"
               merge => { "[dhcp][host]" => "[zeek][dhcp][host_name]" } }

      # ECS - zeek.dhcp.host_name -> client.domain
      mutate { id => "mutate_add_field_ecs_client_domain_dhcp_host_name"
               add_field => { "[client][domain]" => "%{[zeek][dhcp][host_name]}" } }
    }

    if ([zeek][dhcp][domain]) {
      # ECS - zeek.dhcp.domain -> client.domain
      mutate { id => "mutate_add_field_ecs_client_domain_dhcp_domain"
               add_field => { "[client][domain]" => "%{[zeek][dhcp][domain]}" } }
    }

    if ([zeek][dhcp][client_fqdn]) {
      # ECS - zeek.dhcp.client_fqdn -> client.domain
      mutate { id => "mutate_add_field_ecs_client_domain_dhcp_client_fqdn"
               add_field => { "[client][domain]" => "%{[zeek][dhcp][client_fqdn]}" } }
    }

    if ([zeek][dhcp][assigned_ip]) {
      mutate { id => "mutate_merge_zeek_dhcp_host"
               merge => { "[dhcp][host]" => "[zeek][dhcp][assigned_ip]" } }
    }

  } else if ([log_source] == "dnp3") {
    #############################################################################################################################
    # dnp3.log specific logic

    # translate IIN bitmap (least significant bit = zeek_dnp3_iin_flags[0], etc.)
    # reference: https://raw.githubusercontent.com/wireshark/wireshark/master/epan/dissectors/packet-dnp.c (search IIN)
    ruby {
      id => "ruby_parse_dnp3_iin"
      init => "@zeek_dnp3_iin_flags = [ 'Function Code not Implemented', 'Requested Objects Unknown', 'Parameters Invalid or Out of Range', 'Event Buffer Overflow', 'Operation Already Executing', 'Configuration Corrupt', 'Reserved', 'Reserved', 'Broadcast Msg Rx', 'Class 1 Data Available', 'Class 2 Data Available', 'Class 3 Data Available', 'Time Sync Required', 'Digital Outputs in Local', 'Device Trouble', 'Device Restart' ]"
      code => "
        iinNum = event.get('[zeek][dnp3][iin]').to_i
        if (iinNum > 0) then
          iinFlags = Array.new
          @zeek_dnp3_iin_flags.each_with_index do |val, idx|
            iinFlags.push(val) if (iinNum[idx] == 1)
          end
          event.set('[zeek][dnp3][iin_flags]', iinFlags)
        end"
    }

  } else if ([log_source] == "dns") {
    #############################################################################################################################
    # dns.log specific logic
    #
    # NOTE: I discovered that there are some conflicts between ECS's DNS fields
    #   (https://www.elastic.co/guide/en/ecs/current/ecs-dns.html) and Arkime's
    #   (https://github.com/arkime/arkime/blob/70765f46f6e17b62e405d9cd82d8109030e51bd8/db/db.pl#L4369-L4431)
    #   that would result in some issues when opening Arkime sessions with DNS records
    #   (see https://github.com/cisagov/malcolm/issues/509). So I'm commenting-out some of the ECS DNS
    #   normalization here in favor of the Arkime fields.

    # this must be done because [dns][ip] only handles IPv4 or IPv6 addresses
    # but [answers] can contain hostnames as well
    if ([zeek][dns][answers]) {
      ruby {
        id => "ruby_zeek_dns_answers_ip_extract"
        # todo: adjust this regex so it at least sort of catches IPv6 as well
        code => "
          answers = event.get('[zeek][dns][answers]')
          if answers.is_a?(Array) then
            answers = answers.join(',')
          end
          event.set('[@metadata][answers_ip]', answers.scan(/\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/))
        "
      }
      # ECS - zeek.dns -> dns.answers
      # ruby {
      #   id => "ruby_zeek_dns_answers_to_ecs"
      #   code => '
      #     event.set("[dns][answers]", [Array(event.get("[zeek][dns][answers]")), Array(event.get("[zeek][dns][TTLs]"))].transpose.map{ |d| Hash[[:data, :ttl].zip(d)] })
      # '}
      mutate { id => "mutate_add_field_ecs_dns_type_answer"
               add_field => { "[dns][type]" => "answer" } }
    }

    if ([zeek][dns][query]) {
      mutate { id => "mutate_merge_zeek_query"
               merge => { "[dns][host]" => "[zeek][dns][query]" } }
      ruby { id => "ruby_add_field_zeek_dns_opcode"
             code => "event.set('[dns][opcode]', [ 'QUERY', event.get('[dns][opcode]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
    }

    if ([@metadata][answers_ip]) {
      mutate { id => "mutate_merge_zeek_dns_ip"
               merge => { "[dns][ip]" => "[@metadata][answers_ip]" } }
      # ECS  dns.ip -> dns.resolved_ip
      mutate { id => "mutate_merge_ecs_dhs_resolved_ip"
               merge => { "[dns][resolved_ip]" => "[dns][ip]" } }
    }

    if ([zeek][dns][qclass_name]) {
      mutate { id => "mutate_merge_zeek_dns_qc"
               merge => { "[dns][qc]" => "[zeek][dns][qclass_name]" } }
    }

    if ([zeek][dns][qtype_name]) {
      mutate { id => "mutate_merge_zeek_dns_qt"
               merge => { "[dns][qt]" => "[zeek][dns][qtype_name]" } }
    }

    # dns.op_code
   if ([dns][opcode]) {                          mutate { id => "mutate_add_field_ecs_dns_opcode"
                                                          add_field => { "[dns][op_code]" => "%{[dns][opcode]}" } } }

    # dns.question.class
    if ([zeek][dns][qclass_name]) {                mutate { id => "mutate_add_field_ecs_dns_qclass"
                                                           add_field => { "[dns][question][class]" => "%{[zeek][dns][qclass_name]}" } } }

    # dns.question.type
    # if ([zeek][dns][qtype_name]) {                 mutate { id => "mutate_add_field_ecs_dns_qtype"
    #                                                         add_field => { "[dns][question][type]" => "%{[zeek][dns][qtype_name]}" } } }

    # dns.question.name and dns.type:query
    if ([zeek][dns][query]) {
      # mutate { id => "mutate_add_field_ecs_dns_query"
      #          add_field => { "[dns][question][name]" => "%{[zeek][dns][query]}" } }
      if (![dns][type]) { mutate { id => "mutate_add_field_ecs_dns_type_query"
                                   add_field => { "[dns][type]" => "query" } } }
    }

    if ([dns][type]) {
      # dns.header_flags
      if ([zeek][AA] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_aa"
                                                           add_field => { "[dns][header_flags]" => "AA" } } }
      if ([zeek][TC] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_tc"
                                                           add_field => { "[dns][header_flags]" => "TC" } } }
      if ([zeek][RD] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_rd"
                                                           add_field => { "[dns][header_flags]" => "RD" } } }
      if ([zeek][RA] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_ra"
                                                           add_field => { "[dns][header_flags]" => "RA" } } }
    }

    # dns.response_code
    # if ([zeek][dns][rcode_name]) {                mutate { id => "mutate_add_field_ecs_dns_response_code"
    #                                                        add_field => { "[dns][response_code]" => "%{[zeek][dns][rcode_name]}" } } }

    # dns.id
    # if ([zeek][dns][trans_id]) {                   mutate { id => "mutate_add_field_ecs_dns_id"
    #                                                         add_field => { "[dns][id]" => "%{[zeek][dns][trans_id]}" } } }

    # TODO: domain stuff (dns.question.registered_domain, dns.question.subdomain, dns.question.top_level_domain)
    # perhaps use something like https://github.com/plutonbacon/logstash-filter-publicsuffix

  } else if ([log_source] == "enip") {
    #############################################################################################################################
    # enip.log specific logic

    if ([zeek][enip][packet_correlation_id]) {
      mutate {
        id => "mutate_rename_enip_packet_correlation_id"
        rename => { "[zeek][enip][packet_correlation_id]" => "[zeek][cip][packet_correlation_id]" }
      }
    }

  } else if ([log_source] == "files") {
    #############################################################################################################################
    # files.log specific logic

    # translate Zeek's double-backslashes single backslash in filenames
    ruby {
      id => "ruby_zeek_files_filename_dedoubleslash"
      path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
      script_params => {
        "source" => "[zeek][files][filename]"
        "target" => "[zeek][files][filename]"
      }
    }

    if ([zeek][files][total_bytes]) {
      ruby {
        id => "ruby_zeek_files_totBytes"
        code => "event.set('[network][bytes]', event.get('[zeek][files][total_bytes]').to_i)"
      }
    }
    if ([zeek][files][seen_bytes]) {
      ruby {
        id => "ruby_zeek_files_totDataBytes"
        code => "event.set('[totDataBytes]', event.get('[zeek][files][seen_bytes]').to_i)"
      }
    }

    if ([zeek][files][source]) {

      # do some normalization on files source
      mutate { id => "mutate_gsub_field_zeek_files_source_spicy_suffix"
               gsub => [ "[zeek][files][source]", "_(TCP|UDP|DATA)$", "" ] }
      mutate { id => "mutate_gsub_field_zeek_files_source_spicy_prefix"
               gsub => [ "[zeek][files][source]", "^SPICY_", "" ] }

      if ([zeek][files][source] =~ /^XOR decrypted from /) {
        # PE_XOR plugin writes source as "XOR decrypted from FM7Tr545kxt3ofR7x2-"..., let's
        # standardize that to just "XOR decrypted" and put the source fuid in parent_fuid
        grok {
          id => "grok_zeek_files_source_xor"
          match => { "[zeek][files][source]" => [ "decrypted%{SPACE}from%{SPACE}%{WORD:[@metadata][source_xor_fuid]}" ] }
        }
        if ([@metadata][source_xor_fuid]) { mutate { id => "mutate_merge_zeek_files_source_xor_parent_fuid"
                                                     merge => { "[zeek][files][parent_fuid]" => "[@metadata][source_xor_fuid]" } } }
        mutate { id => "mutate_replace_zeek_files_source_xor"
                 replace => { "[zeek][files][source]" => "XOR decrypted" } }

      } else if ([zeek][files][source] == "SSL") {
        # SSL->TLS to match up with what the service field has for cross-referencing
        mutate { id => "mutate_replace_zeek_files_source_ssl_to_tls"
                 replace => { "[zeek][files][source]" => "TLS" } }
      }
    }

    # ECS - "file" -> file.type
    mutate { id => "mutate_add_field_ecs_file_type"
             add_field => { "[file][type]" => "file" } }

    # ECS -> zeek_files.total_bytes -> file.size
    if ([zeek][files][total_bytes]) {  mutate { id => "mutate_add_field_ecs_files_size"
                                      add_field => { "[file][size]" => "%{[zeek][files][total_bytes]}" } } }

    # ECS -> zeek_files.(md5|sha1|sha256) -> file.hash.(md5|sha1|sha256)
    if ([zeek][files][md5]) {          mutate { id => "mutate_add_field_ecs_files_hash_md5"
                                      add_field => { "[file][hash][md5]" => "%{[zeek][files][md5]}" } } }
    if ([zeek][files][sha1]) {         mutate { id => "mutate_add_field_ecs_files_hash_sha1"
                                      add_field => { "[file][hash][sha1]" => "%{[zeek][files][sha1]}" } } }
    if ([zeek][files][sha256]) {       mutate { id => "mutate_add_field_ecs_files_hash_sha256"
                                      add_field => { "[file][hash][sha256]" => "%{[zeek][files][sha256]}" } } }

    if ([zeek][files][extracted]) {
      ruby {
        id => "ruby_zeek_files_extracted_uri_build"
        code => "
          uri = nil
          if (fName = event.get('[zeek][files][extracted]')) then
            if (tags = event.get('[tags]')) && tags.include?('_filebeat_zeek_hedgehog') then
              if (hName = event.get('[host][name]')) then
                uri = 'hh-extracted-files/' + hName + '/' + fName
              end
            else
              uri = 'extracted-files/' + fName
            end
          end
          event.set('[zeek][files][extracted_uri]', uri) unless uri.to_s.empty?
        "
      }
    }

  } else if ([log_source] == "ftp") {
    #############################################################################################################################
    # ftp.log specific logic

    if ([zeek][ftp][file_size]) {
      ruby {
        id => "ruby_zeek_ftp_totDataBytes"
        code => "event.set('[totDataBytes]', event.get('[zeek][ftp][file_size]').to_i)"
      }
    }

  } else if ([log_source] == "ge_srtp") {
    #############################################################################################################################
    # ge_srtp_general.log specific logic

    if ([zeek][ge_srtp][io_fault_entry_last_read]) {
      translate {
        id => "translate_zeek_ge_srtp_io_fault_entry_last_read"
        source => "[zeek][ge_srtp][io_fault_entry_last_read]"
        target => "[zeek][ge_srtp][io_fault_entry_last_read]"
        dictionary => {
          "I/O fault table has changed since last read by this device" => true
          "I/O fault table unchanged since last read" => false
        }
      }
    }

    if ([zeek][ge_srtp][io_fault_entry_present]) {
      translate {
        id => "translate_zeek_ge_srtp_io_fault_entry_present"
        source => "[zeek][ge_srtp][io_fault_entry_present]"
        target => "[zeek][ge_srtp][io_fault_entry_present]"
        dictionary => {
          "One or more fault entries in I/O fault table" => true
          "I/O fault table is empty" => false
        }
      }
    }

    if ([zeek][ge_srtp][front_panel_run_switch]) {
      translate {
        id => "translate_zeek_ge_srtp_front_panel_run_switch"
        source => "[zeek][ge_srtp][front_panel_run_switch]"
        target => "[zeek][ge_srtp][front_panel_run_switch]"
        dictionary => {
          "RUN" => true
          "STOP" => false
        }
      }
    }

    if ([zeek][ge_srtp][constant_sweep_mode]) {
      translate {
        id => "translate_zeek_ge_srtp_constant_sweep_mode"
        source => "[zeek][ge_srtp][constant_sweep_mode]"
        target => "[zeek][ge_srtp][constant_sweep_mode]"
        dictionary => {
        "Constant sweep mode active" => true
        "Constant sweep mode is not active" => false
        }
      }
    }

    if ([zeek][ge_srtp][oem_protected]) {
      translate {
        id => "translate_zeek_ge_srtp_oem_protected"
        source => "[zeek][ge_srtp][oem_protected]"
        target => "[zeek][ge_srtp][oem_protected]"
        dictionary => {
          "OEM protection in effect" => true
          "No OEM protection" => false
        }
      }
    }

    if ([zeek][ge_srtp][oversweep_flag]) {
      translate {
        id => "translate_zeek_ge_srtp_oversweep_flag"
        source => "[zeek][ge_srtp][oversweep_flag]"
        target => "[zeek][ge_srtp][oversweep_flag]"
        dictionary => {
          "Constant sweep value exceeded" => true
          "No oversweep condition exists" => false
        }
      }
    }

    if ([zeek][ge_srtp][front_panel_enable_switch]) {
      translate {
        id => "translate_zeek_ge_srtp_front_panel_enable_switch"
        source => "[zeek][ge_srtp][front_panel_enable_switch]"
        target => "[zeek][ge_srtp][front_panel_enable_switch]"
        dictionary => {
          "Outputs disabled" => false
          "Outputs enabled" => true
        }
      }
    }

    if ([zeek][ge_srtp][plc_fault_entry_present]) {
      translate {
        id => "translate_zeek_ge_srtp_plc_fault_entry_present"
        source => "[zeek][ge_srtp][plc_fault_entry_present]"
        target => "[zeek][ge_srtp][plc_fault_entry_present]"
        dictionary => {
          "One or more fault entries in PLC fault table" => true
          "PLC fault table is empty" => false
        }
      }
    }

    if ([zeek][ge_srtp][plc_fault_entry_last_read]) {
      translate {
        id => "translate_zeek_ge_srtp_plc_fault_entry_last_read"
        source => "[zeek][ge_srtp][plc_fault_entry_last_read]"
        target => "[zeek][ge_srtp][plc_fault_entry_last_read]"
        dictionary => {
          "PLC fault table has changed since last read by this device" => true
          "PLC fault table unchanged since last read" => false
        }
      }
    }

    if ([zeek][ge_srtp][programmer_attachment]) {
      translate {
        id => "translate_zeek_ge_srtp_programmer_attachment"
        source => "[zeek][ge_srtp][programmer_attachment]"
        target => "[zeek][ge_srtp][programmer_attachment]"
        dictionary => {
          "Programmer attachment found" => true
          "No programmer attachment found" => false
        }
      }
    }

  } else if ([log_source] == "genisys") {
    #############################################################################################################################
    # genisys.log specific logic

    ruby {
      id => "ruby_genisys_payload"
      init => "@genisys_fields = [ :address, :data ]"
      code => "
        vars = event.get('[zeek][genisys][payload_raw]')
        if !vars.is_a?(Array) then
          vars = vars.to_s.split(',')
        end
        vars = vars.map{ |x| x.split('=') }.map{ |x| @genisys_fields.zip(x).to_h }
        event.set('[zeek][genisys][payload]', vars) unless vars.to_a.empty?
      "
    }
    mutate { id => "mutate_remove_genisys_payload_raw"
             remove_field => [ "[zeek][genisys][payload_raw]" ] }

  } else if ([log_source] == "gquic") {
    #############################################################################################################################
    # gquic.log specific logic

    if ([zeek][gquic][user_agent]) {
      mutate { id => "mutate_merge_zeek_quic_useragent"
               merge => { "[quic][useragent]" => "[zeek][gquic][user_agent]" } }
    }

    if ([zeek][gquic][server_name]) {
      mutate { id => "mutate_merge_zeek_quic_host"
               merge => { "[quic][host]" => "[zeek][gquic][server_name]" } }
    }

    if ([zeek][gquic][version]) {
      ruby {
        id => "ruby_zeek_set_quic_version"
        code => "event.set('[quic][version]', 'Q' + event.get('[zeek][gquic][version]').to_s.rjust(3, '0'))"
      }
    }


  } else if ([log_source] == "http") {
    #############################################################################################################################
    # http.log specific logic

    # translate Zeek's double-backslashes single backslash in filenames
    ruby {
      id => "ruby_zeek_http_orig_filenames_dedoubleslash"
      path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
      script_params => {
        "source" => "[zeek][http][orig_filenames]"
        "target" => "[zeek][http][orig_filenames]"
      }
    }
    ruby {
      id => "ruby_zeek_http_resp_filenames_dedoubleslash"
      path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
      script_params => {
        "source" => "[zeek][http][resp_filenames]"
        "target" => "[zeek][http][resp_filenames]"
      }
    }

    if ([zeek][http][tags]) {
      # merge zeek.http.tags into tags and then remove original
      mutate { id => "mutate_merge_zeek_http_tags"
               merge => { "[tags]" => "[zeek][http][tags]" } }
      mutate { id => "mutate_remove_field_zeek_http_tags"
               remove_field => [ "[zeek][http][tags]" ] }
    }

    if ([zeek][http][host]) {
      mutate { id => "mutate_merge_zeek_http_host"
               merge => { "[http][host]" => "[zeek][http][host]" } }
    }

    if ([zeek][http][uri]) {
      if ([zeek][http][host]) {
        mutate { id => "mutate_add_field_metadata_http_host_and_uri"
                 add_field => { "[@metadata][http_uri]" => "%{[zeek][http][host]}%{[zeek][http][uri]}" } }
        mutate { id => "mutate_merge_zeek_http_host_and_uri"
                 merge => { "[http][uri]" => "[@metadata][http_uri]" } }
      } else {
        mutate { id => "mutate_merge_zeek_http_uri"
                 merge => { "[http][uri]" => "[zeek][http][uri]" } }
      }
    } else if ([zeek][http][referrer]) {
      mutate { id => "mutate_merge_zeek_http_referrer"
      merge => { "[http][uri]" => "[zeek][http][referrer]" } }
    }

    if ([zeek][http][user_agent]) {
      mutate { id => "mutate_merge_zeek_http_user_agent"
               merge => { "[http][useragent]" => "[zeek][http][user_agent]" } }
    }

    if ([zeek][http][orig_mime_types]) {
      mutate { id => "mutate_merge_zeek_http_orig_mime_types"
               merge => { "[http][bodyMagic]" => "[zeek][http][orig_mime_types]" } }
      # ECS - zeek.http.orig_mime_types -> http.request.mime_type
      mutate { id => "mutate_merge_ecs_http_request_mime_type"
               merge => { "[http][request][mime_type]" => "[zeek][http][orig_mime_types]" } }
    }

    if ([zeek][http][resp_mime_types]) {
      mutate { id => "mutate_merge_zeek_http_resp_mime_types"
               merge => { "[http][bodyMagic]" => "[zeek][http][resp_mime_types]" } }
      # ECS - zeek.http.resp_mime_types -> http.response.mime_type
      mutate { id => "mutate_merge_ecs_http_response_mime_type"
               merge => { "[http][response][mime_type]" => "[zeek][http][resp_mime_types]" } }
    }

    if ([zeek][http][version]) {
      mutate { id => "mutate_merge_zeek_http_clientVersion"
               merge => { "[http][clientVersion]" => "[zeek][http][version]" } }
    }

    if ([zeek][http][status_code]) {
      mutate { id => "mutate_merge_zeek_http_statuscode"
               merge => { "[http][statuscode]" => "[zeek][http][status_code]" } }
    }

    if ([zeek][http][method]) {
      mutate { id => "mutate_merge_zeek_http_method"
               merge => { "[http][method]" => "[zeek][http][method]" } }
    }

    # There is no good ECS equivalent for this field so it will map to Arkime's field name only
    if ([zeek][http][ja4h]) {
      mutate { id => "mutate_merge_zeek_http_ja4h"
               merge => { "[http][ja4h]" => "[zeek][http][ja4h]" } }
    }

    if ([zeek][http][post_username]) {
      mutate { id => "mutate_merge_zeek_http_post_username_1"
               merge => { "[related][user]" => "[zeek][http][post_username]" } }
      mutate { id => "mutate_merge_zeek_http_post_username_2"
               merge => { "[user]" => "[zeek][http][post_username]" } }
    }
    if (![related][password]) and ([zeek][http][post_password_plain]) {
      mutate { id => "mutate_add_field_zeek_http_post_password_plain"
               add_field =>  { "[related][password]" => "%{[zeek][http][post_password_plain]}" } }
    }

    if ([zeek][http][response_body_len]) { mutate { id => "mutate_add_field_zeek_http_server_bytes"
                                                   add_field => { "[server][bytes]" => "%{[zeek][http][response_body_len]}" } } }
    if ([zeek][http][request_body_len]) { mutate { id => "mutate_add_field_zeek_http_client_bytes"
                                                  add_field => { "[client][bytes]" => "%{[zeek][http][request_body_len]}" } } }

    ruby {
      id => "ruby_zeek_http_totDataBytes"
      code => "event.set('[totDataBytes]', event.get('[zeek][http][response_body_len]').to_i + event.get('[zeek][http][request_body_len]').to_i)"
    }

    # ECS - zeek.http.request_body_len -> http.request.body.bytes
    if ([zeek][http][request_body_len]) {        mutate { id => "mutate_add_field_ecs_http_request_body_bytes"
                                                         add_field => { "[http][request][body][bytes]" => "%{[zeek][http][request_body_len]}" } } }
    # ECS - zeek.http.method -> http.request.method
    if ([zeek][http][method]) {                  mutate { id => "mutate_add_field_ecs_http_request_method"
                                                         add_field => { "[http][request][method]" => "%{[zeek][http][method]}" } } }
    # ECS - zeek.http.referrer -> http.request.referrer
    if ([zeek][http][referrer]) {                mutate { id => "mutate_add_field_ecs_http_request_referrer"
                                                         add_field => { "[http][request][referrer]" => "%{[zeek][http][referrer]}" } } }
    # ECS - zeek.http.response_body_len -> http.response.body.bytes
    if ([zeek][http][response_body_len]) {       mutate { id => "mutate_add_field_ecs_http_response_body_bytes"
                                                         add_field => { "[http][response][body][bytes]" => "%{[zeek][http][response_body_len]}" } } }
    # ECS - zeek.http.status_code -> http.response.status_code
    if ([zeek][http][status_code]) {             mutate { id => "mutate_add_field_ecs_http_response_status_code"
                                                         add_field => { "[http][response][status_code]" => "%{[zeek][http][status_code]}" } } }
    # ECS - zeek.http.version -> http.version
    if ([zeek][http][version]) {                 mutate { id => "mutate_add_field_ecs_http_version"
                                                         add_field => { "[http][version]" => "%{[zeek][http][version]}" } } }

    # ECS - zeek.http.host and zeek_http.uri -> url.* (https://www.elastic.co/guide/en/ecs/current/ecs-url.html)
    if ([zeek][http][uri]) or ([zeek][http][host]) {
      ruby {
        id => "ruby_ecs_uri_parse_from_zeek_http"
        init => "require 'uri'"
        code => "
          scheme = 'http'
          user = Array(event.get('[related][user]') || []).compact
          userStr = user.first.to_s
          password = event.get('[related][password]')
          host = event.get('[zeek][http][host]')
          port = event.get('[destination][port]')
          uri = event.get('[zeek][http][uri]')
          ext = (uri.nil? || !(uri.include? '/')) ? nil : File.extname(uri).partition('.').last.split(/[\?#]/)[0]
          fragment = uri.nil? ? nil : uri.partition('#').last
          query = uri.nil? ? nil : uri.partition('?').last
          event.set('[url][scheme]', scheme)
          event.set('[url][original]', scheme + '://' + host.to_s + uri.to_s)
          event.set('[url][full]', scheme + '://' + userStr + (password.nil? ? '' : ':' + password) + ((userStr.empty? && password.nil?) ? '' : '@') + host.to_s + (port.nil? ? '' : ':' + port.to_s) + uri.to_s)
          event.set('[url][domain]', host) unless host.to_s.empty?
          event.set('[url][extension]', ext) unless ext.to_s.empty?
          event.set('[url][fragment]', fragment) unless fragment.to_s.empty?
          event.set('[url][password]', password) unless password.to_s.empty?
          event.set('[url][path]', uri) unless uri.to_s.empty?
          event.set('[url][port]', port) unless port.to_s.empty?
          event.set('[url][query]', query) unless query.to_s.empty?
          event.set('[url][username]', userStr) unless userStr.empty?
        "
        # TODO: ECS url domain stuff (url.registered_domain, url.top_level_domain)
        # perhaps use something like https://github.com/plutonbacon/logstash-filter-publicsuffix
      }
    }

  } else if ([log_source] == "ipsec") {
    #############################################################################################################################
    # ipsec.log specific logic

    ruby {
      id => "ruby_zeek_field_ipsec_flags"
      code => '
        flags = Array.new
        if (event.get("[zeek][ipsec][flag_e]") == "T") then
          flags << "E"
        end
        if (event.get("[zeek][ipsec][flag_c]") == "T") then
          flags << "C"
        end
        if (event.get("[zeek][ipsec][flag_a]") == "T") then
          flags << "A"
        end
        if (event.get("[zeek][ipsec][flag_i]") == "T") then
          flags << "I"
        end
        if (event.get("[zeek][ipsec][flag_v]") == "T") then
          flags << "V"
        end
        if (event.get("[zeek][ipsec][flag_r]") == "T") then
          flags << "R"
        end
        if !flags.empty? then
          event.set("[zeek][ipsec][flags]", flags)
        end'
    }

  } else if ([log_source] == "irc") {
    #############################################################################################################################
    # irc.log specific logic

    if ([zeek][irc][nick]) {
      mutate { id => "mutate_merge_zeek_irc_nick"
               merge => { "[irc][nick]" => "[zeek][irc][nick]" } }
      # store "nick" alongside "user"
      mutate { id => "mutate_merge_irc_nick_user_1"
               merge => { "[related][user]" => "[zeek][irc][nick]" } }
      mutate { id => "mutate_merge_irc_nick_user_2"
               merge => { "[user]" => "[zeek][irc][nick]" } }
    }

    if ([zeek][irc][command]) and ([zeek][irc][value]) and (([zeek][irc][command] == "JOIN") or ([zeek][irc][command] == "PART")) {
      mutate { id => "mutate_merge_zeek_irc_channel"
               merge => { "[irc][channel]" => "[zeek][irc][value]" } }
    }

  } else if ([log_source] == "intel") {
    #############################################################################################################################
    # intel.log specific logic

    ruby {
      id => "ruby_zeek_intel_fields_comma_fix"
      code => "
        ['[zeek][intel][category]',
         '[zeek][intel][cif_description]',
         '[zeek][intel][cif_tags]',
         '[zeek][intel][desc]',
         '[zeek][intel][sources]',
         '[zeek][intel][url]'].each do |field|
          values = event.get(field)
          next unless values.is_a?(Array) && values.length > 0
          adjusted = values.map { |val| val.gsub('\\x2c', ',') }
          event.set(field, adjusted) unless adjusted.empty?
        end
      "
    }
    if ([zeek][intel][url]) { mutate { id => "mutate_merge_zeek_intel_url"
                                       merge => { "[threat][indicator][reference]" => "[zeek][intel][url]" }
                                       remove_field => [ "[zeek][intel][url]" ] } }
    if ([zeek][intel][category]) {
      ruby {
        # given category as ["exploit/vulnerability-scanning", "exploit", "foo/bar", "foo", "bar"]
        #   turn it into  ["exploit/vulnerability-scanning", "foo/bar", "bar"],
        #   so we don't end up with both "exploit" and "exploit/vulnerability-scanning" in the same list
        id => "ruby_zeek_intel_category_cleanup"
        code => "
          categories = Array(event.get('[zeek][intel][category]') || []).compact
          prefixes = categories.select { |s| s.include?('/') }.map { |s| s.split('/').first }.uniq
          event.set('[zeek][intel][category]', categories.reject { |s| prefixes.include?(s) })
        "
      }
    }

    if ([zeek][intel][desc]) {
      # Collapse variants with the same base name (case-insensitive),
      # preferring the bare form’s capitalization if it exists.
      # If only a single variant with parentheses exists, keep it as-is.
      # Example: ["APT41 (X)", "apt41", "Apt41 (Y)"] → ["APT41"]
      #          ["Foo (Bar)"] → ["Foo (Bar)"]
      ruby {
        id => "ruby_zeek_intel_desc_cleanup"
        code => "
          deduped = Array(event.get('[zeek][intel][desc]') || []).compact.group_by { |s| s.split(' (').first.downcase }.map do |_, items|
            bases = items.map { |s| s.split(' (').first }
            # If we have multiple variants or a bare version, collapse to bare
            if items.size > 1 || bases.any? { |b| items.include?(b) }
              # Prefer the bare version with its original capitalization if present
              bare = items.find { |s| !s.include?('(') }
              bare || bases.first
            else
              # Single item, keep as-is (with parens)
              items.first
            end
          end
          event.set('[zeek][intel][desc]', deduped)
        "
      }
    }

  } else if ([log_source] == "ja4ssh") {
    #############################################################################################################################
    # ja4ssh.log specific logic

    if ([zeek][ja4ssh][ja4ssh]) {
      mutate {
        id => "mutate_rename_ja4ssh_fields"
        rename => { "[zeek][ja4ssh][ja4ssh]" => "[zeek][ssh][ja4ssh]" }
      }
      mutate {
        id => "mutate_merge_ja4ssh_fields"
        merge => { "[ssh][ja4ssh]" => "[zeek][ssh][ja4ssh]" }
      }
    }

  } else if ([log_source] == "kerberos") {
    #############################################################################################################################
    # kerberos.log specific logic

    if ([zeek][kerberos][cname]) {
      mutate { id => "mutate_merge_zeek_kerberos_cname"
               merge => { "[krb5][cname]" => "[zeek][kerberos][cname]" } }
    }

    if ([zeek][kerberos][sname]) {
      mutate { id => "mutate_merge_zeek_kerberos_sname"
               merge => { "[krb5][sname]" => "[zeek][kerberos][sname]" } }
    }

  } else if ([log_source] == "ldap") {
    #############################################################################################################################
    # ldap.log specific logic

    # map simple bind "object" and "argument" to username and password
    # and map to Arkime types
    if ("bind simple" in [zeek][ldap][operation]) {
      if ([zeek][ldap][object]) {
        mutate { id => "mutate_merge_zeek_ldap_bind_object_user"
                 merge => { "[related][user]" => "[zeek][ldap][object]" } }
        mutate { id => "mutate_merge_ldap_bind_name"
                 merge => { "[ldap][bindname]" => "[zeek][ldap][object]" } }
      }
      if ([zeek][ldap][argument]) {
        mutate { id => "mutate_merge_zeek_ldap_bind_argument_password"
                 merge => { "[related][password]" => "[zeek][ldap][argument]" } }
      }
      mutate { id => "mutate_add_field_ldap_authtype_simple"
               add_field => { "[@metadata][ldapAuthType]" => "simple" } }
    } else if ("bind SASL" in [zeek][ldap][operation]) {
      mutate { id => "mutate_add_field_ldap_authtype_sasl"
               add_field => { "[@metadata][ldapAuthType]" => "sasl" } }
    }
    if ([@metadata][ldapAuthType]) {
      mutate { id => "mutate_merge_ldap_authtype"
               merge => { "[ldap][authtype]" => "[@metadata][ldapAuthType]" } }
    }

  } else if ([log_source] == "modbus") {
    #############################################################################################################################
    # modbus.log specific logic

    # normalize network_direction to match modbus_details.log
    if ([zeek][modbus][network_direction]) {
      translate {
        id => "translate_zeek_modbus_network_direction"
        source => "[zeek][modbus][network_direction]"
        target => "[zeek][modbus][network_direction]"
        dictionary => {
          "REQ" => "request"
          "RESP" => "response"
        }
      }
    }

  } else if ([log_source] == "modbus_detailed") {
    #############################################################################################################################
    # modbus_detailed.log specific logic

    # rename some fields to make correlating modbus easier between logs
    mutate {
      id => "mutate_rename_modbus_detailed_fields"
      rename => { "[zeek][modbus_detailed][func]" => "[zeek][modbus][func]" }
      rename => { "[zeek][modbus_detailed][unit_id]" => "[zeek][modbus][unit_id]" }
      rename => { "[zeek][modbus_detailed][trans_id]" => "[zeek][modbus][trans_id]" }
      rename => { "[zeek][modbus_detailed][network_direction]" => "[zeek][modbus][network_direction]" }
      rename => { "[zeek][modbus_detailed][modbus_detailed_link_id]" => "[zeek][modbus_detailed][link_id]" }
      rename => { "[zeek][modbus_detailed][exception_code]" => "[zeek][modbus][exception]" }
      rename => { "[zeek][modbus_detailed][mei_type]" => "[zeek][modbus][mei_type]" }
    }

  } else if ([log_source] == "modbus_mask_write_register") {
    #############################################################################################################################
    # modbus_mask_write_register.log specific logic

    # rename some fields to make correlating modbus easier between logs
    mutate {
      id => "mutate_rename_modbus_mask_write_register_fields"
      rename => { "[zeek][modbus_mask_write_register][address]" => "[zeek][modbus_detailed][address]" }
      rename => { "[zeek][modbus_mask_write_register][func]" => "[zeek][modbus][func]" }
      rename => { "[zeek][modbus_mask_write_register][network_direction]" => "[zeek][modbus][network_direction]" }
      rename => { "[zeek][modbus_mask_write_register][unit_id]" => "[zeek][modbus][unit_id]" }
      rename => { "[zeek][modbus_mask_write_register][trans_id]" => "[zeek][modbus][trans_id]" }
      rename => { "[zeek][modbus_mask_write_register][modbus_detailed_link_id]" => "[zeek][modbus_detailed][link_id]" }
    }

  } else if ([log_source] == "modbus_read_device_identification") {
    #############################################################################################################################
    # modbus_read_device_identification.log specific logic

    # rename some fields to make correlating modbus easier between logs
    mutate {
      id => "mutate_rename_modbus_read_device_identification_fields"
      rename => { "[zeek][modbus_read_device_identification][network_direction]" => "[zeek][modbus][network_direction]" }
      rename => { "[zeek][modbus_read_device_identification][unit_id]" => "[zeek][modbus][unit_id]" }
      rename => { "[zeek][modbus_read_device_identification][trans_id]" => "[zeek][modbus][trans_id]" }
      rename => { "[zeek][modbus_read_device_identification][func]" => "[zeek][modbus][func]" }
      rename => { "[zeek][modbus_read_device_identification][mei_type]" => "[zeek][modbus][mei_type]" }
      rename => { "[zeek][modbus_read_device_identification][modbus_detailed_link_id]" => "[zeek][modbus_detailed][link_id]" }
    }

  } else if ([log_source] == "modbus_read_write_multiple_registers") {
    #############################################################################################################################
    # modbus_read_write_multiple_registers.log specific logic

    # rename some fields to make correlating modbus easier between logs
    mutate {
      id => "mutate_rename_modbus_read_write_multiple_registers_fields"
      rename => { "[zeek][modbus_read_write_multiple_registers][network_direction]" => "[zeek][modbus][network_direction]" }
      rename => { "[zeek][modbus_read_write_multiple_registers][unit_id]" => "[zeek][modbus][unit_id]" }
      rename => { "[zeek][modbus_read_write_multiple_registers][trans_id]" => "[zeek][modbus][trans_id]" }
      rename => { "[zeek][modbus_read_write_multiple_registers][func]" => "[zeek][modbus][func]" }
      rename => { "[zeek][modbus_read_write_multiple_registers][modbus_detailed_link_id]" => "[zeek][modbus_detailed][link_id]" }
    }

  } else if ([log_source] == "mqtt_publish") {
    #############################################################################################################################
    # mqtt_publish.log specific logic

    # MQTT payload *may* be JSON, or it may not
    json {
      skip_on_invalid_json => true
      source => "[zeek][mqtt_publish][payload]"
      target => "[zeek][mqtt_publish][payload_dict]"
    }

    if ([zeek][mqtt_publish][payload_len]) { mutate { id => "mutate_add_field_zeek_mqtt_publish_client_len"
                                                     add_field => { "[client][bytes]" => "%{[zeek][mqtt_publish][payload_len]}" } } }


  } else if ([log_source] == "mysql") {
    #############################################################################################################################
    # mysql.log specific logic

    if ([zeek][mysql][rows] == 0) {
      mutate { id => "mutate_remove_field_zeek_mysql_zero_rows"
               remove_field => [ "[zeek][mysql][rows]" ] }
    }

  } else if ([log_source] == "notice") {
    #############################################################################################################################
    # notice.log specific logic

    ruby {
      id => "ruby_add_field_zeek_notice_event_original"
      code => " event.set('[event][original]', [event.get('[zeek][notice][msg]'),
                                                event.get('[zeek][notice][sub]')].reject{ |e| e.nil? || e&.empty? }.join(':'))" }

    # split "Category::Subcategory" into two different fields
    ruby {
      id => "ruby_zeek_notice_category_extract"
      code => "
        if (noticeNote = event.get('[zeek][notice][note]')) and (noticeParts = noticeNote.split('::')) then
          if (noticeParts.length >= 2) then
            event.set('[zeek][notice][category]', noticeParts[0])
            event.set('[zeek][notice][sub_category]', noticeParts[1])
          elsif (noticeParts.length == 1) then
            event.set('[zeek][notice][category]', noticeParts[0])
          end
        end"
    }

    if ([zeek][notice][category] == "ATTACK") and ([zeek][notice][msg] =~ /(from|against|to)\s+host/) {
      # ATTACK::Discovery - Detected activity from host 192.168.199.133, total attempts 5 within timeframe 5.0 mins
      # but no IP addresses set :(
      if (![source][ip]) {
        grok {
          id => "grok_zeek_notice_attack_src_hosts"
          match => { "[zeek][notice][msg]" => [ "from%{SPACE}host%{SPACE}%{DATA:[source][ip]}%{SPACE}($|[^\d:\.\w-]+)" ] }
        }
      }
      if (![destination][ip]) {
        grok {
          id => "grok_zeek_notice_attack_dst_hosts"
          match => { "[zeek][notice][msg]" => [ "(against|to)%{SPACE}host%{SPACE}%{DATA:[destination][ip]}%{SPACE}($|[^\d:\.\w-]+)" ] }
        }
      }
    }

    if ([zeek][notice][note] == "Corelight::XOR_Encrypted_PE_File_Seen") and ([zeek][notice][sub] =~ /Decrypted File ID/) {
      # zeek_notice.note  Corelight::XOR_Encrypted_PE_File_Seen
      #
      #         zeek.fuid   F7QoY740DvrZF2lrsa
      # + zeek_notice.sub   Decrypted File ID: FqNQ8i3LbG2ZY5EO3k
      # -----------------
      # =       zeek.fuid   F7QoY740DvrZF2lrsa, FqNQ8i3LbG2ZY5EO3k
      grok {
        id => "grok_zeek_notice_xor_fuid"
        match => { "[zeek][notice][sub]" => [ "Decrypted%{SPACE}File%{SPACE}ID:%{SPACE}%{WORD:[@metadata][decrypted_xor_fuid]}" ] }
      }
      if ([@metadata][decrypted_xor_fuid]) { mutate { id => "mutate_merge_zeek_notice_decrypted_xor_fuid"
                                                      merge => { "[zeek][fuid]" => "[@metadata][decrypted_xor_fuid]" } } }
    }

    # add event.module to make them jive with signatures, suricata alerts, etc.
    mutate { id => "mutate_add_field_zeek_notice_module"
             add_field => { "[event][module]" => "zeek" } }

    # ECS - zeek.notice.category -> rule.category
    if ([zeek][notice][category]) {
      ruby { id => "ruby_add_field_ecs_rule_category_notice_category"
             code => "event.set('[rule][category]', [ event.get('[zeek][notice][category]'), event.get('[rule][category]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
    }

    # ECS - zeek.notice.sub_category -> rule.name
    if ([zeek][notice][sub_category]) {
      ruby { id => "ruby_add_field_ecs_zeek_rule_name_notice_sub_category"
             code => "event.set('[rule][name]', [ event.get('[zeek][notice][sub_category]'), event.get('[rule][name]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
    }

    # ECS - zeek.notice.category -> rule.author (mapped)
    translate {
      id => "translate_zeek_notice_author"
      source => "[zeek][notice][category]"
      target => "[@metadata][zeek_noticed_mapped_author]"
      dictionary_path => "/etc/notice_authors.yaml"
      fallback => "Zeek"
    }
    if ([@metadata][zeek_noticed_mapped_author]) {
      mutate { id => "mutate_merge_zeek_noticed_mapped_author"
               merge => { "[rule][author]" => "[@metadata][zeek_noticed_mapped_author]" } }
    }

    # ECS - zeek.notice.category -> rule.reference (mapped)
    translate {
      id => "translate_zeek_notice_reference"
      source => "[zeek][notice][category]"
      target => "[@metadata][zeek_noticed_mapped_reference]"
      dictionary_path => "/etc/notice_reference.yaml"
      fallback => "https://docs.zeek.org/en/current/zeek-noticeindex.html"
    }
    if ([@metadata][zeek_noticed_mapped_reference]) {
      mutate { id => "mutate_merge_zeek_noticed_mapped_reference"
               merge => { "[rule][reference]" => "[@metadata][zeek_noticed_mapped_reference]" } }
    }

    # ECS - zeek.notice.category -> rule.license (mapped)
    translate {
      id => "translate_zeek_notice_license"
      source => "[zeek][notice][category]"
      target => "[@metadata][zeek_noticed_mapped_license]"
      dictionary_path => "/etc/notice_license.yaml"
      fallback => "https://raw.githubusercontent.com/zeek/zeek/master/COPYING"
    }
    if ([@metadata][zeek_noticed_mapped_license]) {
      mutate { id => "mutate_merge_zeek_noticed_mapped_license"
               merge => { "[rule][license]" => "[@metadata][zeek_noticed_mapped_license]" } }
    }

    # ECS - zeek.notice.category -> threat.* (https://www.elastic.co/guide/en/ecs/current/ecs-threat.html)

    # populate threat information for MITRE ATT&CK notices from mitre-attack/bzar and cisa/acid plugins
    if ([zeek][notice][category] == "ATTACKICS") {

      mutate { id => "mutate_add_field_ecs_threat_framework_mitre_attack_ics"
               add_field => { "[threat][framework]" => "MITRE ATT&CK for ICS" }
               add_tag => [ "ics" ] }

      if ([zeek][notice][sub]) {
        mutate { id => "mutate_gsub_zeek_notice_sub_proto_slash"
                 gsub => [ "[zeek][notice][sub]", "/.*$", "" ] }
        mutate { id => "mutate_merge_attackics_sub_proto"
                 merge => { "[network][protocol]" => "[zeek][notice][sub]" } }
      }

      if ([zeek][notice][msg]) {
        mutate { id => "mutate_gsub_field_zeek_notice_attackics_msg_indicator"
                 gsub => [ "[zeek][notice][msg]", "^Indicator: ", "" ] }
        if ([zeek][notice][msg] =~ /^T/) {
          # eg., T0845 Program Upload (Function Code: 0x1d - Start Upload)
          grok {
            id => "grok_zeek_notice_msg_attack_ics_technique"
            match => { "[zeek][notice][msg]" => [ "^%{WORD:[threat][technique][id]}%{SPACE}%{DATA:[threat][technique][name]}%{SPACE}\(%{DATA}\)$" ] }
          }
          mutate { id => "mutate_gsub_ecs_threat_technique_name_notice_sub_ics"
                   gsub => [ "[threat][technique][name]", " ", "_" ] }
          if ([threat][technique][id]) {
            mutate { id => "mutate_add_field_threat_technique_ics_reference"
                     add_field => { "[threat][technique][reference]" => "https://attack.mitre.org/tactics/%{[threat][technique][id]}/" } }
          }
        }
      }

      if ([zeek][notice][sub_category]) {
        # sub_category comes from ruby_zeek_notice_category_extract above, it's not the same as sub
        mutate { id => "mutate_add_field_ecs_threat_tactic_name_mitre_ics"
                 add_field => { "[threat][tactic][name]" => "%{[zeek][notice][sub_category]}" } }
        mutate { id => "mutate_gsub_ecs_threat_tactic_name_notice_sub_ics"
                 gsub => [ "[threat][tactic][name]", "_,", " " ] }
        translate {
          id => "translate_zeek_mitre_attack_tactic_name_to_id_ics"
          source => "[zeek][notice][sub_category]"
          target => "[threat][tactic][id]"
          dictionary_path => "/etc/mitre_attack_tactic_ics_ids.yaml"
        }
        translate {
          id => "translate_zeek_mitre_attack_tactic_name_to_reference_ics"
          source => "[zeek][notice][sub_category]"
          target => "[threat][tactic][reference]"
          dictionary_path => "/etc/mitre_attack_tactic_ics_reference.yaml"
          fallback => "https://attack.mitre.org/tactics/ics/"
        }
      }

    } else if ([zeek][notice][category] == "ATTACK") {

      mutate { id => "mutate_add_field_ecs_threat_framework_mitre_attack"
               add_field => { "[threat][framework]" => "MITRE ATT&CK" } }

      if ([zeek][notice][sub]) and ([zeek][notice][sub] =~ /^T/) {
        # eg., T1077 Windows Admin Shares + T1105 Remote File Copy
        ruby {
          id => "ruby_ecs_threat_technique_from_attack_enterprise"
          code => "
            idArray = Array.new
            nameArray = Array.new
            event.get('[zeek][notice][sub]').split('+').each do |technique|
              id, name = technique.strip.match(/(^T.*?)\s+(.+$)/).captures
              idArray.push(id) unless id.nil?
              nameArray.push(name) unless name.nil?
            end
            event.set('[threat][technique][id]', idArray)
            event.set('[threat][technique][name]', nameArray)
            event.set('[threat][technique][reference]', idArray.clone.map(&:clone).map{|x| x.prepend('https://attack.mitre.org/techniques/')})
          "
        }
      }

      if ([zeek][notice][sub_category]) {
        # sub_category comes from ruby_zeek_notice_category_extract above, it's not the same as sub
        mutate { id => "mutate_add_field_ecs_threat_tactic_name_mitre_enterprise"
                 add_field => { "[threat][tactic][name]" => "%{[zeek][notice][sub_category]}" } }
        mutate { id => "mutate_gsub_ecs_threat_tactic_name_notice_sub_enterprise"
                 gsub => [ "[threat][tactic][name]", "_,", " " ] }
        translate {
          id => "translate_zeek_mitre_attack_tactic_name_to_id_enterprise"
          source => "[zeek][notice][sub_category]"
          target => "[threat][tactic][id]"
          dictionary_path => "/etc/mitre_attack_tactic_enterprise_ids.yaml"
        }
        translate {
          id => "translate_zeek_mitre_attack_tactic_name_to_reference_enterprise"
          source => "[zeek][notice][sub_category]"
          target => "[threat][tactic][reference]"
          dictionary_path => "/etc/mitre_attack_tactic_enterprise_reference.yaml"
          fallback => "https://attack.mitre.org/tactics/enterprise/"
        }
      }

    } else if ([zeek][notice][category] == "EternalSafety") {
      # populate threat information for EternalSafety from 0xl3x1/zeek-EternalSafety plugin
      mutate { id => "mutate_add_field_ecs_threat_framework_eternal_safety"
               add_field => { "[threat][framework]" => "EternalSafety" } }
      if ([zeek][notice][sub_category]) { mutate { id => "mutate_add_field_ecs_threat_technique_name_eternal"
                                                  add_field => { "[threat][technique][name]" => "%{[zeek][notice][sub_category]}" } } }
      if ([rule][reference])           { mutate { id => "mutate_add_field_ecs_threat_technique_reference_eternal"
                                                  add_field => { "[threat][tactic][reference]" => "%{[rule][reference]}"
                                                                 "[threat][technique][reference]" => "%{[rule][reference]}" } } }
    }

    if (([zeek][notice][category] =~ /^CVE/) or
        ([zeek][notice][category] == "EternalSafety") or
        ([zeek][notice][category] == "Ripple20") or
        ([zeek][notice][category] == "VMWareRCE2022") or
        ([zeek][notice][category] == "Zerologon")) {
      # ECS - zeek.notice.category -> vulnerability.* (https://www.elastic.co/guide/en/ecs/current/ecs-vulnerability.html)
      mutate { id => "mutate_merge_ecs_vulnerability_category_notice_category"
               merge => { "[vulnerability][category]" => "[zeek][notice][category]" } }
      mutate { id => "mutate_merge_ecs_vulnerability_description_notice_subcategory"
               merge => { "[vulnerability][description]" => "[zeek][notice][sub_category]" } }
      if ([rule][reference]) { mutate { id => "mutate_merge_zeek_noticed_mapped_vulnerability_reference"
                                        merge => { "[vulnerability][reference]" => "[rule][reference]" } } }
      if ([rule][author]) {    mutate { id => "mutate_merge_zeek_noticed_mapped_vulnerability_vendor"
                                        merge => { "[vulnerability][scanner][vendor]" => "[rule][author]" } } }
      if ([zeek][notice][category] =~ /^CVE/) {
        mutate { id => "mutate_add_field_ecs_zeek_vulnerability_enumeration_cve"
                 add_field => { "[vulnerability][enumeration]" => "CVE" } }
        mutate { id => "mutate_add_field_ecs_zeek_vulnerability_id_cve"
                 add_field => { "[vulnerability][id]" => "%{[zeek][notice][category]}" } }
      }
    }

    # remove signature fields that were mapped to ECS or not useful
    mutate { id => "mutate_remove_fields_zeek_notice"
             remove_field => [
              "[zeek][notice][sub_category]",
              "[zeek][notice][category]" ] }

  } else if ([log_source] == "ntlm") {
    #############################################################################################################################
    # ntlm.log specific logic

    # ECS - zeek.ntlm.host -> client.domain
    if ([zeek][ntlm][host]) {
      mutate { id => "mutate_add_field_ecs_client_domain_ntlm_host_name"
               add_field => { "[client][domain]" => "%{[zeek][ntlm][host]}" } }
    }

    # ECS - zeek.ntlm.domain -> client.domain
    if ([zeek][ntlm][domain]) {
      mutate { id => "mutate_add_field_ecs_client_domain_ntlm_domain"
               add_field => { "[client][domain]" => "%{[zeek][ntlm][domain]}" } }
    }

  } else if ([log_source] == "ntp") {
    #############################################################################################################################
    # ntp.log specific logic

    # map mode to string for readability
    if ([zeek][ntp][mode]) {
      translate {
        id => "translate_zeek_ntp_mode_str"
        source => "[zeek][ntp][mode]"
        target => "[zeek][ntp][mode_str]"
        dictionary_path => "/etc/ntp_modes.yaml"
      }
    }

  } else if ([log_source] =~ /^hart_ip/) {
    #############################################################################################################################
    # hart IP logs specific logic

    # There is a lot of linking between various different field types to tie logs together,
    #   see https://github.com/cisagov/icsnpp-hart-ip/tree/main/scripts.
    # We want to rename these fields as much as possible in order to have them cofilterable.

    mutate {
      id => "mutate_rename_hart_ip_linkage_fields"
      rename => { "[zeek][hart_ip_common_commands][command_number_link_id]" => "[zeek][hart_ip][command_number_link_id]" }
      rename => { "[zeek][hart_ip_direct_pdu_command][command_number_link_id]" => "[zeek][hart_ip][command_number_link_id]" }
      rename => { "[zeek][hart_ip_direct_pdu_command][direct_pdu_command_link_id]" => "[zeek][hart_ip][direct_pdu_command_link_id]" }
      rename => { "[zeek][hart_ip_session_record][session_log_record_link_id]" => "[zeek][hart_ip][session_log_record_link_id]" }
      rename => { "[zeek][hart_ip_universal_commands][command_number_link_id]" => "[zeek][hart_ip][command_number_link_id]" }
    }

    # drop float fields that have 'nan' as their value
    ruby {
      id => "ruby_hartip_drop_nan"
      # this is a hard-coded list of the float fields, I don't think we can get them dynamically
      init => "@result_hash = {} ; ['[zeek][hart_ip_common_commands][enter_exit_fixed_analog_channel_mode_fixed_analog_channel_level]','[zeek][hart_ip_common_commands][enter_exit_fixed_current_mode_pv_fixed_current_level]','[zeek][hart_ip_common_commands][read_analog_channel_and_percent_of_range_response_analog_channel_level]','[zeek][hart_ip_common_commands][read_analog_channel_and_percent_of_range_response_analog_channel_percent_of_range]','[zeek][hart_ip_common_commands][read_analog_channel_endpoint_values_response_analog_channel_lower_endpoint_value]','[zeek][hart_ip_common_commands][read_analog_channel_endpoint_values_response_analog_channel_lower_limit_value]','[zeek][hart_ip_common_commands][read_analog_channel_endpoint_values_response_analog_channel_upper_endpoint_value]','[zeek][hart_ip_common_commands][read_analog_channel_endpoint_values_response_analog_channel_upper_limit_value]','[zeek][hart_ip_common_commands][read_analog_channel_information_response_analog_channel_damping_value]','[zeek][hart_ip_common_commands][read_analog_channel_information_response_analog_channel_lower_range_value]','[zeek][hart_ip_common_commands][read_analog_channel_information_response_analog_channel_upper_range_value]','[zeek][hart_ip_common_commands][read_analog_channels_response_analog_channel_level_slot0]','[zeek][hart_ip_common_commands][read_analog_channels_response_analog_channel_level_slot1]','[zeek][hart_ip_common_commands][read_analog_channels_response_analog_channel_level_slot2]','[zeek][hart_ip_common_commands][read_analog_channels_response_analog_channel_level_slot3]','[zeek][hart_ip_common_commands][read_device_variable_information_response_device_variable_damping_value]','[zeek][hart_ip_common_commands][read_device_variable_information_response_device_variable_lower_transducer_limit]','[zeek][hart_ip_common_commands][read_device_variable_information_response_device_variable_minimum_span]','[zeek][hart_ip_common_commands][read_device_variable_information_response_device_variable_upper_transducer_limit]','[zeek][hart_ip_common_commands][read_device_variable_trim_points_response_lower_or_single_trim_point]','[zeek][hart_ip_common_commands][read_device_variable_trim_points_response_upper_trim_point]','[zeek][hart_ip_common_commands][read_device_variables_response_slot0_device_variable]','[zeek][hart_ip_common_commands][read_device_variables_response_slot1_device_variable]','[zeek][hart_ip_common_commands][read_device_variables_response_slot2_device_variable]','[zeek][hart_ip_common_commands][read_device_variables_response_slot3_device_variable]','[zeek][hart_ip_common_commands][read_dynamic_variables_and_primary_variable_analog_channel_response_primary_variable]','[zeek][hart_ip_common_commands][read_dynamic_variables_and_primary_variable_analog_channel_response_primary_variable_analog_level]','[zeek][hart_ip_common_commands][read_dynamic_variables_and_primary_variable_analog_channel_response_quaternary_variable]','[zeek][hart_ip_common_commands][read_dynamic_variables_and_primary_variable_analog_channel_response_secondary_variable]','[zeek][hart_ip_common_commands][read_dynamic_variables_and_primary_variable_analog_channel_response_tertiary_variable]','[zeek][hart_ip_common_commands][trim_analog_channel_gain_analog_channel_level]','[zeek][hart_ip_common_commands][trim_analog_channel_zero_analog_channel_level]','[zeek][hart_ip_common_commands][trim_loop_current_gain_measured_pv_loop_current_level]','[zeek][hart_ip_common_commands][trim_loop_current_zero_measured_pv_loop_current_level]','[zeek][hart_ip_common_commands][write_analog_channel_additional_damping_value_analog_channel_damping_value]','[zeek][hart_ip_common_commands][write_analog_channel_range_values_analog_channel_lower_range_value]','[zeek][hart_ip_common_commands][write_analog_channel_range_values_analog_channel_upper_range_value]','[zeek][hart_ip_common_commands][write_device_variable_damping_value_device_variable_damping_value]','[zeek][hart_ip_common_commands][write_device_variable_device_variable_value]','[zeek][hart_ip_common_commands][write_device_variable_trim_point_trim_point_value]','[zeek][hart_ip_common_commands][write_primary_variable_damping_value_pv_damping_value]','[zeek][hart_ip_common_commands][write_primary_variable_range_values_p_v_lower_range_value]','[zeek][hart_ip_common_commands][write_primary_variable_range_values_pv_upper_range_value]','[zeek][hart_ip_universal_commands][read_device_information_response_p_v_damping_value]','[zeek][hart_ip_universal_commands][read_device_information_response_p_v_lower_range_value]','[zeek][hart_ip_universal_commands][read_device_information_response_p_v_upper_range_value]','[zeek][hart_ip_universal_commands][read_device_variable_response_slot0_device_variable]','[zeek][hart_ip_universal_commands][read_device_variable_response_slot1_device_variable]','[zeek][hart_ip_universal_commands][read_device_variable_response_slot2_device_variable]','[zeek][hart_ip_universal_commands][read_device_variable_response_slot3_device_variable]','[zeek][hart_ip_universal_commands][read_device_variable_response_slot4_device_variable]','[zeek][hart_ip_universal_commands][read_device_variable_response_slot5_device_variable]','[zeek][hart_ip_universal_commands][read_device_variable_response_slot6_device_variable]','[zeek][hart_ip_universal_commands][read_device_variable_response_slot7_device_variable]','[zeek][hart_ip_universal_commands][read_dynamic_variable_response_primary_variable]','[zeek][hart_ip_universal_commands][read_dynamic_variable_response_primary_variable_loop_current]','[zeek][hart_ip_universal_commands][read_dynamic_variable_response_quaternary_variable]','[zeek][hart_ip_universal_commands][read_dynamic_variable_response_secondary_variable]','[zeek][hart_ip_universal_commands][read_dynamic_variable_response_tertiary_variable]','[zeek][hart_ip_universal_commands][read_loop_current_response_primary_variable_loop_current]','[zeek][hart_ip_universal_commands][read_loop_current_response_primary_variable_percent_range]','[zeek][hart_ip_universal_commands][read_primary_variable_response_primary_variable]','[zeek][hart_ip_universal_commands][read_primary_variable_transducer_information_response_p_v_lower_transducer_limit]','[zeek][hart_ip_universal_commands][read_primary_variable_transducer_information_response_p_v_minimum_span]','[zeek][hart_ip_universal_commands][read_primary_variable_transducer_information_response_p_v_upper_transducer_limit]'].each do |string| key = string.match(/\[([^\[\]]+)\]\[([^\[\]]+)\]/)[2] ; @result_hash[key] ||= [] ; @result_hash[key] << string end"
      code => "
        dataset = event.get('[log_source]').to_s
        if @result_hash.key?(dataset) then
          @result_hash[dataset].each do |field|
            if (event.get(field).to_s.downcase == 'nan') then
              event.remove(field)
            end
          end
        end
      "
    }

  } else if ([log_source] =~ /^omron_fins/) {
  #############################################################################################################################
  # omron_fins_*.log specific logic

    mutate {
      id => "mutate_rename_omron_fins_linkage_fields"
      rename => { "[zeek][omron_fins][omron_fins_link_id]" => "[zeek][omron_fins][link_id]" }
      rename => { "[zeek][omron_fins_data_link_status_read][omron_fins_link_id]" => "[zeek][omron_fins][link_id]" }
      rename => { "[zeek][omron_fins_error][omron_fins_link_id]" => "[zeek][omron_fins][link_id]" }
      rename => { "[zeek][omron_fins_file][omron_fins_link_id]" => "[zeek][omron_fins][link_id]" }
      rename => { "[zeek][omron_fins_detail][omron_fins_link_id]" => "[zeek][omron_fins][link_id]" }
      rename => { "[zeek][omron_fins_network_status_read][omron_fins_link_id]" => "[zeek][omron_fins][link_id]" }
      rename => { "[zeek][omron_fins_data_link_status_read][response_code]" => "[zeek][omron_fins][response_code]" }
      rename => { "[zeek][omron_fins_detail][response_code]" => "[zeek][omron_fins][response_code]" }
      rename => { "[zeek][omron_fins_error][response_code]" => "[zeek][omron_fins][response_code]" }
      rename => { "[zeek][omron_fins_file][response_code]" => "[zeek][omron_fins][response_code]" }
      rename => { "[zeek][omron_fins_network_status_read][response_code]" => "[zeek][omron_fins][response_code]" }
      rename => { "[zeek][omron_fins_data_link_status_read][command_code]" => "[zeek][omron_fins][command_code]" }
      rename => { "[zeek][omron_fins_detail][command_code]" => "[zeek][omron_fins][command_code]" }
      rename => { "[zeek][omron_fins_error][command_code]" => "[zeek][omron_fins][command_code]" }
      rename => { "[zeek][omron_fins_file][command_code]" => "[zeek][omron_fins][command_code]" }
      rename => { "[zeek][omron_fins_network_status_read][command_code]" => "[zeek][omron_fins][command_code]" }
      rename => { "[zeek][omron_fins_data_link_status_read][icf_data_type]" => "[zeek][omron_fins][icf_data_type]" }
      rename => { "[zeek][omron_fins_detail][icf_data_type]" => "[zeek][omron_fins][icf_data_type]" }
      rename => { "[zeek][omron_fins_error][icf_data_type]" => "[zeek][omron_fins][icf_data_type]" }
      rename => { "[zeek][omron_fins_file][icf_data_type]" => "[zeek][omron_fins][icf_data_type]" }
      rename => { "[zeek][omron_fins_network_status_read][icf_data_type]" => "[zeek][omron_fins][icf_data_type]" }
      rename => { "[zeek][omron_fins_detail][day]" => "[zeek][omron_fins][day]" }
      rename => { "[zeek][omron_fins_detail][hour]" => "[zeek][omron_fins][hour]" }
      rename => { "[zeek][omron_fins_detail][minute]" => "[zeek][omron_fins][minute]" }
      rename => { "[zeek][omron_fins_detail][month]" => "[zeek][omron_fins][month]" }
      rename => { "[zeek][omron_fins_detail][second]" => "[zeek][omron_fins][second]" }
      rename => { "[zeek][omron_fins_detail][year]" => "[zeek][omron_fins][year]" }
      rename => { "[zeek][omron_fins_error][day]" => "[zeek][omron_fins][day]" }
      rename => { "[zeek][omron_fins_error][hour]" => "[zeek][omron_fins][hour]" }
      rename => { "[zeek][omron_fins_error][minute]" => "[zeek][omron_fins][minute]" }
      rename => { "[zeek][omron_fins_error][month]" => "[zeek][omron_fins][month]" }
      rename => { "[zeek][omron_fins_error][second]" => "[zeek][omron_fins][second]" }
      rename => { "[zeek][omron_fins_error][year]" => "[zeek][omron_fins][year]" }
      rename => { "[zeek][omron_fins_file][day]" => "[zeek][omron_fins][day]" }
      rename => { "[zeek][omron_fins_file][hour]" => "[zeek][omron_fins][hour]" }
      rename => { "[zeek][omron_fins_file][minute]" => "[zeek][omron_fins][minute]" }
      rename => { "[zeek][omron_fins_file][month]" => "[zeek][omron_fins][month]" }
      rename => { "[zeek][omron_fins_file][second]" => "[zeek][omron_fins][second]" }
      rename => { "[zeek][omron_fins_file][year]" => "[zeek][omron_fins][year]" }
    }

  } else if ([log_source] =~ /^opcua_binary/) {
    #############################################################################################################################
    # opcua-binary-*.log specific logic

    # There is a lot of linking between various different field types to tie logs together,
    #   see https://github.com/cisagov/icsnpp-opcua-binary/tree/main/scripts.
    # We want to rename these fields as much as possible in order to have them cofilterable.
    #   I identified these from the the icsnpp-opcua-binary scripts source code with something like
    #   > grep -R '&log' | grep -Pi "\s*#.+$"

    mutate {
      id => "mutate_rename_opcua_linkage_fields"
      rename => { "[zeek][opcua_binary][status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_activate_session][activate_session_diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_activate_session][client_software_cert_link_id]" => "[zeek][opcua_binary_activate_session_client_software_cert][client_software_cert_link_id]" }
      rename => { "[zeek][opcua_binary_activate_session][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_activate_session][opcua_locale_link_id]" => "[zeek][opcua_binary_activate_session_locale_id][opcua_locale_link_id]" }
      rename => { "[zeek][opcua_binary_activate_session][status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_browse][browse_description_link_id]" => "[zeek][opcua_binary_browse_description][browse_description_link_id]" }
      rename => { "[zeek][opcua_binary_browse][browse_diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_browse][browse_next_link_id]" => "[zeek][opcua_binary_browse_request_continuation_point][browse_next_link_id]" }
      rename => { "[zeek][opcua_binary_browse][browse_response_link_id]" => "[zeek][opcua_binary_browse_result][browse_response_link_id]" }
      rename => { "[zeek][opcua_binary_browse][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_browse_result][browse_reference_link_id]" => "[zeek][opcua_binary_browse_response_references][browse_reference_link_id]" }
      rename => { "[zeek][opcua_binary_browse_result][status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_close_session][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_create_monitored_items][create_item_link_id]" => "[zeek][opcua_binary_create_monitored_items_create_item][create_item_link_id]" }
      rename => { "[zeek][opcua_binary_create_monitored_items][create_monitored_items_diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_create_monitored_items][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_create_monitored_items_create_item][monitoring_parameters_status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_create_session][discovery_profile_link_id]" => "[zeek][opcua_binary_create_session_discovery][discovery_profile_link_id]" }
      rename => { "[zeek][opcua_binary_create_session][endpoint_link_id]" => "[zeek][opcua_binary_create_session_endpoints][endpoint_link_id]" }
      rename => { "[zeek][opcua_binary_create_session][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_create_session_endpoints][discovery_profile_link_id]" => "[zeek][opcua_binary_create_session_discovery][discovery_profile_link_id]" }
      rename => { "[zeek][opcua_binary_create_session_endpoints][user_token_link_id]" => "[zeek][opcua_binary_create_session_user_token][user_token_link_id]" }
      rename => { "[zeek][opcua_binary_create_subscription][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_get_endpoints][endpoint_description_link_id]" => "[zeek][opcua_binary_get_endpoints_description][endpoint_description_link_id]" }
      rename => { "[zeek][opcua_binary_get_endpoints][locale_link_id]" => "[zeek][opcua_binary_get_endpoints_locale_id][locale_link_id]" }
      rename => { "[zeek][opcua_binary_get_endpoints][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_get_endpoints][profile_uri_link_id]" => "[zeek][opcua_binary_get_endpoints_profile_uri][profile_uri_link_id]" }
      rename => { "[zeek][opcua_binary_get_endpoints_description][discovery_profile_link_id]" => "[zeek][opcua_binary_get_endpoints_discovery][discovery_profile_link_id]" }
      rename => { "[zeek][opcua_binary_get_endpoints_description][user_token_link_id]" => "[zeek][opcua_binary_get_endpoints_user_token][user_token_link_id]" }
      rename => { "[zeek][opcua_binary_opensecure_channel][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_read][diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_read][nodes_to_read_link_id]" => "[zeek][opcua_binary_read_nodes_to_read][nodes_to_read_link_id]" }
      rename => { "[zeek][opcua_binary_read][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_read][read_results_link_id]" => "[zeek][opcua_binary_read_results][results_link_id]" }
      rename => { "[zeek][opcua_binary_read_results][status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_variant_metadata][variant_source_data_link_id]" => "[zeek][opcua_binary][variant_source_link_id]" }
      rename => { "[zeek][opcua_binary_read_results][read_results_variant_metadata_link_id]" => "[zeek][opcua_binary][variant_source_link_id]" }
      rename => { "[zeek][opcua_binary_variant_data][variant_metadata_data_link_id]" => "[zeek][opcua_binary][variant_source_link_id]" }
      rename => { "[zeek][opcua_binary_variant_data_value][variant_metadata_link_id]" => "[zeek][opcua_binary][variant_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_literal_operand][literal_operand_variant_link]" => "[zeek][opcua_binary][variant_source_link_id]" }
      rename => { "[zeek][opcua_binary_variant_metadata][variant_data_link_id]" => "[zeek][opcua_binary_variant_data][variant_data_link_id]" }
      rename => { "[zeek][opcua_binary_variant_metadata][variant_data_array_multi_dim_link_id]" => "[zeek][opcua_binary_variant_array_dims][array_dim_link_id]" }
      rename => { "[zeek][opcua_binary_variant_data][variant_data_status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_variant_data][variant_data_diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_variant_data][variant_data_ext_obj_link_id]" => "[zeek][opcua_binary_variant_extension_object][ext_obj_link_id]" }
      rename => { "[zeek][opcua_binary_variant_data][variant_data_value_link_id]" => "[zeek][opcua_binary_variant_data_value][variant_data_value_source_link]" }
      rename => { "[zeek][opcua_binary_variant_data_value][status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_create_monitored_items_create_item][filter_info_details_link_id]" => "[zeek][opcua_binary][filter_source_link_id]" }
      rename => { "[zeek][opcua_binary_data_change_filter][monitored_parameters_link_id]" => "[zeek][opcua_binary][filter_source_link_id]" }
      rename => { "[zeek][opcua_binary_aggregate_filter][monitored_parameters_link_id]" => "[zeek][opcua_binary][filter_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter][monitored_parameters_link_id]" => "[zeek][opcua_binary][filter_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter][select_clause_link_id]" => "[zeek][opcua_binary_event_filter_select_clause][select_clause_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter][where_clause_content_filter_link_id]" => "[zeek][opcua_binary_event_filter_where_clause][where_clause_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_where_clause][content_filter_element_link_id]" => "[zeek][opcua_binary_event_filter_where_clause_elements][content_filter_element_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_where_clause][content_filter_status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_where_clause][content_filter_diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_where_clause_elements][content_filter_filter_operand_link_id]" => "[zeek][opcua_binary][operand_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_where_clause_elements][content_filter_operand_status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_where_clause_elements][content_filter_operand_diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_select_clause][simple_attribute_operand_browse_path_link_id]" => "[zeek][opcua_binary_event_filter_simple_attribute_operand_browse_paths][simple_attribute_operand_browse_path_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_select_clause][select_clause_status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_select_clause][select_clause_diagnostic_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_simple_attribute_operand][content_filter_filter_operand_link_id]" => "[zeek][opcua_binary][operand_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_simple_attribute_operand][simple_attribute_operand_browse_path_link_id]" => "[zeek][opcua_binary_event_filter_simple_attribute_operand_browse_paths][simple_attribute_operand_browse_path_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_attribute_operand][content_filter_filter_operand_link_id]" => "[zeek][opcua_binary][operand_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_attribute_operand][browse_path_element_link_id]" => "[zeek][opcua_binary_event_filter_attribute_operand_browse_paths][browse_path_element_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_element_operand][content_filter_filter_operand_link_id]" => "[zeek][opcua_binary][operand_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_literal_operand][content_filter_filter_operand_link_id]" => "[zeek][opcua_binary][operand_source_link_id]" }
      rename => { "[zeek][opcua_binary_write][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_write][diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_write][write_results_variant_metadata_link_id]" => "[zeek][opcua_binary][variant_source_link_id]" }
    }
    if ([zeek][opcua_binary][req_opcua_link_id]) {
      mutate { id => "mutate_merge_zeek_opcua_binary_req_opcua_link_id"
               merge => { "[zeek][opcua_binary][opcua_link_id]" => "[zeek][opcua_binary][req_opcua_link_id]" } }
    }
    if ([zeek][opcua_binary][res_opcua_link_id]) {
      mutate { id => "mutate_merge_zeek_opcua_binary_res_opcua_link_id"
               merge => { "[zeek][opcua_binary][opcua_link_id]" => "[zeek][opcua_binary][res_opcua_link_id]" } }
    }
    if ([zeek][opcua_binary_write][req_status_code_link_id]) {
      mutate { id => "mutate_merge_zeek_opcua_binary_write_req_status_code_link_id"
               merge => { "[zeek][opcua_binary_status_code_detail][status_code_link_id]" => "[zeek][opcua_binary_write][req_status_code_link_id]" }
               remove_field => [ "[zeek][opcua_binary_write][req_status_code_link_id]" ] }
    }
    if ([zeek][opcua_binary_write][res_status_code_link_id]) {
      mutate { id => "mutate_merge_zeek_opcua_binary_write_res_status_code_link_id"
               merge => { "[zeek][opcua_binary_status_code_detail][status_code_link_id]" => "[zeek][opcua_binary_write][res_status_code_link_id]" }
               remove_field => [ "[zeek][opcua_binary_write][res_status_code_link_id]" ] }
    }

    # count the number of contributing "log types" after we've renamed stuff
    ruby {
        id => "ruby_zeek_opcua_binary_log_types"
        code => "
            zeekHash = event.get('[zeek]')
            if !zeekHash.nil? && zeekHash.is_a?(Hash) then
              event.set('[zeek][opcua_binary][log_types]', zeekHash.count { |_, v| v.is_a?(Hash) })
            end
        "
    }

    if ([zeek][opcua_binary_activate_session][ext_obj_password]) {
      mutate { id => "mutate_merge_zeek_opcua_binary_activate_session_ext_obj_password"
               merge => { "[related][password]" => "[zeek][opcua_binary_activate_session][ext_obj_password]" } }
    }

    if ([zeek][opcua_binary_activate_session][ext_obj_user_name]) {
      mutate { id => "mutate_merge_zeek_opcua_binary_activate_session_ext_obj_user_name"
               merge => { "[related][user]" => "[zeek][opcua_binary_activate_session][ext_obj_user_name]" } }
    }

    if ([zeek][opcua_binary_create_session_user_token][user_token_policy_id]) {
      mutate { id => "mutate_merge_zeek_opcua_binary_create_session_user_token_user_token_policy_id"
               merge => { "[related][user]" => "[zeek][opcua_binary_create_session_user_token][user_token_policy_id]" } }
    }

    if ([zeek][opcua_binary_get_endpoints_user_token][user_token_policy_id]) {
      mutate { id => "mutate_merge_zeek_opcua_binary_get_endpoints_user_token_user_token_policy_id"
               merge => { "[related][user]" => "[zeek][opcua_binary_get_endpoints_user_token][user_token_policy_id]" } }
    }

    if ([zeek][opcua_binary_activate_session][ext_obj_policy_id]) and
       ([zeek][opcua_binary_activate_session][ext_obj_type_id_str] =~ /(User(Name)?IdentityToken|AnonymousIdentityToken)/) {
      mutate { id => "mutate_merge_zeek_opcua_binary_activate_session_ext_obj_policy_id"
               merge => { "[related][user]" => "[zeek][opcua_binary_activate_session][ext_obj_policy_id]" } }
    }

    if ([zeek][opcua_binary_create_session_endpoints][text]) {
      mutate { id => "mutate_add_field_zeek_opcua_binary_create_session_endpoints_text_software_name"
               add_field => { "[zeek][software][name]" => "%{[zeek][opcua_binary_create_session_endpoints][text]}" } }
      mutate { id => "mutate_add_field_zeek_opcua_binary_create_session_endpoints_text_software_type"
               add_field => { "[zeek][software][software_type]" => "OPCUA" } }
    }

    if ([zeek][opcua_binary_get_endpoints_description][text]) {
      mutate { id => "mutate_add_field_zeek_opcua_binary_get_endpoints_description_text_software_name"
               add_field => { "[zeek][software][name]" => "%{[zeek][opcua_binary_get_endpoints_description][text]}" } }
      mutate { id => "mutate_add_field_zeek_opcua_binary_get_endpoints_description_text_software_type"
               add_field => { "[zeek][software][software_type]" => "OPCUA" } }
    }

  } else if ([log_source] == "postgresql") {
    #############################################################################################################################
    # postgresql.log specific logic

    if ([zeek][postgresql][rows] == 0) {
      mutate { id => "mutate_remove_field_zeek_postgresql_zero_rows"
               remove_field => [ "[zeek][postgresql][rows]" ] }
    }

  } else if ([log_source] == "profinet_io_cm") {
    #############################################################################################################################
    # profinet_io_cm.log specific logic

    if ([zeek][profinet_io_cm][packet_type]) and
        ((![zeek][profinet_io_cm][operation])       or ([zeek][profinet_io_cm][operation] == '(empty)') or
         ([zeek][profinet_io_cm][operation] == 'unknown') or ([zeek][profinet_io_cm][operation] == '-') or
         ([zeek][profinet_io_cm][operation] == '')) {
      mutate { id => "mutate_replace_zeek_profinet_io_cm_operation"
               replace => { "[zeek][profinet_io_cm][operation]" => "%{[zeek][profinet_io_cm][packet_type]}" } }
    }

    if ([zeek][profinet_io_cm][interface_vers_major]) or ([zeek][profinet_io_cm][interface_vers_minor]) {
      ruby {
        id => "ruby_zeek_profinet_io_cm_interface_vers"
        code => '
          event.set("[zeek][profinet_io_cm][uuid_version]",
                    [event.get("[zeek][profinet_io_cm][interface_vers_major]").to_s,
                     event.get("[zeek][profinet_io_cm][interface_vers_minor]").to_s].join("."))
        '
      }
      mutate { id => "mutate_remove_fields_zeek_profinet_io_cm_interface_vers"
               remove_field => [ "[zeek][profinet_io_cm][interface_vers_major]",
                                 "[zeek][profinet_io_cm][interface_vers_minor]" ] }
    }

  } else if ([log_source] == "radius") {
    #############################################################################################################################
    # radius.log specific logic

    if ([related][user]) { mutate { id => "mutate_merge_zeek_radius_user"
                                    merge => { "[radius][user]" => "[related][user]" } } }

    if ([zeek][radius][framed_addr]) {
      mutate { id => "mutate_merge_zeek_radius_framed_addr"
               merge => { "[radius][framedIp]" => "[zeek][radius][framed_addr]" } }
    }

    if ([zeek][radius][tunnel_client]) {
      mutate { id => "mutate_merge_zeek_radius_tunnel_client"
               merge => { "[radius][endpointIp]" => "[zeek][radius][tunnel_client]" } }
    }

    if ([zeek][radius][mac]) {
      mutate { id => "mutate_merge_zeek_radius_mac"
               merge => { "[radius][mac]" => "[zeek][radius][mac]" } }
      if (![source][mac]) {
        mutate { id => "mutate_merge_zeek_radius_zeek_mac"
                 merge => { "[source][mac]" => "[zeek][radius][mac]" } }
      }
    }

  } else if ([log_source] =~ /^roc_plus/) {

    mutate {
      id => "mutate_rename_roc_plus_fields"
      rename => { "[zeek][roc_plus][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_configurable_opcode][data]" => "[zeek][roc_plus][data]" }
      rename => { "[zeek][roc_plus_configurable_opcode][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_data_request][history_segment]" => "[zeek][roc_plus_history_information][history_segment]" }
      rename => { "[zeek][roc_plus_data_request][num_points]" => "[zeek][roc_plus][num_points]" }
      rename => { "[zeek][roc_plus_data_request][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_file_transfer][command]" => "[zeek][roc_plus][command]" }
      rename => { "[zeek][roc_plus_file_transfer][data]" => "[zeek][roc_plus][data]" }
      rename => { "[zeek][roc_plus_file_transfer][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_historical_min_max_vals][history_segment]" => "[zeek][roc_plus_history_information][history_segment]" }
      rename => { "[zeek][roc_plus_historical_min_max_vals][point_logic_number]" => "[zeek][roc_plus][point_logic_number]" }
      rename => { "[zeek][roc_plus_historical_min_max_vals][point_type]" => "[zeek][roc_plus][point_type]" }
      rename => { "[zeek][roc_plus_historical_min_max_vals][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_history_information][command]" => "[zeek][roc_plus][command]" }
      rename => { "[zeek][roc_plus_history_information][num_points]" => "[zeek][roc_plus][num_points]" }
      rename => { "[zeek][roc_plus_history_information][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_history_point_data][current_history_segment_index]" => "[zeek][roc_plus_history_information][current_index]" }
      rename => { "[zeek][roc_plus_history_point_data][history_segment]" => "[zeek][roc_plus_history_information][history_segment]" }
      rename => { "[zeek][roc_plus_history_point_data][history_segment_index]" => "[zeek][roc_plus_history_information][history_segment_index]" }
      rename => { "[zeek][roc_plus_history_point_data][num_time_periods]" => "[zeek][roc_plus_history_information][num_time_periods]" }
      rename => { "[zeek][roc_plus_history_point_data][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_history_point_data][type_of_history]" => "[zeek][roc_plus_history_information][type_of_history]" }
      rename => { "[zeek][roc_plus_login][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_peer_to_peer_network_messages][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_realtime_clock][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_single_point_parameters][parameter_data]" => "[zeek][roc_plus][data]" }
      rename => { "[zeek][roc_plus_single_point_parameters][point_logic_number]" => "[zeek][roc_plus][point_logic_number]" }
      rename => { "[zeek][roc_plus_single_point_parameters][point_type]" => "[zeek][roc_plus][point_type]" }
      rename => { "[zeek][roc_plus_single_point_parameters][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_store_and_forward][opcode_data]" => "[zeek][roc_plus][data]" }
      rename => { "[zeek][roc_plus_store_and_forward][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_sys_cfg][point_types]" => "[zeek][roc_plus][point_type]" }
      rename => { "[zeek][roc_plus_sys_cfg][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_time_period_history_points][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_transaction_history][command]" => "[zeek][roc_plus][command]" }
      rename => { "[zeek][roc_plus_transaction_history][data]" => "[zeek][roc_plus][data]" }
      rename => { "[zeek][roc_plus_transaction_history][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_unknown_data][data]" => "[zeek][roc_plus][data]" }
      rename => { "[zeek][roc_plus_unknown_data][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
      rename => { "[zeek][roc_plus_user_defined_info][command]" => "[zeek][roc_plus][command]" }
      rename => { "[zeek][roc_plus_user_defined_info][num_points]" => "[zeek][roc_plus][num_points]" }
      rename => { "[zeek][roc_plus_user_defined_info][point_types]" => "[zeek][roc_plus][point_type]" }
      rename => { "[zeek][roc_plus_user_defined_info][roc_plus_link_id]" => "[zeek][roc_plus][link_id]" }
    }

    if ([zeek][roc_plus_peer_to_peer_network_messages][embedded_request_length]) or
       ([zeek][roc_plus_peer_to_peer_network_messages][embedded_response_length]) {
       if ([zeek][roc_plus_peer_to_peer_network_messages][embedded_request_length]) {
         mutate { id => "mutate_add_field_zeek_roc_plus_peer_to_peer_network_messages_source_bytes"
                  add_field => { "[source][bytes]" => "%{[zeek][roc_plus_peer_to_peer_network_messages][embedded_request_length]}" } }
       }
       if ([zeek][roc_plus_peer_to_peer_network_messages][embedded_response_length]) {
         mutate { id => "mutate_add_field_zeek_roc_plus_peer_to_peer_network_messages_destination_bytes"
                  add_field => { "[destination][bytes]" => "%{[zeek][roc_plus_peer_to_peer_network_messages][embedded_response_length]}" } }
       }
       ruby {
         id => "roc_plus_peer_to_peer_bytes_calc"
         code => "event.set('[totDataBytes]', event.get('[source][bytes]').to_i + event.get('[destination][bytes]').to_i)
                  event.set('[network][bytes]', event.get('[source][bytes]').to_i + event.get('[destination][bytes]').to_i)"
       }
    }

    if ([zeek][roc_plus_transaction_history][msg_data_size]) {
      mutate { id => "mutate_add_field_zeek_roc_plus_transaction_history_msg_data_size"
               add_field => { "[network][bytes]" => "%{[zeek][roc_plus_transaction_history][msg_data_size]}" } }
    }
    if ([zeek][roc_plus_file_transfer][num_bytes]) {
      mutate { id => "mutate_add_field_zeek_roc_plus_file_transfer_network_bytes"
               add_field => { "[network][bytes]" => "%{[zeek][roc_plus_file_transfer][num_bytes]}" } }
    }
    if ([zeek][roc_plus_file_transfer][file_size]) {
      mutate { id => "mutate_add_field_zeek_roc_plus_file_transfer_file_size"
               rename => { "[zeek][roc_plus_file_transfer][file_size]" => "[file][size]" } }
    }
    if ([zeek][roc_plus_store_and_forward][num_data_bytes]) {
      mutate { id => "mutate_add_field_zeek_roc_plus_store_and_forward_num_data_bytes_network_bytes"
               add_field => { "[network][bytes]" => "%{[zeek][roc_plus_store_and_forward][num_data_bytes]}" } }
    }
    if ([zeek][roc_plus][data_length]) {
      mutate { id => "mutate_add_field_zeek_roc_plus_data_length_network_bytes"
               add_field => { "[network][bytes]" => "%{[zeek][roc_plus][data_length]}" } }
    }
    if ([zeek][roc_plus][packet_type] == "Unknown") {
      mutate { id => "mutate_remove_fields_roc_plus_packet_type_unknown"
               remove_field => [ "[zeek][roc_plus][packet_type]" ] }
    }

  } else if ([log_source] == "s7comm_read_szl") {
    #############################################################################################################################
    # s7comm_read_szl.log specific logic

    # so we can link s7comm and s7comm_read_szl by this field
    mutate { id => "mutate_rename_zeek_s7comm_read_szl_pdu_reference"
             rename => { "[zeek][s7comm_read_szl][pdu_reference]" => "[zeek][s7comm][pdu_reference]" } }

  } else if ([log_source] == "s7comm_upload_download") {
    #############################################################################################################################
    # s7comm_upload_download.log specific logic

    # so we can link s7comm and s7comm_upload_download by this field
    mutate { id => "mutate_rename_zeek_s7comm_upload_download_pdu_reference"
             rename => { "[zeek][s7comm_upload_download][pdu_reference]" => "[zeek][s7comm][pdu_reference]" } }

  } else if ([log_source] == "signatures") {
    #############################################################################################################################
    # signatures.log specific logic
    #
    # this has been reworked significantly from its original form to normalize to ECS along with suricata.alert.*

    if ("_carved" in [tags]) {
      # Malcolm does some "special" stuff in zeek_carve_logger.py for file carving, sort of hijacking signatures.log for it

      # _carved signature logs' sub_message contains fuid(s) comma-separated
      if ([zeek][signatures][sub_message]) {
        mutate { id => "mutate_rename_zeek_signatures_sub_message"
                 rename => { "[zeek][signatures][sub_message]" => "[zeek][fuid]" } }
      }

      if ([zeek][signatures][event_message]) {
        # sub_message contains "Signature [Engine]" list semi-colon separated
        ruby {
            id => "ruby_zeek_signatures_event_message_parse"
            code => "
                matchesHash = Hash.new
                idArray = Array.new
                event.get('[zeek][signatures][event_message]').split(';').each { |hit|
                  nameAndEngines = hit.split(/(.+?)\s*<(.+)>/)
                  nameAndEngines[2].split(',').each { |engine|
                    unless matchesHash.key?(engine)
                      matchesHash[engine] = Array.new
                    end
                    matchesHash[engine].push(nameAndEngines[1])
                    idArray.push(nameAndEngines[1])
                  }
                }
                event.set('[zeek][signatures][hits]', matchesHash) unless matchesHash.empty?
                event.set('[event][module]', matchesHash.keys) unless matchesHash.empty?
                event.set('[event][hits]', matchesHash.length)
                event.set('[rule][name]', idArray.uniq) unless idArray.empty?
            "
        }
      }

    } else {
      # not _carved, actual zeek signatures.log entries

      if ([zeek][signatures][signature_id]) {
        if ([zeek][signatures][signature_id] =~ /^dpd_/) {
          # I don't care about DPD matching signatures
          drop { id => "drop_zeek_ignored_signatures_dpd" }
        } else {
          mutate { id => "mutate_merge_zeen_signature_id_rule_name"
                   merge => { "[rule][name]" => "[zeek][signatures][signature_id]" } }
        }
      }

      if ([zeek][signatures][event_message]) {
        mutate { id => "mutate_add_field_ecs_event_original_signature_event_message"
                 add_field => { "[event][original]" => "%{[zeek][signatures][event_message]}" } }
      }

    } # carved vs not

    if (![event][module]) {
      ruby { id => "ruby_add_field_zeek_signature_event_module"
             code => "event.set('[event][module]', [ 'zeek' ].flatten.reject{ |e| e.nil? || e&.empty? })" }
    }

    # ECS - zeek.signatures.note -> rule.category
    if ([zeek][signatures][note]) {
      mutate { id => "mutate_add_field_ecs_zeek_rule_category_signatures_note"
               merge => { "[rule][category]" => "[zeek][signatures][note]" } }
    }

    if ('Capa' in [event][module]) {
      # ECS - populate threat information for MITRE ATT&CK techniques specified by capa hits
      ruby {
          id => "ruby_signatures_attack_extract"
          # matches array is like: 1) tactic name, 2) technique name, 3) sub-technique name, 4) technique number
          # <MatchData
          #  "Persistence::Create or Modify System Process::Windows Service [ATT&CK T1543.003]"
          #    1:"Persistence"
          #    2:"Create or Modify System Process"
          #    3:"Windows Service"
          #    4:"T1543.003">,
          # <MatchData
          #  "Execution::Shared Modules [ATT&CK T1129]"
          #    1:"Execution"
          #    2:"Shared Modules"
          #    3:nil
          #    4:"T1129">
          init => "
            require 'yaml'; $tacticIdMap = YAML.safe_load(File.read('/etc/mitre_attack_tactic_enterprise_ids.yaml'));
          "
          code => "
            matches = Array.new
            begin
              Array(event.get('[rule][name]') || []).compact.each do |signature|
                matches.push(/(.+?)::(.+?)(?:::(.+?))?\s*\[ATT&CK\s*(.+?)\]/.match(signature))
              end
            rescue Exception => e
              event.set('ruby_exception', 'ruby_signatures_attack_extract: ' + e.message)
            end
            if ! matches.empty? then
                tacticNames = matches.map{ |x| x[1].gsub(' ', '_') }.reject{ |e| e.nil? || e&.empty? }
                tacticIds = tacticNames.clone.map(&:clone).map{ |x| $tacticIdMap[x] }.reject{ |e| e.nil? || e&.empty? }
                tacticRefs = tacticIds.clone.map(&:clone).map { |x| x.gsub(/\..*/, '').prepend('https://attack.mitre.org/tactics/') }.uniq.reject{ |e| e.nil? || e&.empty? }
                techniqueNames = matches.map{ |x| [x[2], x[3]].reject{ |e| e.nil? || e&.empty? }.join(':') }.reject{ |e| e.nil? || e&.empty? }
                techniqueIds = matches.map{ |x| x[4] }.reject{ |e| e.nil? || e&.empty? }
                techniqueRefs = techniqueIds.clone.map(&:clone).map { |x| x.gsub(/\..*/, '').prepend('https://attack.mitre.org/techniques/') }.uniq.reject{ |e| e.nil? || e&.empty? }
                event.set('[threat][tactic][name]', tacticNames.uniq) unless tacticNames.to_a.empty?
                event.set('[threat][tactic][id]', tacticIds.uniq) unless tacticIds.to_a.empty?
                event.set('[threat][tactic][reference]', tacticRefs.uniq) unless tacticRefs.to_a.empty?
                event.set('[threat][technique][name]', techniqueNames.uniq) unless techniqueNames.to_a.empty?
                event.set('[threat][technique][id]', techniqueIds.uniq) unless techniqueIds.to_a.empty?
                event.set('[threat][technique][reference]', techniqueRefs.uniq) unless techniqueRefs.to_a.empty?
                event.set('[threat][framework]', 'MITRE ATT&CK')
            end
          "
      }
    } # Capa

    # get more specific than 'Signatures::Sensitive_Signature' if we can
    if ([rule][category]) and ([rule][category][0] == 'Signatures::Sensitive_Signature') {
      if ([threat][tactic][name]) {
        mutate { id => "mutate_merge_zeek_sensitive_signature_tactic"
                 merge => { "[@metadata][zeek_sensitive_signature_replacement]" => "[threat][tactic][name]" } }
      } else if ([threat][technique][name]) {
        mutate { id => "mutate_merge_zeek_sensitive_signature_technique"
                 merge => { "[@metadata][zeek_sensitive_signature_replacement]" => "[threat][technique][name]" } }
      } else if ([threat][framework]) {
        mutate { id => "mutate_merge_zeek_sensitive_signature_framework"
                 merge => { "[@metadata][zeek_sensitive_signature_replacement]" => "[threat][framework]" } }
      }
      if ([@metadata][zeek_sensitive_signature_replacement]) {
        mutate { id => "remove_field_zeek_sensitive_signature"
                 remove_field => [ "[rule][category][0]" ] }
        mutate { id => "mutate_merge_zeek_sensitive_signature_replacement"
                 merge => { "[rule][category]" => "[@metadata][zeek_sensitive_signature_replacement]" } }
      } else if ([event][hits]) and ([event][hits] > 1) {
        mutate { id => "remove_field_zeek_sensitive_signature_multiple"
                 remove_field => [ "[rule][category][0]" ] }
        ruby { id => "ruby_add_field_zeek_multiple_signatures"
               code => "event.set('[rule][category]', [ 'Signatures::Multiple_Signatures', event.get('[rule][category]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
      }
    }

    # remove signature fields that were mapped to ECS
    mutate { id => "mutate_remove_fields_zeek_signatures"
             remove_field => [
              "[zeek][signatures][event_message]",
              "[zeek][signatures][note]" ] }

  } else if ([log_source] == "sip") {
    #############################################################################################################################
    # sip.log specific logic

    ruby {
      id => "ruby_zeek_field_zeek_sip_version"
      code => '
        versions = Array.new
        paths = [event.get("[zeek][sip][request_path]"), event.get("[zeek][sip][response_path]")].reject{ |e| e.nil? || e&.empty? }.join(",")
        paths.scan(/\bSIP:?\/([\d\.]+)/i) { |match| versions << match[0] }
        event.set("[zeek][sip][version]", versions.uniq) unless versions.empty?
      '
    }

    if ([zeek][sip][request_body_len]) { mutate { id => "mutate_add_field_zeek_sip_client_bytes"
                                                 add_field => { "[client][bytes]" => "%{[zeek][sip][request_body_len]}" } } }

    if ([zeek][sip][response_body_len]) { mutate { id => "mutate_add_field_zeek_sip_server_bytes"
                                                  add_field => { "[server][bytes]" => "%{[zeek][sip][response_body_len]}" } } }

  } else if ([log_source] == "smb_cmd") or ([log_source] == "smb_files") {
    #############################################################################################################################
    # smb_cmd.log and smb_files.log specific logic
    # note that smb_cmd.referenced_file is exactly the same structure as the log line for smb_files, which is why I've combined
    # the logic here to avoid duplication

    if ([zeek][smb_cmd]) {

      if ([zeek][smb_cmd][tree]) {
         # translate Zeek's double-backslashes single backslash in filenames
         ruby {
           id => "ruby_zeek_smb_cmd_tree_dedoubleslash"
           path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
           script_params => {
             "source" => "[zeek][smb_cmd][tree]"
             "target" => "[zeek][smb_cmd][tree]"
           }
         }
         # split zeek.smb_cmd.tree to host and service
         ruby {
           id => "ruby_zeek_smb_cmd_tree_split"
           path => "/usr/share/logstash/malcolm-ruby/smbsplit.rb"
           script_params => {
             "source" => "[zeek][smb_cmd][tree]"
             "host" => "[smb][host]"
             "share" => "[smb][share]"
             "path" => "[smb][filename]"
           }
         }
         # if we didn't populate service, fall back to tree_service for share
         if (![smb][share]) and ([zeek][smb_cmd][tree_service]) {
             mutate { id => "mutate_merge_zeek_smb_cmd_tree_service_share"
                      merge => { "[smb][share]" => "[zeek][smb_cmd][tree_service]" } }
         }
      } # if [zeek][smb_cmd][tree]

      if ([zeek][smb_cmd][referenced_file]) {

        # move "up" referenced_file to its own smb_files top-level entity
        mutate {
          id => "mutate_rename_zeek_zeek_smb_cmd_referenced_file"
          rename => { "[zeek][smb_cmd][referenced_file]" => "[zeek][smb_files]" }
        }

        # remove unset (-) or "(empty)" referenced_file (now zeek_smb_files) subfield values
        ruby {
          id => "ruby_zeek_remove_empty_smb_cmd_referenced_file_values"
          path => "/usr/share/logstash/malcolm-ruby/compact_event_hash.rb"
          script_params => {
            "field" => "[zeek][smb_files]"
          }
        }

        # collect referenced file UIDs(s)/FUID(s) at parent level (here rather than in 1300_zeek_normalize.conf because
        # this would have already been done as a root-level fuid array in the main "rename" above if we
        # had not had to move it up a level just now)
        if ([zeek][smb_files][uid]) {
          mutate { id => "mutate_merge_zeek_smb_files_uid"
                   merge => { "[zeek][uid]" => "[zeek][smb_files][uid]" } }
          mutate { id => "mutate_remove_zeek_smb_files_uid"
                   remove_field => [ "[zeek][smb_files][uid]" ] }
        }
        if ([zeek][smb_files][fuid]) {
          mutate { id => "mutate_merge_zeek_smb_files_fuid"
                   merge => { "[zeek][fuid]" => "[zeek][smb_files][fuid]" } }
          mutate { id => "mutate_remove_zeek_smb_files_fuid"
                   remove_field => [ "[zeek][smb_files][fuid]" ] }
        }

        if ([zeek][smb_files][action]) { mutate { id => "mutate_gsub_zeek_smb_cmd_referenced_file_action"
                                                 gsub => [ "[zeek][smb_files][action]", "^SMB::", "" ] } }

      } # if ([zeek][smb_cmd][referenced_file])

    } # if ([zeek][smb_cmd])

    # this should now apply to either lines from smb_files.log or smb_cmd.referenced_file
    if ([zeek][smb_files]) {

      # translate Zeek's double-backslashes single backslash in filenames
      ruby {
        id => "ruby_zeek_smb_files_path_dedoubleslash"
        path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
        script_params => {
          "source" => "[zeek][smb_files][path]"
          "target" => "[zeek][smb_files][path]"
        }
      }
      ruby {
        id => "ruby_zeek_smb_files_name_dedoubleslash"
        path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
        script_params => {
          "source" => "[zeek][smb_files][name]"
          "target" => "[zeek][smb_files][name]"
        }
      }
      ruby {
        id => "ruby_zeek_smb_files_prev_name_dedoubleslash"
        path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
        script_params => {
          "source" => "[zeek][smb_files][prev_name]"
          "target" => "[zeek][smb_files][prev_name]"
        }
      }

      # store smb_files.name and/or smb_files.prev_name as smb.filename for Arkime
      if ([zeek][smb_files][name]) { mutate { id => "mutate_merge_zeek_smb_files_name_to_filename"
                                            merge => { "[smb][filename]" => "[zeek][smb_files][name]" } } }
      if ([zeek][smb_files][prev_name]) { mutate { id => "mutate_merge_zeek_smb_files_prev_name_to_filename"
                                                 merge => { "[smb][filename]" => "[zeek][smb_files][prev_name]" } } }

      # if we have smb_files.path, split into host/share/path
      if ([zeek][smb_files][path]) {
        ruby {
          id => "ruby_zeek_smb_files_path_split"
          path => "/usr/share/logstash/malcolm-ruby/smbsplit.rb"
          script_params => {
            "source" => "[zeek][smb_files][path]"
            "host" => "[smb][host]"
            "share" => "[smb][share]"
            "path" => "[@metadata][smb_files_path]"
          }
        }
      }

      # store appropriate filename in file.name
      if (![smb][filename]) and ([@metadata][smb_files_path]) {
        mutate { id => "mutate_merge_zeek_metadata_smb_files_path_file_name"
                  merge => { "[smb][filename]" => "[@metadata][smb_files_path]" } }
      }

    } # if ([zeek][smb_files])

  } else if ([log_source] == "smb_mapping") {
    #############################################################################################################################
    # smb_mapping.log specific logic

    if ([zeek][smb_mapping][path]) {
      # translate Zeek's double-backslashes single backslash in filenames
      ruby {
        id => "ruby_zeek_smb_mapping_path_dedoubleslash"
        path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
        script_params => {
          "source" => "[zeek][smb_mapping][path]"
          "target" => "[zeek][smb_mapping][path]"
        }
      }
    }

    if ([zeek][smb_mapping][path]) {
      ruby {
        id => "ruby_zeek_smb_mapping_path_split"
        path => "/usr/share/logstash/malcolm-ruby/smbsplit.rb"
        script_params => {
          "source" => "[zeek][smb_mapping][path]"
          "host" => "[smb][host]"
          "share" => "[smb][share]"
          "path" => "[smb][filename]"
        }
      }
    }

  } else if ([log_source] == "smtp") {
    #############################################################################################################################
    # smtp.log specific logic

    if ([zeek][smtp][user_agent]) {
      mutate { id => "mutate_merge_zeek_smtp_user_agent"
               merge => { "[email][useragent]" => "[zeek][smtp][user_agent]" } }
    }

    if ([zeek][smtp][from]) { mutate { id => "mutate_merge_zeek_smtp_from"
                                     merge => { "[email][src]" => "[zeek][smtp][from]" } } }
    if ([zeek][smtp][mailfrom]) { mutate { id => "mutate_merge_zeek_smtp_mailfrom"
                                         merge => { "[email][src]" => "[zeek][smtp][mailfrom]" } } }
    if ([zeek][smtp][reply_to]) { mutate { id => "mutate_merge_zeek_smtp_reply_to"
                                         merge => { "[email][src]" => "[zeek][smtp][reply_to]" } } }
    if ([zeek][smtp][to]) { mutate { id => "mutate_merge_zeek_smtp_dst_from_to"
                                   merge => { "[email][dst]" => "[zeek][smtp][to]" } } }
    if ([zeek][smtp][cc]) { mutate { id => "mutate_merge_zeek_smtp_dst_from_cc"
                                   merge => { "[email][dst]" => "[zeek][smtp][cc]" } } }
    if ([zeek][smtp][rcptto]) { mutate { id => "mutate_merge_zeek_dst_from_rcptto"
                                       merge => { "[email][dst]" => "[zeek][smtp][rcptto]" } } }
    if ([zeek][smtp][helo]) {
      mutate { id => "mutate_merge_zeek_smtp_helo"
               merge => { "[email][smtpHello]" => "[zeek][smtp][helo]" } }
    }
    if ([zeek][smtp][subject]) {
      mutate { id => "mutate_merge_zeek_smtp_subject"
               merge => { "[email][subject]" => "[zeek][smtp][subject]" } }
    }

    if ([zeek][smtp][msg_id]) {
      mutate { id => "mutate_gsub_zeek_smtp_msg_id"
               gsub => [ "[zeek][smtp][msg_id]", "(^<|>$)", "" ] }
      mutate { id => "mutate_merge_zeek_smtp_msg_id"
               merge => { "[email][id]" => "[zeek][smtp][msg_id]" } }
    }
    if ([zeek][smtp][in_reply_to]) {
      mutate { id => "mutate_gsub_zeek_smtp_in_reply_to"
               gsub => [ "[zeek][smtp][in_reply_to]", "(^<|>$)", "" ] }
      mutate { id => "mutate_merge_zeek_smtp_in_reply_to"
               merge => { "[email][id]" => "[zeek][smtp][in_reply_to]" } }
    }

    if ([zeek][smtp][last_reply]) {
      # will be mapped to a "result" later in normalization
      grok {
        id => "grok_zeek_zeek_smtp_last_reply"
        match => { "[zeek][smtp][last_reply]" => [ "^%{SPACE}%{NUMBER:[zeek][smtp][last_reply_code]}" ] }
      }
    }

  } else if ([log_source] == "ssh") {
    #############################################################################################################################
    # ssh.log specific logic

    if ([zeek][ssh][server]) { mutate { id => "mutate_merge_zeek_ssh_server_version"
                                       merge => { "[ssh][version]" => "[zeek][ssh][server]" } } }

    if ([zeek][ssh][client]) { mutate { id => "mutate_merge_zeek_client_version"
                                       merge => { "[ssh][version]" => "[zeek][ssh][client]" } } }

    if (![ssh][version]) and ([zeek][ssh][version]) { mutate { id => "mutate_merge_zeek_ssh_version"
                                                              merge => { "[ssh][version]" => "[zeek][ssh][version]" } } }

    if ([zeek][ssh][host_key] and [zeek][ssh][host_key_alg]) {
      # this is stupid, the %{} doesn't seem to be liked by mutate.merge
      mutate { id => "mutate_add_field_zeek_ssh_host_key"
               add_field => { "[@metadata][ssh_key_str]" => "%{[zeek][ssh][host_key_alg]} %{[zeek][ssh][host_key]}" } }
      mutate { id => "mutate_merge_zeek_ssh_key"
               merge => { "[ssh][key]" => "[@metadata][ssh_key_str]" } }
    }

    # HASSH stuff (see https://github.com/corelight/hassh)

    if ([zeek][ssh][hassh]) {
      mutate { id => "mutate_merge_zeek_ssh_hassh"
               merge => { "[ssh][hassh]" => "[zeek][ssh][hassh]" } }
    }

    if ([zeek][ssh][hasshServer]) {
      mutate { id => "mutate_merge_zeek_ssh_hasshServer"
               merge => { "[ssh][hasshServer]" => "[zeek][ssh][hasshServer]" } }
    }


  } else if ([log_source] == "ssl") {
    #############################################################################################################################
    # ssl.log specific logic

    # split subjects/issuers out into hashes
    # 1. handle escaped commans (urlencode)
    # 2. rename source hashes into metadata for splitting
    # 3. split fields by comma into destination hashes
    # 4. urldecode any commas we might have had

    if ([zeek][ssl][subject]) {
      mutate { id => "mutate_gsub_zeek_ssl_subject"
               gsub => [ "[zeek][ssl][subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_subject"
               rename => { "[zeek][ssl][subject]" => "[zeek][ssl][subject_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_subject"
        field_split => ","
        source => "[zeek][ssl][subject_full]"
        target => "[zeek][ssl][subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_subject"
        field => "[zeek][ssl][subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_subject_full"
        field => "[zeek][ssl][subject_full]"
      }
    }

    if ([zeek][ssl][client_subject]) {
      mutate { id => "mutate_gsub_zeek_ssl_client_subject"
               gsub => [ "[zeek][ssl][client_subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_client_subject"
               rename => { "[zeek][ssl][client_subject]" => "[zeek][ssl][client_subject_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_client_subject"
        field_split => ","
        source => "[zeek][ssl][client_subject_full]"
        target => "[zeek][ssl][client_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_subject"
        field => "[zeek][ssl][client_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_subject_full"
        field => "[zeek][ssl][client_subject_full]"
      }
    }

    if ([zeek][ssl][issuer]) {
      mutate { id => "mutate_gsub_zeek_ssl_issuer"
               gsub => [ "[zeek][ssl][issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_issuer"
               rename => { "[zeek][ssl][issuer]" => "[zeek][ssl][issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_issuer"
        field_split => ","
        source => "[zeek][ssl][issuer_full]"
        target => "[zeek][ssl][issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_issuer"
        field => "[zeek][ssl][issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_issuer_full"
        field => "[zeek][ssl][issuer_full]"
      }
    }

    if ([zeek][ssl][client_issuer]) {
      mutate { id => "mutate_gsub_zeek_ssl_client_issuer"
               gsub => [ "[zeek][ssl][client_issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_client_issuer"
               rename => { "[zeek][ssl][client_issuer]" => "[zeek][ssl][client_issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_client_issuer"
        field_split => ","
        source => "[zeek][ssl][client_issuer_full]"
        target => "[zeek][ssl][client_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_issuer"
        field => "[zeek][ssl][client_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_issuer_full"
        field => "[zeek][ssl][client_issuer_full]"
      }
    }

    if ([zeek][ssl][cipher]) {
      # ECS - zeek.ssl.cipher -> tls.cipher
      mutate { id => "mutate_merge_zeek_ssl_cipher"
               merge => { "[tls][cipher]" => "[zeek][ssl][cipher]" } }
    }

    if ([zeek][ssl][ja4]) {
      mutate { id => "mutate_merge_zeek_ssl_ja4"
               merge => { "[tls][ja4]" => "[zeek][ssl][ja4]" } }
    }

    if ([zeek][ssl][ja4s]) {
      mutate { id => "mutate_merge_zeek_ssl_ja4s"
               merge => { "[tls][ja4s]" => "[zeek][ssl][ja4s]" } }
    }

    if ([zeek][ssl][cert_chain_fps]) {
      # store certificate chain fingerprints in zeek_x509.fingerprint as well for cross-reference with x509.log
      mutate { id => "mutate_merge_zeek_ssl_cert_chain_fps"
               merge => { "[zeek][x509][fingerprint]" => "[zeek][ssl][cert_chain_fps]" } }
      # TODO: zeek.ssl.*cert_chain_fps to:
      #       https://www.elastic.co/guide/en/ecs/current/ecs-tls.html#field-tls-client-hash-md5 (or sha1, sha256, etc.)
      #       https://www.elastic.co/guide/en/ecs/current/ecs-tls.html#field-tls-server-hash-md5 (or sha1, sha256, etc.)
    }

    if ([zeek][ssl][client_cert_chain_fps]) {
      # store certificate chain fingerprints in zeek_x509.fingerprint as well for cross-reference with x509.log
      mutate { id => "mutate_merge_zeek_ssl_client_cert_chain_fps"
               merge => { "[zeek][x509][fingerprint]" => "[zeek][ssl][client_cert_chain_fps]" } }
    }

    # ECS - zeek.ssl.ssl_version -> tls.version and tls.version_protocol
    if ([zeek][ssl][ssl_version]) {
      # turn TLSv10, TLSv13, TSLv12, etc. to 'tls' and '1.2', etc.
      ruby {
        id => "ruby_ecs_ssl_version_parse"
        code => "
          verMatch = event.get('[zeek][ssl][ssl_version]').tr('.', '').match(/(.+)\s*[v-]\s*([\d\.]+)/i)
          verParts = verMatch.nil? ? nil : verMatch.captures
          unless verParts.nil?
            event.set('[tls][version_protocol]', verParts[0].downcase)
            event.set('[tls][version]', verParts[1].split(//).join('.'))
          end
        "
      }
    }

    # ECS - zeek.ssl.established -> tls.established
    if ([zeek][ssl][established]) {          mutate { id => "mutate_add_field_ecs_zeek_tls_established"
                                                     add_field => { "[tls][established]" => "%{[zeek][ssl][established]}" } } }

    # ECS - zeek.ssl.resumed -> tls.resumed
    if ([zeek][ssl][resumed]) {              mutate { id => "mutate_add_field_ecs_zeek_tls_resumed"
                                                     add_field => { "[tls][resumed]" => "%{[zeek][ssl][resumed]}" } } }

    # ECS - zeek.ssl.next_protocol -> tls.next_protocol
    if ([zeek][ssl][next_protocol]) {
      mutate { id => "mutate_add_field_ecs_zeek_tls_next_protocol"
                     add_field => { "[tls][next_protocol]" => "%{[zeek][ssl][next_protocol]}" } }
      mutate { id => "mutate_lowercase_field_ecs_zeek_tls_next_protocol"
               lowercase => [ "[tls][next_protocol]" ] }
    }

    # ECS - zeek.ssl.curve -> tls.curve
    if ([zeek][ssl][curve]) {                mutate { id => "mutate_add_field_ecs_zeek_tls_client_curve"
                                                     add_field => { "[tls][curve]" => "%{[zeek][ssl][curve]}" } } }

    # ECS - zeek.ssl.ja4 -> tls.client.ja4
    if ([zeek][ssl][ja4]) {                  mutate { id => "mutate_rename_ecs_zeek_tls_client_ja4"
                                                      rename => { "[zeek][ssl][ja4]" => "[tls][client][ja4]" } } }

    # ECS - zeek.ssl.client_issuer_full -> tls.client.issuer
    if ([zeek][ssl][client_issuer_full]) {   mutate { id => "mutate_add_field_ecs_zeek_tls_client_issuer_full"
                                                     add_field => { "[tls][client][issuer]" => "%{[zeek][ssl][client_issuer_full]}" } } }

    # ECS - zeek.ssl.client_subject_full -> tls.client.subject
    if ([zeek][ssl][client_subject_full]) {  mutate { id => "mutate_add_field_ecs_zeek_tls_client_subject_full"
                                                     add_field => { "[tls][client][subject]" => "%{[zeek][ssl][client_subject_full]}" } } }

    # ECS - zeek.ssl.server_name -> tls.client.server_name and server.domain
    if ([zeek][ssl][server_name]) {
      mutate { id => "mutate_add_field_ecs_zeek_tls_client_server_name"
               add_field => { "[tls][client][server_name]" => "%{[zeek][ssl][server_name]}" } }
      mutate { id => "mutate_add_field_ecs_zeek_tls_client_server_name_destination_domain"
               add_field => { "[server][domain]" => "%{[zeek][ssl][server_name]}" } }
    }

    # ECS - zeek.ssl.issuer_full -> tls.server.issuer
    if ([zeek][ssl][issuer_full]) {          mutate { id => "mutate_add_field_ecs_zeek_tls_issuer_full"
                                                     add_field => { "[tls][server][issuer]" => "%{[zeek][ssl][issuer_full]}" } } }

    # ECS - zeek.ssl.ja4s -> tls.server.ja4s
    if ([zeek][ssl][ja4s]) {                 mutate { id => "mutate_rename_field_ecs_zeek_tls_server_ja4s"
                                                      rename => { "[zeek][ssl][ja4s]" => "[tls][server][ja4s]" } } }

    # ECS - zeek.ssl.subject_full -> tls.server.subject
    if ([zeek][ssl][subject_full]) {         mutate { id => "mutate_add_field_ecs_zeek_tls_subject_full"
                                                     add_field => { "[tls][server][subject]" => "%{[zeek][ssl][subject_full]}" } } }

  } else if ([log_source] == "stun_nat") {
    #############################################################################################################################
    # stun_nat.log specific logic

    # ECS - zeek.stun_nat.wan_addr -> source.nat.ip
    if ([zeek][stun_nat][wan_addr]) {    mutate { id => "mutate_add_field_ecs_zeek_stun_nat_wan_addr"
                                                  add_field => { "[source][nat][ip]" => "%{[zeek][stun_nat][wan_addr]}" } } }

    # ECS - zeek.stun_nat.wan_port -> source.nat.port
    if ([zeek][stun_nat][wan_port]) {    mutate { id => "mutate_add_field_ecs_zeek_stun_nat_wan_port"
                                                  add_field => { "[source][nat][port]" => "%{[zeek][stun_nat][wan_port]}" } } }

  } else if ([log_source] =~ /^synchrophasor/) {

    mutate {
      id => "mutate_rename_synchrophasor_fields"
      rename => { "[zeek][synchrophasor_cfg][data_rate]" => "[zeek][synchrophasor][data_rate]" }
      rename => { "[zeek][synchrophasor_cfg][frame_size]" => "[zeek][synchrophasor][frame_size]" }
      rename => { "[zeek][synchrophasor_cfg][frame_type]" => "[zeek][synchrophasor][frame_type]" }
      rename => { "[zeek][synchrophasor_cfg][header_time_stamp]" => "[zeek][synchrophasor][header_time_stamp]" }
      rename => { "[zeek][synchrophasor_cfg_detail][frame_type]" => "[zeek][synchrophasor][frame_type]" }
      rename => { "[zeek][synchrophasor_cfg_detail][header_time_stamp]" => "[zeek][synchrophasor][header_time_stamp]" }
      rename => { "[zeek][synchrophasor_cmd][frame_size]" => "[zeek][synchrophasor][frame_size]" }
      rename => { "[zeek][synchrophasor_cmd][frame_type]" => "[zeek][synchrophasor][frame_type]" }
      rename => { "[zeek][synchrophasor_cmd][header_time_stamp]" => "[zeek][synchrophasor][header_time_stamp]" }
      rename => { "[zeek][synchrophasor_data][frame_size]" => "[zeek][synchrophasor][frame_size]" }
      rename => { "[zeek][synchrophasor_data][frame_type]" => "[zeek][synchrophasor][frame_type]" }
      rename => { "[zeek][synchrophasor_data][header_time_stamp]" => "[zeek][synchrophasor][header_time_stamp]" }
      rename => { "[zeek][synchrophasor_data_detail][frame_type]" => "[zeek][synchrophasor][frame_type]" }
      rename => { "[zeek][synchrophasor_data_detail][header_time_stamp]" => "[zeek][synchrophasor][header_time_stamp]" }
      rename => { "[zeek][synchrophasor_hdr][frame_size]" => "[zeek][synchrophasor][frame_size]" }
      rename => { "[zeek][synchrophasor_hdr][frame_type]" => "[zeek][synchrophasor][frame_type]" }
      rename => { "[zeek][synchrophasor_hdr][header_time_stamp]" => "[zeek][synchrophasor][header_time_stamp]" }
    }

    if ("_jsonparsesuccess" not in [tags]) {
      mutate {
        id => "mutate_split_synchrophasor_fields"
        split => { "[zeek][synchrophasor_cfg_detail][analog_conv_analog_flags]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][analog_conv_mag_scale]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][analog_conv_offset]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][analog_conv_user_defined_scaling]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][annam]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][dgnam]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][digital_conv_normal_status_mask]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][digital_conv_valid_inputs_mask]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_angle_adj]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_calibration_mag_adj]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_calibration_phas_adj]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_downsampled_fir_filter]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_downsampled_no_fir_filter]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_downsampled_reselection]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_filtered_without_changing_sampling]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_mod_appl]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_phasor_component]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_phasor_type]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_phunit]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_phvalue]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_pseudo_phasor_val]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_rotation_phase_adj]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_scale_factor]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_upsampled_extrapolation]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_upsampled_interpolation]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_user_def]" => "," }
        split => { "[zeek][synchrophasor_cfg_detail][phnam]" => "," }
        split => { "[zeek][synchrophasor_cmd][extframe]" => "," }
        split => { "[zeek][synchrophasor_data_detail][analog_data]" => "," }
        split => { "[zeek][synchrophasor_data_detail][digital]" => "," }
        split => { "[zeek][synchrophasor_data_detail][est_polar_angle]" => "," }
        split => { "[zeek][synchrophasor_data_detail][est_polar_magnitude]" => "," }
        split => { "[zeek][synchrophasor_data_detail][est_rectangular_imaginary]" => "," }
        split => { "[zeek][synchrophasor_data_detail][est_rectangular_real]" => "," }
      }
    }

    if ([zeek][synchrophasor][frame_size]) {
      mutate { id => "mutate_add_field_totDataBytes_zeek_synchrophasor_frame_size"
               add_field => { "[totDataBytes]" => "%{[zeek][synchrophasor][frame_size]}" } }
    }
    if ([zeek][synchrophasor][frame_size_tot]) {
      mutate { id => "mutate_add_field_totDataBytes_zeek_synchrophasor_frame_size_tot"
               add_field => { "[totDataBytes]" => "%{[zeek][synchrophasor][frame_size_tot]}" } }
    }

  } else if ([log_source] == "tds_rpc") {
    #############################################################################################################################
    # tds_rpc.log specific logic

    if ([zeek][tds_rpc][parameter]) {
      ruby {
        id => "ruby_zeek_tds_rpc_parse_parameter"
        code => "
          params = event.get('[zeek][tds_rpc][parameter]')
          if !params.is_a?(Array) then
            params = params.to_s.split(',')
          end
          parameterHash = params.each_with_object({}) do |a, hash|
            key,value = a.split(/\s*=\s*/)
            hash[key.to_s.delete_prefix('@')] = value
          end
          parameterHash = parameterHash.reject{|k,v| k.nil? || v.nil? || k.empty? || v.empty?}
          event.set('[zeek][tds_rpc][parameters]', parameterHash) unless parameterHash.empty?
        "
      }
      if ("_jsonparsesuccess" not in [tags]) {
        mutate { id => "mutate_split_field_tds_rpc_parameter"
                 split => { "[zeek][tds_rpc][parameter]" => "," } }
      }
    }

  } else if ([log_source] == "weird") {
    #############################################################################################################################
    # weird.log specific logic

    if ([zeek][weird][name]) {
      # ECS - "Zeek" -> rule.author
      mutate { id => "mutate_add_field_ecs_rule_author_zeek_weird"
               add_field => { "[rule][author]" => "Zeek" } }
      # ECS - zeek weird URL -> rule.reference
      mutate { id => "mutate_add_field_ecs_rule_reference_zeek_weird"
               add_field => { "[rule][reference]" => "https://docs.zeek.org/en/current/scripts/base/frameworks/notice/weird.zeek.html" } }
      # ECS - zeek.weird.name -> rule.name
      ruby { id => "ruby_add_field_ecs_zeek_rule_name_weird_name"
             code => "event.set('[rule][name]', [ event.get('[zeek][weird][name]'), event.get('[rule][name]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
    }

    ruby {
      id => "ruby_add_field_zeek_weird_event_original"
      code => " event.set('[event][original]', [event.get('[zeek][weird][name]'),
                                                event.get('[zeek][weird][addl]')].reject{ |e| e.nil? || e&.empty? }.join(':'))" }

    # remove signature fields that were mapped to ECS or not useful
    mutate { id => "mutate_remove_fields_zeek_weird"
             remove_field => [
              "[zeek][weird][name]",
              "[zeek][weird][peer]" ] }

  } else if ([log_source] == "x509") {
    #############################################################################################################################
    # x509.log specific logic

    # split subject/issuer out into hashes
    # 1. handle escaped commans (urlencode)
    # 2. rename source hashes into metadata for splitting
    # 3. split fields by comma into destination hashes
    # 4. urldecode any commas we might have had

    if ([zeek][x509][certificate_subject]) {
      mutate { id => "mutate_gsub_zeek_x509_certificate_subject"
               gsub => [ "[zeek][x509][certificate_subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_x509_certificate_subject"
               rename => { "[zeek][x509][certificate_subject]" => "[zeek][x509][certificate_subject_full]" } }
      kv {
        id => "mutate_kv_zeek_x509_certificate_subject"
        field_split => ","
        source => "[zeek][x509][certificate_subject_full]"
        target => "[zeek][x509][certificate_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_subject"
        field => "[zeek][x509][certificate_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_subject_full"
        field => "[zeek][x509][certificate_subject_full]"
      }
      if ([zeek][x509][certificate_subject][CN]) {
        mutate { id => "mutate_merge_zeek_x509_certificate_subject_CN"
                 merge => { "[@metadata][cert][subjectCN]" => "[zeek][x509][certificate_subject][CN]" } }
      }
      if ([zeek][x509][certificate_subject][O]) {
        mutate { id => "mutate_add_zeek_x509_certificate_subject_O"
                 add_field => { "[@metadata][cert][subjectON]" => "%{[zeek][x509][certificate_subject][O]}" } }
      }
    }

    if ([zeek][x509][certificate_issuer]) {
      mutate { id => "mutate_gsub_zeek_x509_certificate_issuer"
               gsub => [ "[zeek][x509][certificate_issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_x509_certificate_issuer"
               rename => { "[zeek][x509][certificate_issuer]" => "[zeek][x509][certificate_issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_x509_certificate_issuer"
        field_split => ","
        source => "[zeek][x509][certificate_issuer_full]"
        target => "[zeek][x509][certificate_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_issuer"
        field => "[zeek][x509][certificate_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_issuer_full"
        field => "[zeek][x509][certificate_issuer_full]"
      }
      if ([zeek][x509][certificate_issuer][CN]) {
        mutate { id => "mutate_merge_zeek_x509_certificate_issuer_CN"
                 merge => { "[@metadata][cert][issuerCN]" => "[zeek][x509][certificate_issuer][CN]" } }
      }
      if ([zeek][x509][certificate_issuer][O]) {
        mutate { id => "mutate_add_zeek_x509_certificate_issuer_O"
                 add_field => { "[@metadata][cert][issuerON]" => "%{[zeek][x509][certificate_issuer][O]}" } }
      }
    }

    if ([zeek][x509][certificate_not_valid_before]) and ([zeek][x509][certificate_not_valid_after]) {
      ruby {
        id => "ruby_zeek_x509_valid_range"
        code => "event.set('[@metadata][cert][notBefore]', (1000*event.get('[zeek][x509][certificate_not_valid_before]').to_f).round(0))
                 event.set('[@metadata][cert][notAfter]', (1000*event.get('[zeek][x509][certificate_not_valid_after]').to_f).round(0))
                 event.set('[@metadata][cert][validDays]', ((event.get('[zeek][x509][certificate_not_valid_after]').to_f - event.get('[zeek][x509][certificate_not_valid_before]').to_f)/(24.0*60.0*60.0)).round(0))"
      }
      mutate {
        id => "mutate_convert_zeek_x509_time_range"
        convert => {
          "[@metadata][cert][notBefore]" => "integer"
          "[@metadata][cert][notAfter]" => "integer"
          "[@metadata][cert][validDays]" => "float"
        }
      }
    }

    if ([zeek][x509][certificate_serial]) {
      # todo: serial not showing up right...
      # ruby {
      #  id => "ruby_zeek_x509_serial"
      #  code => "event.set('[@metadata][cert][serial]', event.get('[certificate_serial]').unpack('C*').map {|e| e.to_s 16}.join(':'))"
      # }
      mutate { id => "mutate_add_field_zeek_x509_serial"
               add_field => { "[@metadata][cert][serial]" => "%{[zeek][x509][certificate_serial]}" } }
    }

    if ([@metadata][cert]) {
      ruby {
          id => "ruby_zeek_x509_cert_array_set"
          code => "
              certArray = Array.new
              certArray.push(event.get('[@metadata][cert]'))
              event.set('[cert]', certArray)"
      }
    }

    # TODO: ECS TLS/X509 nestings?
    # - https://www.elastic.co/guide/en/ecs/current/ecs-tls.html#ecs-tls-nestings
    # - https://www.elastic.co/guide/en/ecs/current/ecs-x509.html#_field_reuse_27

  } # end if/else if/else for specific log type logic
  #######################################################################################################

  # rename log_source (eg., conn, ssh, etc.) to event.dataset
  mutate { id => "mutate_rename_zeek_logType"
           rename => { "[log_source]" => "[event][dataset]" } }

  # kind of a unique case, smb_cmd can also be smb_files
  if ([zeek][smb_files]) {

    if ([event][dataset] == "smb_cmd") {
      ruby { id => "ruby_add_field_zeek_tmp_logtype_smb_cmd"
             code => "event.set('[event][dataset]', [ 'smb_files', event.get('[event][dataset]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
    }

    # ECS - zeek.smb_files.times_created -> file.created
    # ECS - zeek.smb_files.times_accessed -> file.accessed
    # ECS - zeek.smb_files.times_changed -> file.ctime
    # ECS - zeek.smb_files.times_modified -> file.mtime
    # ECS - zeek.smb_files.size -> file.size
    if ([zeek][smb_files][times_created]) {   mutate { id => "mutate_add_field_ecs_smb_created"
                                                      add_field => { "[file][created]" => "%{[zeek][smb_files][times_created]}" } } }

    if ([zeek][smb_files][times_accessed]) {  mutate { id => "mutate_add_field_ecs_smb_accessed"
                                                      add_field => { "[file][accessed]" => "%{[zeek][smb_files][times_accessed]}" } } }

    if ([zeek][smb_files][times_changed]) {   mutate { id => "mutate_add_field_ecs_smb_changed"
                                                      add_field => { "[file][ctime]" => "%{[zeek][smb_files][times_changed]}" } } }

    if ([zeek][smb_files][times_modified]) {  mutate { id => "mutate_add_field_ecs_smb_modified"
                                                      add_field => { "[file][mtime]" => "%{[zeek][smb_files][times_modified]}" } } }

    if ([zeek][smb_files][size]) {            mutate { id => "mutate_add_field_ecs_smb_size"
                                                      add_field => { "[file][size]" => "%{[zeek][smb_files][size]}" } } }

  } # end if ([zeek][smb_files])

  # ECS - event.kind based on event.dataset (https://www.elastic.co/guide/en/ecs/current/ecs-allowed-values-event-kind.html)
  if ([zeek][notice]) or ([zeek][signatures]) or ([zeek][weird]) {
    mutate { id => "mutate_add_field_ecs_event_kind_alert"
             add_field => { "[event][kind]" => "alert" } }
  } else if ("_zeekdiagnostic" in [tags]) and ([zeek][stats]) {
    mutate { id => "mutate_add_field_ecs_event_kind_metric"
             add_field => { "[event][kind]" => "metric" } }
  } else {
    mutate { id => "mutate_add_field_ecs_event_kind_event"
             add_field => { "[event][kind]" => "event" } }
  }

} # end Filter
