# Copyright (c) 2023 Battelle Energy Alliance, LLC.  All rights reserved.

filter {

  if ([zeek_cols]) {
    # remove unset (-) or "(empty)" top-level field values
    ruby {
      id => "ruby_zeek_remove_empty_values"
      path => "/usr/share/logstash/malcolm-ruby/compact_event.rb"
    }
  } else {
    drop { id => "drop_dissect_error" }
  }

  # ECS - "zeek" -> event.provider
  if (![event][provider]) { mutate { id => "mutate_add_field_event_provider_zeek"
                                     add_field => { "[event][provider]" => "zeek" } } }

  # rename the zeek child array to match the log type
  mutate { id => "mutate_rename_zeek_log_type"
           rename => { "[zeek_cols]" => "[zeek][%{[log_source]}]" } }

  # move "up" some fields that are considered to be "multi-log" fields (eg., they
  # show up in many types of logs)
  mutate {
    id => "mutate_rename_zeek_common_fields"
    rename => { "[zeek][%{[log_source]}][ts]"              => "[zeek][ts]" }
    rename => { "[zeek][%{[log_source]}][uid]"             => "[zeek][uid]" }
    rename => { "[zeek][%{[log_source]}][fuid]"            => "[zeek][fuid]" }
    rename => { "[zeek][%{[log_source]}][is_orig]"         => "[network][is_orig]" }
    rename => { "[zeek][%{[log_source]}][orig_h]"          => "[source][ip]" }
    rename => { "[zeek][%{[log_source]}][orig_p]"          => "[source][port]" }
    rename => { "[zeek][%{[log_source]}][orig_l2_addr]"    => "[source][mac]" }
    rename => { "[zeek][%{[log_source]}][resp_h]"          => "[destination][ip]" }
    rename => { "[zeek][%{[log_source]}][resp_p]"          => "[destination][port]" }
    rename => { "[zeek][%{[log_source]}][resp_l2_addr]"    => "[destination][mac]" }
    rename => { "[zeek][%{[log_source]}][proto]"           => "[network][transport]" }
    rename => { "[zeek][%{[log_source]}][service]"         => "[network][protocol]" }
    rename => { "[zeek][%{[log_source]}][user]"            => "[related][user]" }
    rename => { "[zeek][%{[log_source]}][password]"        => "[related][password]" }
    rename => { "[zeek][%{[log_source]}][community_id]"    => "[network][community_id]" }
  }

  # we'll just save the "true" source and destination fields.
  #   see, for example, https://github.com/cisagov/icsnpp-bacnet#source-and-destination-fields
  mutate { id => "mutate_remove_zeek_common_fields"
           remove_field => [
            "[zeek][%{[log_source]}][drop_orig_h]",
            "[zeek][%{[log_source]}][drop_orig_p]",
            "[zeek][%{[log_source]}][drop_resp_h]",
            "[zeek][%{[log_source]}][drop_resp_p]" ] }

  # create a repeatable fingerprint for document ID
  fingerprint {
    id => "fingerprint_zeek_event_hash"
    source => [ "[event][provider]",
                "[log_source]",
                "[zeek][ts]",
                "[network][community_id]",
                "[zeek][uid]",
                "[zeek][fuid]",
                "[log][offset]" ]
    concatenate_sources => true
    # uses event.hash
    ecs_compatibility => "v8"
    method => "MURMUR3_128"
    base64encode => true
  }

  if ([source][mac]) {
    mutate { id => "mutate_split_zeek_source_mac"
             split => { "[source][mac]" => "," } }
  }

  if ([destination][mac]) {
    mutate { id => "mutate_split_zeek_destination_mac"
             split => { "[destination][mac]" => "," } }
  }

  if ([zeek][uid]) {
    # set zeek connection UID as "rootId" (see logstash.conf output section)
    if (![rootId]) { mutate { id => "mutate_add_field_zeek_rootId"
                              add_field => { "[rootId]" => "%{[zeek][uid]}" } } }

    # ECS - zeek.uid -> event.id
    mutate { id => "mutate_add_field_ecs_id_uid"
             merge => { "[event][id]" => "[zeek][uid]" } }
  }

  # if present, FUIDs are always a vector (comma-separated)
  if ([zeek][fuid]) { mutate { id => "mutate_split_zeek_fuids"
                               split => { "[zeek][fuid]" => "," } } }

  if ([zeek][ts]) {

    if ([zeek][ts] == "0.000000") {
      # missing packet timestamp, set to "now." not sure what a better option would be
      ruby {
        id => "ruby_zeek_empty_timestamp_set"
        init => "require 'time'"
        code => "event.set('[zeek][ts]', Time.now.to_f)"
      }
      mutate { id => "tag_zeek_empty_timestamp_set"
               add_tag => [ "_missing_timestamp" ] }
    }

    # set firstPacket to timestamp, lastPacket to timestamp + duration
    # timestamp, firstPacket, lastPacket are UNIX epoch milliseconds
    ruby {
      id => "ruby_zeek_timestamp_calc"
      init => "require 'time'"
      code => "msTime = (1000*event.get('[zeek][ts]').to_f).round(0)
               event.set('[timestamp]', msTime)
               event.set('[@timestamp]', LogStash::Timestamp.at(Time.strptime(msTime.to_s, '%Q')))
               event.set('[firstPacket]', msTime)"
    }

    if ([zeek][conn]) and ([zeek][conn][duration]) {
      # convert duration (floating-point seconds) to milliseconds
      ruby {
        id => "ruby_zeek_duration_calc"
        code => "event.set('[length]', (1000*event.get('[zeek][conn][duration]').to_f).round(0))
                 event.set('[lastPacket]', event.get('[timestamp]').to_i + event.get('[length]').to_i)"
      }
      # ECS - zeek.conn.duration -> event.duration
      ruby {
        id => "ruby_zeek_duration_to_ecs_event_duration"
        code => "event.set('[event][duration]', (1000000000 * event.get('[zeek][conn][duration]').to_f).round(0))"
      }
    } else {
      mutate { id => "mutate_add_field_zeek_lastPacket"
               add_field => { "[lastPacket]" => "%{timestamp}" } }
      mutate { id => "mutate_add_field_zeek_length"
               add_field => { "[length]" => "0" } }
    }

    # set the ts back as something more readable
    mutate { id => "mutate_replace_zeek_ts"
             replace => { "[zeek][ts]" => "%{[@timestamp]}" } }
  } # if ([zeek][ts])

  # set user and transport- and application-level protocols if specified
  if ([related][user]) {
    mutate { id => "mutate_split_related_user"
             split => { "[related][user]" => "," } }
  }
  if ([network][transport]) {
    translate {
      id => "translate_zeek_proto"
      source => "[network][transport]"
      target => "[ipProtocol]"
      dictionary_path => "/etc/ip_protocol_name_to_number.yaml"
    }
    mutate { id => "mutate_split_zeek_proto"
             split => { "[network][transport]" => "," } }
    mutate { id => "mutate_merge_zeek_proto"
             merge => { "[protocol]" => "[network][transport]" } }
  }

  if ([network][protocol]) {
    mutate { id => "mutate_split_zeek_service"
             split => { "[network][protocol]" => "," } }
  }

  if ([log_source] == "conn") {
    #############################################################################################################################
    # conn.log specific logic

    translate {
      id => "translate_zeek_conn_state"
      source => "[zeek][conn][conn_state]"
      target => "[zeek][conn][conn_state_description]"
      dictionary_path => "/etc/conn_states.yaml"
      # TODO: can we normalize this with suricata.flow.state somewhere?
    }

    mutate { id => "mutate_split_zeek_conn_tunnel_parents"
             split => { "[zeek][conn][tunnel_parents]" => "," } }

    if ([zeek][conn][vlan] or [zeek][conn][inner_vlan]) {
      # ECS - zeek.conn.vlan -> network.vlan.id
      if ([zeek][conn][vlan]) {
        mutate { id => "mutate_merge_zeek_conn_vlan"
                 merge => { "[network][vlan][id]" => "[zeek][conn][vlan]" } }
      }
      if ([zeek][conn][inner_vlan]) {
        # ECS - zeek.conn.inner_vlan -> network.inner.vlan.id
        mutate { id => "mutate_merge_zeek_conn_inner_vlan"
                 merge => { "[network][inner][vlan][id]" => "[zeek][conn][inner_vlan]" } }
      }
    }

    # aggregate total bytes and packets
    ruby {
      id => "ruby_zeek_bytes_and_packets_calc"
      code => "event.set('[totDataBytes]', event.get('[client][bytes]').to_i + event.get('[server][bytes]').to_i)
               event.set('[network][bytes]', event.get('[source][bytes]').to_i + event.get('[destination][bytes]').to_i)
               event.set('[network][packets]', event.get('[source][packets]').to_i + event.get('[destination][packets]').to_i)"
    }

    if ([zeek][conn][history]) {
      ruby {
        id => "ruby_zeek_conn_history"
        # see https://www.zeek.org/sphinx/scripts/base/protocols/conn/main.bro.html#type-Conn::Info
        code => "historyStr = event.get('[zeek][conn][history]').upcase
                 sCnt = [historyStr.count('S'), 19].min
                 hCnt = [historyStr.count('H'), 19].min
                 aCnt = [historyStr.count('A'), 19].min
                 fCnt = [historyStr.count('F'), 19].min
                 rCnt = [historyStr.count('R'), 19].min
                 event.set('[tcpflags][syn]',     10**(sCnt-1)) if sCnt > 0
                 event.set('[tcpflags][syn-ack]', 10**(hCnt-1)) if hCnt > 0
                 event.set('[tcpflags][ack]',     10**(aCnt-1)) if aCnt > 0
                 event.set('[tcpflags][fin]',     10**(fCnt-1)) if fCnt > 0
                 event.set('[tcpflags][rst]',     10**(rCnt-1)) if rCnt > 0"
      }
    }

  } else if ([log_source] =~ /^bacnet/) {

    if ([log_source] == "bacnet_discovery") {
      #############################################################################################################################
      # bacnet_discovery.log specific logic

      # bacnet_discovery.range ccan be split into a min/max (All, 12345-12350, etc.)
      if ([zeek][bacnet_discovery][range]) {
        if ([zeek][bacnet_discovery][range] == "All") {
          mutate { id => "mutate_add_field_zeek_bacnet_discovery_range_low"
                   add_field => { "[zeek][bacnet_discovery][range_low]" => "0" } }
          mutate { id => "mutate_add_field_zeek_bacnet_discovery_range_high"
                   add_field => { "[zeek][bacnet_discovery][range_high]" => "4194300" } }
        } else if ([zeek][bacnet_discovery][range] =~ "^\d+-\d+$") {
          ruby {
            id => "ruby_bacnet_discovery_range_split"
            code => "
              if (bacnetRange = event.get('[zeek][bacnet_discovery][range]').split('-')) and (bacnetRange.length == 2) then
                event.set('[zeek][bacnet_discovery][range_low]', bacnetRange[0])
                event.set('[zeek][bacnet_discovery][range_high]', bacnetRange[1])
              end"
          }
        }
      }
    }

    mutate {
      id => "mutate_rename_bacnet_fields"
      rename => { "[zeek][bacnet_device_control][invoke_id]" => "[zeek][bacnet][invoke_id]" }
      rename => { "[zeek][bacnet_property][invoke_id]" => "[zeek][bacnet][invoke_id]" }
      rename => { "[zeek][bacnet_discovery][instance_number]" => "[zeek][bacnet][instance_number]" }
      rename => { "[zeek][bacnet_property][instance_number]" => "[zeek][bacnet][instance_number]" }
    }

  } else if ([log_source] == "bsap_ip_rdb") {
    #############################################################################################################################
    # bsap_ip_rdb.log specific logic

    ruby {
      id => "ruby_bsap_ip_rdb_variables"
      init => "$bsap_ip_rdb_fields = [ :var, :val ]"
      code => "
        vars = event.get('[zeek][bsap_ip_rdb][variables]').to_s.split(',').zip(
                    event.get('[zeek][bsap_ip_rdb][variable_value]').to_s.split(',')).map{ |x| $bsap_ip_rdb_fields.zip(x).to_h }
        event.set('[zeek][bsap_ip_rdb][variables]', vars)
        event.set('[zeek][bsap_ip_rdb][variable_count]', vars.length)
      "
    }
    mutate { id => "mutate_remove_field_zeek_bsap_ip_rdb_variable_value"
             remove_field => [ "[zeek][bsap_ip_rdb][variable_value]",
                               "[zeek][bsap_ip_rdb][data_len]" ] }


  } else if ([log_source] == "bsap_serial_rdb") {
    #############################################################################################################################
    # bsap_serial_rdb.log specific logic

    ruby {
      id => "ruby_bsap_serial_rdb_variables"
      init => "$bsap_serial_rdb_fields = [ :var, :val ]"
      code => "
        vars = event.get('[zeek][bsap_serial_rdb][variables]').to_s.split(',').zip(
                    event.get('[zeek][bsap_serial_rdb][variable_value]').to_s.split(',')).map{ |x| $bsap_serial_rdb_fields.zip(x).to_h }
        event.set('[zeek][bsap_serial_rdb][variables]', vars)
        event.set('[zeek][bsap_serial_rdb][variable_count]', vars.length)
      "
    }
    mutate { id => "mutate_remove_field_zeek_bsap_serial_rdb_variable_value"
             remove_field => [ "[zeek][bsap_serial_rdb][variable_value]",
                               "[zeek][bsap_serial_rdb][data_len]" ] }


  } else if ([log_source] == "cip_identity") {
    #############################################################################################################################
    # cip_identity.log specific logic

    if ([zeek][cip_identity][socket_address]) {

      # if this is a zeek_cip_identity record with socket_address, ASN/GeoIP it as well
      geoip {
        id => "geoip_zeek_cip_identity_socket_address"
        default_database_type => "ASN"
        source => "[zeek][cip_identity][socket_address]"
        target => "[@metadata][zeek_cip_identity_asn]"
      }
      if ([@metadata][zeek_cip_identity_asn] and [@metadata][zeek_cip_identity_asn][as_org] and [@metadata][zeek_cip_identity_asn][asn]) {
        # this is stupid, the %{} doesn't seem to be liked by mutate.merge
        mutate { id => "mutate_add_field_zeek_cip_identity_asn"
                 add_field => { "[@metadata][cip_asn_str]" => "AS%{[@metadata][zeek_cip_identity_asn][asn]} %{[@metadata][zeek_cip_identity_asn][as_org]}" } }
        mutate { id => "mutate_merge_zeek_cip_identity_asn"
                 merge => { "[zeek][cip_identity][socket_address_asn]" => "[@metadata][cip_asn_str]" } }
      }
      geoip {
        id => "geoip_zeek_cip_identity_socket_address_geo"
        source => "[zeek][cip_identity][socket_address]"
        target => "[zeek][cip_identity][socket_address_geo]"
      }

    }

  } else if ([log_source] == "dhcp") {
    #############################################################################################################################
    # dhcp.log specific logic

    if ([source][mac]) {
      mutate {
        id => "mutate_add_fields_zeek_dhcp_mac"
        add_field =>  { "[zeek][dhcp][mac]" => "%{[source][mac]}" }
      }
      mutate { id => "mutate_merge_zeek_dhcp_mac"
               merge => { "[dhcp][mac]" => "[source][mac]" } }
    }

    if ([zeek][dhcp][msg_types]) {
      mutate { id => "mutate_split_zeek_dhcp_msg_types"
                 split => { "[zeek][dhcp][msg_types]" => "," } }
      ruby {
        id => "ruby_zeek_dhcp_msg_types"
        path => "/usr/share/logstash/malcolm-ruby/make_unique_array.rb"
        script_params => {
          "field" => "[zeek][dhcp][msg_types]"
        }
      }
      mutate { id => "mutate_merge_zeek_dhcp_type"
               merge => { "[dhcp][type]" => "[zeek][dhcp][msg_types]" } }
    }

    if ([zeek][dhcp][trans_id]) {
      mutate { id => "mutate_merge_zeek_dhcp_id"
               merge => { "[dhcp][id]" => "[zeek][dhcp][trans_id]" } }
    }

    if ([zeek][dhcp][host_name]) {
      mutate { id => "mutate_merge_zeek_dhcp_host_name"
               merge => { "[dhcp][host]" => "[zeek][dhcp][host_name]" } }

      # ECS - zeek.dhcp.host_name -> client.domain
      mutate { id => "mutate_add_field_ecs_client_domain_dhcp_host_name"
               add_field => { "[client][domain]" => "%{[zeek][dhcp][host_name]}" } }
    }

    if ([zeek][dhcp][domain]) {
      # ECS - zeek.dhcp.domain -> client.domain
      mutate { id => "mutate_add_field_ecs_client_domain_dhcp_domain"
               add_field => { "[client][domain]" => "%{[zeek][dhcp][domain]}" } }
    }

    if ([zeek][dhcp][client_fqdn]) {
      # ECS - zeek.dhcp.client_fqdn -> client.domain
      mutate { id => "mutate_add_field_ecs_client_domain_dhcp_client_fqdn"
               add_field => { "[client][domain]" => "%{[zeek][dhcp][client_fqdn]}" } }
    }

    if ([zeek][dhcp][assigned_ip]) {
      mutate { id => "mutate_merge_zeek_dhcp_host"
               merge => { "[dhcp][host]" => "[zeek][dhcp][assigned_ip]" } }
    }

  } else if ([log_source] == "dnp3") {
    #############################################################################################################################
    # dnp3.log specific logic

    # translate IIN bitmap (least significant bit = zeek_dnp3_iin_flags[0], etc.)
    # reference: https://raw.githubusercontent.com/wireshark/wireshark/master/epan/dissectors/packet-dnp.c (search IIN)
    ruby {
      id => "ruby_parse_dnp3_iin"
      init => "$zeek_dnp3_iin_flags = [ 'Function Code not Implemented', 'Requested Objects Unknown', 'Parameters Invalid or Out of Range', 'Event Buffer Overflow', 'Operation Already Executing', 'Configuration Corrupt', 'Reserved', 'Reserved', 'Broadcast Msg Rx', 'Class 1 Data Available', 'Class 2 Data Available', 'Class 3 Data Available', 'Time Sync Required', 'Digital Outputs in Local', 'Device Trouble', 'Device Restart' ]"
      code => "
        iinNum = event.get('[zeek][dnp3][iin]').to_i
        if (iinNum > 0) then
          iinFlags = Array.new
          $zeek_dnp3_iin_flags.each_with_index do |val, idx|
            iinFlags.push(val) if (iinNum[idx] == 1)
          end
          event.set('[zeek][dnp3][iin_flags]', iinFlags)
        end"
    }

  } else if ([log_source] == "dns") {
    #############################################################################################################################
    # dns.log specific logic

    mutate { id => "mutate_split_zeek_dns_TTLs"
               split => { "[zeek][dns][TTLs]" => "," } }

    # this must be done because [dns][ip] only handles IPv4 or IPv6 addresses
    # but [answers] can contain hostnames as well
    if ([zeek][dns][answers]) {
      ruby {
        id => "ruby_zeek_dns_answers_ip_extract"
        # todo: adjust this regex so it at least sort of catches IPv6 as well
        code => "event.set('[@metadata][answers_ip]', event.get('[zeek][dns][answers]').scan(/\d+\.\d+\.\d+\.\d+/).join(','))"
      }
      mutate { id => "mutate_split_zeek_dns_answers"
               split => { "[zeek][dns][answers]" => "," } }
      mutate { id => "mutate_split_zeek_dns_answers_ip"
               split => { "[@metadata][answers_ip]" => "," } }
      # ECS - zeek.dns -> dns.answers
      ruby {
        id => "ruby_zeek_dns_answers_to_ecs"
        code => '
          event.set("[dns][answers]", [Array(event.get("[zeek][dns][answers]")), Array(event.get("[zeek][dns][TTLs]"))].transpose.map{ |d| Hash[[:data, :ttl].zip(d)] })
      '}
      mutate { id => "mutate_add_field_ecs_dns_type_answer"
               add_field => { "[dns][type]" => "answer" } }
    }

    if ([zeek][dns][query]) {
      mutate { id => "mutate_merge_zeek_query"
               merge => { "[dns][host]" => "[zeek][dns][query]" } }
      ruby { id => "ruby_add_field_zeek_dns_opcode"
             code => "event.set('[dns][opcode]', [ 'QUERY', event.get('[dns][opcode]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
    }

    if ([@metadata][answers_ip]) {
      mutate { id => "mutate_merge_zeek_dns_ip"
               merge => { "[dns][ip]" => "[@metadata][answers_ip]" } }
      # ECS  dns.ip -> dns.resolved_ip
      mutate { id => "mutate_merge_ecs_dhs_resolved_ip"
               merge => { "[dns][resolved_ip]" => "[dns][ip]" } }
    }

    if ([zeek][dns][qclass_name]) {
      mutate { id => "mutate_merge_zeek_dns_qc"
               merge => { "[dns][qc]" => "[zeek][dns][qclass_name]" } }
    }

    if ([zeek][dns][qtype_name]) {
      mutate { id => "mutate_merge_zeek_dns_qt"
               merge => { "[dns][qt]" => "[zeek][dns][qtype_name]" } }
    }

    # dns.op_code
    if ([dns][opcode]) {                          mutate { id => "mutate_add_field_ecs_dns_opcode"
                                                           add_field => { "[dns][op_code]" => "%{[dns][opcode]}" } } }

    # dns.question.class
    if ([zeek][dns][qclass_name]) {                mutate { id => "mutate_add_field_ecs_dns_qclass"
                                                           add_field => { "[dns][question][class]" => "%{[zeek][dns][qclass_name]}" } } }

    # dns.question.type
    if ([zeek][dns][qtype_name]) {                 mutate { id => "mutate_add_field_ecs_dns_qtype"
                                                           add_field => { "[dns][question][type]" => "%{[zeek][dns][qtype_name]}" } } }

    # dns.question.name and dns.type:query
    if ([zeek][dns][query]) {
                          mutate { id => "mutate_add_field_ecs_dns_query"
                                   add_field => { "[dns][question][name]" => "%{[zeek][dns][query]}" } }
      if (![dns][type]) { mutate { id => "mutate_add_field_ecs_dns_type_query"
                                   add_field => { "[dns][type]" => "query" } } }
    }

    if ([dns][type]) {
      # dns.header_flags
      if ([zeek][AA] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_aa"
                                                           add_field => { "[dns][header_flags]" => "AA" } } }
      if ([zeek][TC] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_tc"
                                                           add_field => { "[dns][header_flags]" => "TC" } } }
      if ([zeek][RD] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_rd"
                                                           add_field => { "[dns][header_flags]" => "RD" } } }
      if ([zeek][RA] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_ra"
                                                           add_field => { "[dns][header_flags]" => "RA" } } }
    }

    # dns.response_code
    if ([zeek][dns][rcode_name]) {                 mutate { id => "mutate_add_field_ecs_dns_response_code"
                                                           add_field => { "[dns][response_code]" => "%{[zeek][dns][rcode_name]}" } } }

    # dns.id
    if ([zeek][dns][trans_id]) {                   mutate { id => "mutate_add_field_ecs_dns_id"
                                                           add_field => { "[dns][id]" => "%{[zeek][dns][trans_id]}" } } }

    # TODO: domain stuff (dns.question.registered_domain, dns.question.subdomain, dns.question.top_level_domain)
    # perhaps use something like https://github.com/plutonbacon/logstash-filter-publicsuffix

  } else if ([log_source] == "files") {
    #############################################################################################################################
    # files.log specific logic

    # translate Zeek's double-backslashes single backslash in filenames
    ruby {
      id => "ruby_zeek_files_filename_dedoubleslash"
      path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
      script_params => {
        "source" => "[zeek][files][filename]"
        "target" => "[zeek][files][filename]"
      }
    }

    if ([zeek][files][total_bytes]) {
      ruby {
        id => "ruby_zeek_files_totBytes"
        code => "event.set('[network][bytes]', event.get('[zeek][files][total_bytes]').to_i)"
      }
    }
    if ([zeek][files][seen_bytes]) {
      ruby {
        id => "ruby_zeek_files_totDataBytes"
        code => "event.set('[totDataBytes]', event.get('[zeek][files][seen_bytes]').to_i)"
      }
    }

    if ([zeek][files][parent_fuid]) { mutate { id => "mutate_split_zeek_files_parent_fuid"
                                              split => { "[zeek][files][parent_fuid]" => "," } } }

    if ([zeek][files][analyzers]) { mutate { id => "mutate_split_zeek_files_analyzers"
                                            split => { "[zeek][files][analyzers]" => "," } } }

    if ([zeek][files][source]) {

      # do some normalization on files source
      mutate { id => "mutate_gsub_field_zeek_files_source_spicy_suffix"
               gsub => [ "[zeek][files][source]", "_(TCP|UDP|DATA)$", "" ] }
      mutate { id => "mutate_gsub_field_zeek_files_source_spicy_prefix"
               gsub => [ "[zeek][files][source]", "^SPICY_", "" ] }

      if ([zeek][files][source] =~ /^XOR decrypted from /) {
        # PE_XOR plugin writes source as "XOR decrypted from FM7Tr545kxt3ofR7x2-"..., let's
        # standardize that to just "XOR decrypted" and put the source fuid in parent_fuid
        grok {
          id => "grok_zeek_files_source_xor"
          match => { "[zeek][files][source]" => [ "decrypted%{SPACE}from%{SPACE}%{WORD:[@metadata][source_xor_fuid]}" ] }
        }
        if ([@metadata][source_xor_fuid]) { mutate { id => "mutate_merge_zeek_files_source_xor_parent_fuid"
                                                     merge => { "[zeek][files][parent_fuid]" => "[@metadata][source_xor_fuid]" } } }
        mutate { id => "mutate_replace_zeek_files_source_xor"
                 replace => { "[zeek][files][source]" => "XOR decrypted" } }

      } else if ([zeek][files][source] == "SSL") {
        # SSL->TLS to match up with what the service field has for cross-referencing
        mutate { id => "mutate_replace_zeek_files_source_ssl_to_tls"
                 replace => { "[zeek][files][source]" => "TLS" } }
      }
    }

    # ECS - "file" -> file.type
    mutate { id => "mutate_add_field_ecs_file_type"
             add_field => { "[file][type]" => "file" } }

    # ECS -> zeek_files.total_bytes -> file.size
    if ([zeek][files][total_bytes]) {  mutate { id => "mutate_add_field_ecs_files_size"
                                      add_field => { "[file][size]" => "%{[zeek][files][total_bytes]}" } } }

    # ECS -> zeek_files.(md5|sha1|sha256) -> file.hash.(md5|sha1|sha256)
    if ([zeek][files][md5]) {          mutate { id => "mutate_add_field_ecs_files_hash_md5"
                                      add_field => { "[file][hash][md5]" => "%{[zeek][files][md5]}" } } }
    if ([zeek][files][sha1]) {         mutate { id => "mutate_add_field_ecs_files_hash_sha1"
                                      add_field => { "[file][hash][sha1]" => "%{[zeek][files][sha1]}" } } }
    if ([zeek][files][sha256]) {       mutate { id => "mutate_add_field_ecs_files_hash_sha256"
                                      add_field => { "[file][hash][sha256]" => "%{[zeek][files][sha256]}" } } }

  } else if ([log_source] == "ftp") {
    #############################################################################################################################
    # ftp.log specific logic

    if ([zeek][ftp][file_size]) {
      ruby {
        id => "ruby_zeek_ftp_totDataBytes"
        code => "event.set('[totDataBytes]', event.get('[zeek][ftp][file_size]').to_i)"
      }
    }

  } else if ([log_source] == "genisys") {
    #############################################################################################################################
    # genisys.log specific logic

    ruby {
      id => "ruby_genisys_payload"
      init => "$genisys_fields = [ :address, :data ]"
      code => "
        vars = event.get('[zeek][genisys][payload_raw]').to_s.split(',').map{ |x| x.split('=') }.map{ |x| $genisys_fields.zip(x).to_h }
        event.set('[zeek][genisys][payload]', vars) unless vars.nil? or (vars.length == 0)
      "
    }
    mutate { id => "mutate_remove_genisys_payload_raw"
             remove_field => [ "[zeek][genisys][payload_raw]" ] }

  } else if ([log_source] == "gquic") {
    #############################################################################################################################
    # gquic.log specific logic

    if ([zeek][gquic][user_agent]) {
      mutate { id => "mutate_merge_zeek_quic_useragent"
               merge => { "[quic][useragent]" => "[zeek][gquic][user_agent]" } }
    }

    if ([zeek][gquic][server_name]) {
      mutate { id => "mutate_merge_zeek_quic_host"
               merge => { "[quic][host]" => "[zeek][gquic][server_name]" } }
    }

    if ([zeek][gquic][version]) {
      ruby {
        id => "ruby_zeek_set_quic_version"
        code => "event.set('[quic][version]', 'Q' + event.get('[zeek][gquic][version]').rjust(3, '0'))"
      }
    }


  } else if ([log_source] == "http") {
    #############################################################################################################################
    # http.log specific logic

    mutate { id => "mutate_split_zeek_http_orig_fuids"
             split => { "[zeek][http][orig_fuids]" => "," } }
    mutate { id => "mutate_split_zeek_http_orig_filenames"
             split => { "[zeek][http][orig_filenames]" => "," } }
    mutate { id => "mutate_split_zeek_http_orig_mime_types"
             split => { "[zeek][http][orig_mime_types]" => "," } }
    mutate { id => "mutate_split_zeek_http_resp_fuids"
             split => { "[zeek][http][resp_fuids]" => "," } }
    mutate { id => "mutate_split_zeek_http_resp_filenames"
             split => { "[zeek][http][resp_filenames]" => "," } }
    mutate { id => "mutate_split_zeek_http_resp_mime_types"
             split => { "[zeek][http][resp_mime_types]" => "," } }
    mutate { id => "mutate_split_zeek_http_proxied"
             split => { "[zeek][http][proxied]" => "," } }

    # translate Zeek's double-backslashes single backslash in filenames
    ruby {
      id => "ruby_zeek_http_orig_filenames_dedoubleslash"
      path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
      script_params => {
        "source" => "[zeek][http][orig_filenames]"
        "target" => "[zeek][http][orig_filenames]"
      }
    }
    ruby {
      id => "ruby_zeek_http_resp_filenames_dedoubleslash"
      path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
      script_params => {
        "source" => "[zeek][http][resp_filenames]"
        "target" => "[zeek][http][resp_filenames]"
      }
    }

    if ([zeek][http][tags]) {
      # merge zeek.http.tags into tags and then remove original
      mutate { id => "mutate_split_zeek_http_tags"
               split => { "[zeek][http][tags]" => "," } }
      mutate { id => "mutate_merge_zeek_http_tags"
               merge => { "[tags]" => "[zeek][http][tags]" } }
      mutate { id => "mutate_remove_field_zeek_http_tags"
               remove_field => [ "[zeek][http][tags]" ] }
    }

    if ([zeek][http][host]) {
      mutate { id => "mutate_merge_zeek_http_host"
               merge => { "[http][host]" => "[zeek][http][host]" } }
    }

    if ([zeek][http][uri]) {
      if ([zeek][http][host]) {
        mutate { id => "mutate_add_field_metadata_http_host_and_uri"
                 add_field => { "[@metadata][http_uri]" => "%{[zeek][http][host]}%{[zeek][http][uri]}" } }
        mutate { id => "mutate_merge_zeek_http_host_and_uri"
                 merge => { "[http][uri]" => "[@metadata][http_uri]" } }
      } else {
        mutate { id => "mutate_merge_zeek_http_uri"
                 merge => { "[http][uri]" => "[zeek][http][uri]" } }
      }
    } else if ([zeek][http][referrer]) {
      mutate { id => "mutate_merge_zeek_http_referrer"
      merge => { "[http][uri]" => "[zeek][http][referrer]" } }
    }

    if ([zeek][http][user_agent]) {
      mutate { id => "mutate_merge_zeek_http_user_agent"
               merge => { "[http][useragent]" => "[zeek][http][user_agent]" } }
    }

    if ([zeek][http][orig_mime_types]) {
      mutate { id => "mutate_merge_zeek_http_orig_mime_types"
               merge => { "[http][bodyMagic]" => "[zeek][http][orig_mime_types]" } }
      # ECS - zeek.http.orig_mime_types -> http.request.mime_type
      mutate { id => "mutate_merge_ecs_http_request_mime_type"
               merge => { "[http][request][mime_type]" => "[zeek][http][orig_mime_types]" } }
    }

    if ([zeek][http][resp_mime_types]) {
      mutate { id => "mutate_merge_zeek_http_resp_mime_types"
               merge => { "[http][bodyMagic]" => "[zeek][http][resp_mime_types]" } }
      # ECS - zeek.http.resp_mime_types -> http.response.mime_type
      mutate { id => "mutate_merge_ecs_http_response_mime_type"
               merge => { "[http][response][mime_type]" => "[zeek][http][resp_mime_types]" } }
    }

    if ([zeek][http][version]) {
      mutate { id => "mutate_merge_zeek_http_clientVersion"
               merge => { "[http][clientVersion]" => "[zeek][http][version]" } }
    }

    if ([zeek][http][status_code]) {
      mutate { id => "mutate_merge_zeek_http_statuscode"
               merge => { "[http][statuscode]" => "[zeek][http][status_code]" } }
    }

    if ([zeek][http][method]) {
      mutate { id => "mutate_merge_zeek_http_method"
               merge => { "[http][method]" => "[zeek][http][method]" } }
    }

    if ([zeek][http][post_username]) {
      mutate { id => "mutate_merge_zeek_http_post_username_1"
               merge => { "[related][user]" => "[zeek][http][post_username]" } }
      mutate { id => "mutate_merge_zeek_http_post_username_2"
               merge => { "[user]" => "[zeek][http][post_username]" } }
    }
    if (![related][password]) and ([zeek][http][post_password_plain]) {
      mutate { id => "mutate_add_field_zeek_http_post_password_plain"
               add_field =>  { "[related][password]" => "%{[zeek][http][post_password_plain]}" } }
    }

    if ([zeek][http][response_body_len]) { mutate { id => "mutate_add_field_zeek_http_server_bytes"
                                                   add_field => { "[server][bytes]" => "%{[zeek][http][response_body_len]}" } } }
    if ([zeek][http][request_body_len]) { mutate { id => "mutate_add_field_zeek_http_client_bytes"
                                                  add_field => { "[client][bytes]" => "%{[zeek][http][request_body_len]}" } } }

    ruby {
      id => "ruby_zeek_http_totDataBytes"
      code => "event.set('[totDataBytes]', event.get('[zeek][http][response_body_len]').to_i + event.get('[zeek][http][request_body_len]').to_i)"
    }

    # ECS - zeek.http.request_body_len -> http.request.body.bytes
    if ([zeek][http][request_body_len]) {        mutate { id => "mutate_add_field_ecs_http_request_body_bytes"
                                                         add_field => { "[http][request][body][bytes]" => "%{[zeek][http][request_body_len]}" } } }
    # ECS - zeek.http.method -> http.request.method
    if ([zeek][http][method]) {                  mutate { id => "mutate_add_field_ecs_http_request_method"
                                                         add_field => { "[http][request][method]" => "%{[zeek][http][method]}" } } }
    # ECS - zeek.http.referrer -> http.request.referrer
    if ([zeek][http][referrer]) {                mutate { id => "mutate_add_field_ecs_http_request_referrer"
                                                         add_field => { "[http][request][referrer]" => "%{[zeek][http][referrer]}" } } }
    # ECS - zeek.http.response_body_len -> http.response.body.bytes
    if ([zeek][http][response_body_len]) {       mutate { id => "mutate_add_field_ecs_http_response_body_bytes"
                                                         add_field => { "[http][response][body][bytes]" => "%{[zeek][http][response_body_len]}" } } }
    # ECS - zeek.http.status_code -> http.response.status_code
    if ([zeek][http][status_code]) {             mutate { id => "mutate_add_field_ecs_http_response_status_code"
                                                         add_field => { "[http][response][status_code]" => "%{[zeek][http][status_code]}" } } }
    # ECS - zeek.http.version -> http.version
    if ([zeek][http][version]) {                 mutate { id => "mutate_add_field_ecs_http_version"
                                                         add_field => { "[http][version]" => "%{[zeek][http][version]}" } } }

    # ECS - zeek.http.host and zeek_http.uri -> url.* (https://www.elastic.co/guide/en/ecs/current/ecs-url.html)
    if ([zeek][http][uri]) or ([zeek][http][host]) {
      ruby {
        id => "ruby_ecs_uri_parse_from_zeek_http"
        init => "require 'uri'"
        code => "
          scheme = 'http'
          user = event.get('[related][user]')
          password = event.get('[related][password]')
          host = event.get('[zeek][http][host]')
          port = event.get('[destination][port]')
          uri = event.get('[zeek][http][uri]')
          ext = (uri.nil? || !(uri.include? '/')) ? nil : File.extname(uri).partition('.').last.split(/[\?#]/)[0]
          fragment = uri.nil? ? nil : uri.partition('#').last
          query = uri.nil? ? nil : uri.partition('?').last
          event.set('[url][scheme]', scheme)
          event.set('[url][original]', scheme + '://' + (host.nil? ? '' : host) + (uri.nil? ? '' : uri))
          event.set('[url][full]', scheme + '://' + (user.nil? ? '' : Array(user).first) + (password.nil? ? '' : ':' + password) + ((user.nil? && password.nil?) ? '' : '@') + (host.nil? ? '' : host) + (port.nil? ? '' : ':' + port) + (uri.nil? ? '' : uri))
          event.set('[url][domain]', host) unless host.nil?
          event.set('[url][extension]', ext) unless ext.nil? || ext.empty?
          event.set('[url][fragment]', fragment) unless fragment.nil? || fragment.empty?
          event.set('[url][password]', password) unless password.nil?
          event.set('[url][path]', uri) unless uri.nil?
          event.set('[url][port]', port) unless port.nil?
          event.set('[url][query]', query) unless query.nil? || query.empty?
          event.set('[url][username]', Array(user).first) unless user.nil?
        "
        # TODO: ECS url domain stuff (url.registered_domain, url.top_level_domain)
        # perhaps use something like https://github.com/plutonbacon/logstash-filter-publicsuffix
      }
    }

  } else if ([log_source] == "ipsec") {
    #############################################################################################################################
    # ipsec.log specific logic

    mutate { id => "mutate_split_zeek_ipsec_vendor_ids"
             split => { "[zeek][ipsec][vendor_ids]" => "," } }
    mutate { id => "mutate_split_zeek_ipsec_notify_messages"
             split => { "[zeek][ipsec][notify_messages]" => "," } }
    mutate { id => "mutate_split_zeek_ipsec_transforms"
             split => { "[zeek][ipsec][transforms]" => "," } }
    mutate { id => "mutate_split_zeek_ipsec_ke_dh_groups"
             split => { "[zeek][ipsec][ke_dh_groups]" => "," } }
    mutate { id => "mutate_split_zeek_ipsec_proposals"
             split => { "[zeek][ipsec][proposals]" => "," } }
    mutate { id => "mutate_split_zeek_ipsec_certificates"
             split => { "[zeek][ipsec][certificates]" => "," } }
    mutate { id => "mutate_split_zeek_ipsec_transform_attributes"
             split => { "[zeek][ipsec][transform_attributes]" => "," } }

    ruby {
      id => "ruby_zeek_field_ipsec_flags"
      code => '
        flags = Array.new
        if (event.get("[zeek][ipsec][flag_e]") == "T") then
          flags << "E"
        end
        if (event.get("[zeek][ipsec][flag_c]") == "T") then
          flags << "C"
        end
        if (event.get("[zeek][ipsec][flag_a]") == "T") then
          flags << "A"
        end
        if (event.get("[zeek][ipsec][flag_i]") == "T") then
          flags << "I"
        end
        if (event.get("[zeek][ipsec][flag_v]") == "T") then
          flags << "V"
        end
        if (event.get("[zeek][ipsec][flag_r]") == "T") then
          flags << "R"
        end
        if !flags.empty? then
          event.set("[zeek][ipsec][flags]", flags)
        end'
    }

  } else if ([log_source] == "irc") {
    #############################################################################################################################
    # irc.log specific logic

    if ([zeek][irc][nick]) {
      mutate { id => "mutate_merge_zeek_irc_nick"
               merge => { "[irc][nick]" => "[zeek][irc][nick]" } }
      # store "nick" alongside "user"
      mutate { id => "mutate_merge_irc_nick_user_1"
               merge => { "[related][user]" => "[zeek][irc][nick]" } }
      mutate { id => "mutate_merge_irc_nick_user_2"
               merge => { "[user]" => "[zeek][irc][nick]" } }
    }

    if ([zeek][irc][command]) and ([zeek][irc][value]) and (([zeek][irc][command] == "JOIN") or ([zeek][irc][command] == "PART")) {
      mutate { id => "mutate_merge_zeek_irc_channel"
               merge => { "[irc][channel]" => "[zeek][irc][value]" } }
    }

  } else if ([log_source] == "intel") {
    #############################################################################################################################
    # intel.log specific logic

    if ([zeek][intel][sources])  { mutate { id => "mutate_split_zeek_intel_sources"
                                            split => { "[zeek][intel][sources]" => "," } } }

    if ([zeek][intel][matched])  { mutate { id => "mutate_split_zeek_intel_matched"
                                             split => { "[zeek][intel][matched]" => "," } } }

    if ([zeek][intel][cif_tags]) { mutate { id => "mutate_split_zeek_intel_cif_tags"
                                            split => { "[zeek][intel][cif_tags]" => "," } } }

    if ([zeek][intel][sources]) or ([zeek][intel][cif_tags]) {
      ruby {
        id => "ruby_zeek_intel_sources_and_tags_comma_fix"
        code => "
          if (sources = event.get('[zeek][intel][sources]')) and (sources.length > 0) then
            sourcesAdj = Array.new
            sources.each do |val|
              sourcesAdj.push(val.gsub('\\x2c', ','))
            end
            event.set('[zeek][intel][sources]', sourcesAdj)
          end
          if (tags = event.get('[zeek][intel][cif_tags]')) and (tags.length > 0) then
            tagsAdj = Array.new
            tags.each do |val|
              tagsAdj.push(val.gsub('\\x2c', ','))
            end
            event.set('[zeek][intel][cif_tags]', tagsAdj)
          end"
      }
    }

  } else if ([log_source] == "kerberos") {
    #############################################################################################################################
    # kerberos.log specific logic

    if ([zeek][kerberos][cname]) {
      mutate { id => "mutate_merge_zeek_kerberos_cname"
               merge => { "[krb5][cname]" => "[zeek][kerberos][cname]" } }
    }

    if ([zeek][kerberos][sname]) {
      mutate { id => "mutate_merge_zeek_kerberos_sname"
               merge => { "[krb5][sname]" => "[zeek][kerberos][sname]" } }
    }

    if ([zeek][kerberos][client_cert_fuid]) { mutate { id => "mutate_split_zeek_kerberos_client_cert_fuid"
                                                      split => { "[zeek][kerberos][client_cert_fuid]" => "," } } }

    if ([zeek][kerberos][server_cert_fuid]) { mutate { id => "mutate_split_zeek_kerberos_server_cert_fuid"
                                                      split => { "[zeek][kerberos][server_cert_fuid]" => "," } } }

  } else if ([log_source] == "ldap") {
    #############################################################################################################################
    # ldap.log specific logic

    mutate { id => "mutate_split_zeek_ldap_fields"
             split => { "[zeek][ldap][operation]" => ","
                        "[zeek][ldap][result_code]" => ","
                        "[zeek][ldap][result_message]" => ","
                        "[zeek][ldap][object]" => ","
                        "[zeek][ldap][argument]" => "," } }

    if ([zeek][ldap][object]) or ([zeek][ldap][argument]) {
      ruby {
        id => "ruby_zeek_ldap_object_and_arguments_adjustment"
        code => "
          if (objects = event.get('[zeek][ldap][object]')) and (objects.length > 0) then
            objectsAdj = Array.new
            objects.each do |val|
              objectsAdj.push(val.gsub('\\x2c', ','))
            end
            event.set('[zeek][ldap][object]', objectsAdj)
          end
          if (arguments = event.get('[zeek][ldap][argument]')) and (arguments.length > 0) then
            argsAdj = Array.new
            arguments.each do |val|
              argsAdj.push(val.gsub('\\x2c', ','))
            end
            event.set('[zeek][ldap][argument]', argsAdj)
          end"
      }
    }

    # map simple bind "object" and "argument" to username and password
    # and map to Arkime types
    if ("bind simple" in [zeek][ldap][operation]) {
      if ([zeek][ldap][object]) {
        mutate { id => "mutate_merge_zeek_ldap_bind_object_user"
                 merge => { "[related][user]" => "[zeek][ldap][object]" } }
        mutate { id => "mutate_merge_ldap_bind_name"
                 merge => { "[ldap][bindname]" => "[zeek][ldap][object]" } }
      }
      if ([zeek][ldap][argument]) {
        mutate { id => "mutate_merge_zeek_ldap_bind_argument_password"
                 merge => { "[related][password]" => "[zeek][ldap][argument]" } }
      }
      mutate { id => "mutate_add_field_ldap_authtype_simple"
               add_field => { "[@metadata][ldapAuthType]" => "simple" } }
    } else if ("bind SASL" in [zeek][ldap][operation]) {
      mutate { id => "mutate_add_field_ldap_authtype_sasl"
               add_field => { "[@metadata][ldapAuthType]" => "sasl" } }
    }
    if ([@metadata][ldapAuthType]) {
      mutate { id => "mutate_merge_ldap_authtype"
               merge => { "[ldap][authtype]" => "[@metadata][ldapAuthType]" } }
    }

  } else if ([log_source] == "ldap_search") {
    #############################################################################################################################
    # ldap_search.log specific logic

    mutate { id => "mutate_split_zeek_ldap_search_fields"
             split => { "[zeek][ldap_search][scope]" => ","
                        "[zeek][ldap_search][deref]" => ","
                        "[zeek][ldap_search][attributes]" => ","
                        "[zeek][ldap_search][base_object]" => ","
                        "[zeek][ldap_search][result_code]" => ","
                        "[zeek][ldap_search][result_message]" => "," } }

    if ([zeek][ldap_search][base_object]) {
      ruby {
        id => "ruby_zeek_ldap_search_base_object_adjustment"
        code => "
          if (objects = event.get('[zeek][ldap_search][base_object]')) and (objects.length > 0) then
            objectsAdj = Array.new
            objects.each do |val|
              objectsAdj.push(val.gsub('\\x2c', ','))
            end
            event.set('[zeek][ldap_search][base_object]', objectsAdj)
          end"
      }
    }

  } else if ([log_source] == "modbus") {
    #############################################################################################################################
    # modbus.log specific logic

    # normalize network_direction to match modbus_details.log
    if ([zeek][modbus][network_direction]) {
      translate {
        id => "translate_zeek_modbus_network_direction"
        source => "[zeek][modbus][network_direction]"
        target => "[zeek][modbus][network_direction]"
        dictionary => {
          "REQ" => "request"
          "RESP" => "response"
        }
      }
    }

  } else if ([log_source] == "modbus_detailed") {
    #############################################################################################################################
    # modbus_detailed.log specific logic

    if ([zeek][modbus_detailed][values]) {
      mutate { id => "mutate_split_zeek_modbus_detailed_values"
               split => { "[zeek][modbus_detailed][values]" => "," } }
    }

    # rename a to make correlating modbus easier between logs
    mutate {
      id => "mutate_rename_modbus_detailed_fields"
      rename => { "[zeek][modbus_detailed][func]" => "[zeek][modbus][func]" }
      rename => { "[zeek][modbus_detailed][unit_id]" => "[zeek][modbus][unit_id]" }
      rename => { "[zeek][modbus_detailed][network_direction]" => "[zeek][modbus][network_direction]" }
    }

  } else if ([log_source] == "modbus_mask_write_register") {
    #############################################################################################################################
    # modbus_mask_write_register.log specific logic

    # rename a to make correlating modbus easier between logs
    mutate {
      id => "mutate_rename_modbus_mask_write_register_fields"
      rename => { "[zeek][modbus_mask_write_register][address]" => "[zeek][modbus_detailed][address]" }
      rename => { "[zeek][modbus_mask_write_register][func]" => "[zeek][modbus][func]" }
      rename => { "[zeek][modbus_mask_write_register][network_direction]" => "[zeek][modbus][network_direction]" }
      rename => { "[zeek][modbus_mask_write_register][unit_id]" => "[zeek][modbus][unit_id]" }
    }

  } else if ([log_source] == "modbus_read_write_multiple_registers") {
    #############################################################################################################################
    # modbus_read_write_multiple_registers.log specific logic

    if ([zeek][modbus_read_write_multiple_registers][read_registers]) {
      mutate { id => "mutate_split_zeek_modbus_read_write_multiple_registers_read_registers"
               split => { "[zeek][modbus_read_write_multiple_registers][read_registers]" => "," } }
    }

    if ([zeek][modbus_read_write_multiple_registers][write_registers]) {
      mutate { id => "mutate_split_zeek_modbus_read_write_multiple_registers_write_registers"
               split => { "[zeek][modbus_read_write_multiple_registers][write_registers]" => "," } }
    }

    # rename a to make correlating modbus easier between logs
    mutate {
      id => "mutate_rename_modbus_read_write_multiple_registers_fields"
      rename => { "[zeek][modbus_read_write_multiple_registers][network_direction]" => "[zeek][modbus][network_direction]" }
      rename => { "[zeek][modbus_read_write_multiple_registers][unit_id]" => "[zeek][modbus][unit_id]" }
      rename => { "[zeek][modbus_read_write_multiple_registers][func]" => "[zeek][modbus][func]" }
    }

  } else if ([log_source] == "mqtt_publish") {
    #############################################################################################################################
    # mqtt_publish.log specific logic

    # MQTT payload *may* be JSON, or it may not
    json {
      skip_on_invalid_json => true
      source => "[zeek][mqtt_publish][payload]"
      target => "[zeek][mqtt_publish][payload_dict]"
    }

    if ([zeek][mqtt_publish][payload_len]) { mutate { id => "mutate_add_field_zeek_mqtt_publish_client_len"
                                                     add_field => { "[client][bytes]" => "%{[zeek][mqtt_publish][payload_len]}" } } }


  } else if ([log_source] == "mqtt_subscribe") {
    #############################################################################################################################
    # mqtt_subscribe.log specific logic

    mutate { id => "mutate_split_zeek_mqtt_subscribe_fields"
             split => { "[zeek][mqtt_subscribe][topics]" => ","
                        "[zeek][mqtt_subscribe][qos_levels]" => "," } }

  } else if ([log_source] == "mysql") {
    #############################################################################################################################
    # mysql.log specific logic

    if ([zeek][mysql][rows] == 0) {
      mutate { id => "mutate_remove_field_zeek_mysql_zero_rows"
               remove_field => [ "[zeek][mysql][rows]" ] }
    }

  } else if ([log_source] == "notice") {
    #############################################################################################################################
    # notice.log specific logic

    mutate { id => "mutate_split_zeek_notice_actions"
             split => { "[zeek][notice][actions]" => "," } }

    ruby {
      id => "ruby_add_field_zeek_notice_event_original"
      code => " event.set('[event][original]', [event.get('[zeek][notice][msg]'),
                                                event.get('[zeek][notice][sub]')].reject{ |e| e.nil? || e&.empty? }.join(':'))" }

    # split "Category::Subcategory" into two different fields
    ruby {
      id => "ruby_zeek_notice_category_extract"
      code => "
        if (noticeNote = event.get('[zeek][notice][note]')) and (noticeParts = noticeNote.split('::')) then
          if (noticeParts.length >= 2) then
            event.set('[zeek][notice][category]', noticeParts[0])
            event.set('[zeek][notice][sub_category]', noticeParts[1])
          elsif (noticeParts.length == 1) then
            event.set('[zeek][notice][category]', noticeParts[0])
          end
        end"
    }

    if ([zeek][notice][category] == "ATTACK") and ([zeek][notice][msg] =~ /(from|against|to)\s+host/) {
      # ATTACK::Discovery - Detected activity from host 192.168.199.133, total attempts 5 within timeframe 5.0 mins
      # but no IP addresses set :(
      if (![source][ip]) {
        grok {
          id => "grok_zeek_notice_attack_src_hosts"
          match => { "[zeek][notice][msg]" => [ "from%{SPACE}host%{SPACE}%{DATA:[source][ip]}%{SPACE}($|[^\d:\.\w-]+)" ] }
        }
      }
      if (![destination][ip]) {
        grok {
          id => "grok_zeek_notice_attack_dst_hosts"
          match => { "[zeek][notice][msg]" => [ "(against|to)%{SPACE}host%{SPACE}%{DATA:[destination][ip]}%{SPACE}($|[^\d:\.\w-]+)" ] }
        }
      }
    }

    if ([zeek][notice][note] == "Corelight::XOR_Encrypted_PE_File_Seen") and ([zeek][notice][sub] =~ /Decrypted File ID/) {
      # zeek_notice.note  Corelight::XOR_Encrypted_PE_File_Seen
      #
      #         zeek.fuid   F7QoY740DvrZF2lrsa
      # + zeek_notice.sub   Decrypted File ID: FqNQ8i3LbG2ZY5EO3k
      # -----------------
      # =       zeek.fuid   F7QoY740DvrZF2lrsa, FqNQ8i3LbG2ZY5EO3k
      grok {
        id => "grok_zeek_notice_xor_fuid"
        match => { "[zeek][notice][sub]" => [ "Decrypted%{SPACE}File%{SPACE}ID:%{SPACE}%{WORD:[@metadata][decrypted_xor_fuid]}" ] }
      }
      if ([@metadata][decrypted_xor_fuid]) { mutate { id => "mutate_merge_zeek_notice_decrypted_xor_fuid"
                                                      merge => { "[zeek][fuid]" => "[@metadata][decrypted_xor_fuid]" } } }
    }

    # add event.module to make them jive with signatures, suricata alerts, etc.
    mutate { id => "mutate_add_field_zeek_notice_module"
             add_field => { "[event][module]" => "zeek" } }

    # ECS - zeek.notice.category -> rule.category
    if ([zeek][notice][category]) {
      ruby { id => "ruby_add_field_ecs_rule_category_notice_category"
             code => "event.set('[rule][category]', [ event.get('[zeek][notice][category]'), event.get('[rule][category]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
    }

    # ECS - zeek.notice.sub_category -> rule.name
    if ([zeek][notice][sub_category]) {
      ruby { id => "ruby_add_field_ecs_zeek_rule_name_notice_sub_category"
             code => "event.set('[rule][name]', [ event.get('[zeek][notice][sub_category]'), event.get('[rule][name]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
    }

    # ECS - zeek.notice.category -> rule.author (mapped)
    translate {
      id => "translate_zeek_notice_author"
      source => "[zeek][notice][category]"
      target => "[@metadata][zeek_noticed_mapped_author]"
      dictionary_path => "/etc/notice_authors.yaml"
      fallback => "Zeek"
    }
    if ([@metadata][zeek_noticed_mapped_author]) {
      mutate { id => "mutate_merge_zeek_noticed_mapped_author"
               merge => { "[rule][author]" => "[@metadata][zeek_noticed_mapped_author]" } }
    }

    # ECS - zeek.notice.category -> rule.reference (mapped)
    translate {
      id => "translate_zeek_notice_reference"
      source => "[zeek][notice][category]"
      target => "[@metadata][zeek_noticed_mapped_reference]"
      dictionary_path => "/etc/notice_reference.yaml"
      fallback => "https://docs.zeek.org/en/current/zeek-noticeindex.html"
    }
    if ([@metadata][zeek_noticed_mapped_reference]) {
      mutate { id => "mutate_merge_zeek_noticed_mapped_reference"
               merge => { "[rule][reference]" => "[@metadata][zeek_noticed_mapped_reference]" } }
    }

    # ECS - zeek.notice.category -> rule.license (mapped)
    translate {
      id => "translate_zeek_notice_license"
      source => "[zeek][notice][category]"
      target => "[@metadata][zeek_noticed_mapped_license]"
      dictionary_path => "/etc/notice_license.yaml"
      fallback => "https://raw.githubusercontent.com/zeek/zeek/master/COPYING"
    }
    if ([@metadata][zeek_noticed_mapped_license]) {
      mutate { id => "mutate_merge_zeek_noticed_mapped_license"
               merge => { "[rule][license]" => "[@metadata][zeek_noticed_mapped_license]" } }
    }

    # ECS - zeek.notice.category -> threat.* (https://www.elastic.co/guide/en/ecs/current/ecs-threat.html)
    if ([zeek][notice][category] == "ATTACK") {

      # populate threat information for MITRE ATT&CK notices from mitre-attack/bzar plugin
      mutate { id => "mutate_add_field_ecs_threat_framework_mitre_attack"
               add_field => { "[threat][framework]" => "MITRE ATT&CK" } }

      if ([zeek][notice][sub_category]) {
        mutate { id => "mutate_add_field_ecs_threat_tactic_name_mitre"
                 add_field => { "[threat][tactic][name]" => "%{[zeek][notice][sub_category]}" } }
        mutate { id => "mutate_gsub_ecs_threat_tactic_name_notice_sub"
                 gsub => [ "[threat][tactic][name]", "_,", " " ] }
        translate {
          id => "translate_zeek_mitre_attack_tactic_name_to_id"
          source => "[zeek][notice][sub_category]"
          target => "[threat][tactic][id]"
          dictionary_path => "/etc/mitre_attack_tactic_ids.yaml"
        }
        translate {
          id => "translate_zeek_mitre_attack_tactic_name_to_reference"
          source => "[zeek][notice][sub_category]"
          target => "[threat][tactic][reference]"
          dictionary_path => "/etc/mitre_attack_tactic_reference.yaml"
          fallback => "https://attack.mitre.org/tactics/enterprise/"
        }
      }

      if ([zeek][notice][sub]) and ([zeek][notice][sub] =~ /^T/) {
        # eg., T1077 Windows Admin Shares + T1105 Remote File Copy
        ruby {
          id => "ruby_ecs_threat_technique_from_attack"
          code => "
            idArray = Array.new
            nameArray = Array.new
            event.get('[zeek][notice][sub]').split('+').each do |technique|
              id, name = technique.strip.match(/(^T.*?)\s+(.+$)/).captures
              idArray.push(id) unless id.nil?
              nameArray.push(name) unless name.nil?
            end
            event.set('[threat][technique][id]', idArray)
            event.set('[threat][technique][name]', nameArray)
            event.set('[threat][technique][reference]', idArray.clone.map(&:clone).map{|x| x.prepend('https://attack.mitre.org/techniques/')})
          "
        }
      }

    } else if ([zeek][notice][category] == "EternalSafety") {
      # populate threat information for EternalSafety from 0xl3x1/zeek-EternalSafety plugin
      mutate { id => "mutate_add_field_ecs_threat_framework_eternal_safety"
               add_field => { "[threat][framework]" => "EternalSafety" } }
      if ([zeek][notice][sub_category]) { mutate { id => "mutate_add_field_ecs_threat_technique_name_eternal"
                                                  add_field => { "[threat][technique][name]" => "%{[zeek][notice][sub_category]}" } } }
      if ([rule][reference])           { mutate { id => "mutate_add_field_ecs_threat_technique_reference_eternal"
                                                  add_field => { "[threat][tactic][reference]" => "%{[rule][reference]}"
                                                                 "[threat][technique][reference]" => "%{[rule][reference]}" } } }
    }

    if (([zeek][notice][category] =~ /^CVE/) or
        ([zeek][notice][category] == "EternalSafety") or
        ([zeek][notice][category] == "Ripple20") or
        ([zeek][notice][category] == "VMWareRCE2022") or
        ([zeek][notice][category] == "Zerologon")) {
      # ECS - zeek.notice.category -> vulnerability.* (https://www.elastic.co/guide/en/ecs/current/ecs-vulnerability.html)
      mutate { id => "mutate_merge_ecs_vulnerability_category_notice_category"
               merge => { "[vulnerability][category]" => "[zeek][notice][category]" } }
      mutate { id => "mutate_merge_ecs_vulnerability_description_notice_subcategory"
               merge => { "[vulnerability][description]" => "[zeek][notice][sub_category]" } }
      if ([rule][reference]) { mutate { id => "mutate_merge_zeek_noticed_mapped_vulnerability_reference"
                                        merge => { "[vulnerability][reference]" => "[rule][reference]" } } }
      if ([rule][author]) {    mutate { id => "mutate_merge_zeek_noticed_mapped_vulnerability_vendor"
                                        merge => { "[vulnerability][scanner][vendor]" => "[rule][author]" } } }
      if ([zeek][notice][category] =~ /^CVE/) {
        mutate { id => "mutate_add_field_ecs_zeek_vulnerability_enumeration_cve"
                 add_field => { "[vulnerability][enumeration]" => "CVE" } }
        mutate { id => "mutate_add_field_ecs_zeek_vulnerability_id_cve"
                 add_field => { "[vulnerability][id]" => "%{[zeek][notice][category]}" } }
      }
    }

    # remove signature fields that were mapped to ECS or not useful
    mutate { id => "mutate_remove_fields_zeek_notice"
             remove_field => [
              "[zeek][notice][sub_category]",
              "[zeek][notice][category]" ] }

  } else if ([log_source] == "ntlm") {
    #############################################################################################################################
    # ntlm.log specific logic

    # ECS - zeek.ntlm.host -> client.domain
    if ([zeek][ntlm][host]) {
      mutate { id => "mutate_add_field_ecs_client_domain_ntlm_host_name"
               add_field => { "[client][domain]" => "%{[zeek][ntlm][host]}" } }
    }

    # ECS - zeek.ntlm.domain -> client.domain
    if ([zeek][ntlm][domain]) {
      mutate { id => "mutate_add_field_ecs_client_domain_ntlm_domain"
               add_field => { "[client][domain]" => "%{[zeek][ntlm][domain]}" } }
    }

  } else if ([log_source] == "ntp") {
    #############################################################################################################################
    # ntp.log specific logic

    # map mode to string for readability
    if ([zeek][ntp][mode]) {
      translate {
        id => "translate_zeek_ntp_mode_str"
        source => "[zeek][ntp][mode]"
        target => "[zeek][ntp][mode_str]"
        dictionary_path => "/etc/ntp_modes.yaml"
      }
    }

  } else if ([log_source] =~ /^opcua_binary/) {
    #############################################################################################################################
    # opcua-binary-*.log specific logic

    # There is a lot of linking between various different field types to tie logs together,
    #   see https://github.com/cisagov/icsnpp-opcua-binary/tree/main/scripts.
    # We want to rename these fields as much as possible in order to have them cofilterable.
    #   I identified these from the the icsnpp-opcua-binary scripts source code with something like
    #   > grep -R '&log' | grep -Pi "\s*#.+$"

    mutate {
      id => "mutate_rename_opcua_linkage_fields"
      rename => { "[zeek][opcua_binary][status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_activate_session][activate_session_diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_activate_session][client_software_cert_link_id]" => "[zeek][opcua_binary_activate_session_client_software_cert][client_software_cert_link_id]" }
      rename => { "[zeek][opcua_binary_activate_session][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_activate_session][opcua_locale_link_id]" => "[zeek][opcua_binary_activate_session_locale_id][opcua_locale_link_id]" }
      rename => { "[zeek][opcua_binary_activate_session][status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_browse][browse_description_link_id]" => "[zeek][opcua_binary_browse_description][browse_description_link_id]" }
      rename => { "[zeek][opcua_binary_browse][browse_diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_browse][browse_next_link_id]" => "[zeek][opcua_binary_browse_request_continuation_point][browse_next_link_id]" }
      rename => { "[zeek][opcua_binary_browse][browse_response_link_id]" => "[zeek][opcua_binary_browse_result][browse_response_link_id]" }
      rename => { "[zeek][opcua_binary_browse][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_browse_result][browse_reference_link_id]" => "[zeek][opcua_binary_browse_response_references][browse_reference_link_id]" }
      rename => { "[zeek][opcua_binary_browse_result][status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_close_session][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_create_monitored_items][create_item_link_id]" => "[zeek][opcua_binary_create_monitored_items_create_item][create_item_link_id]" }
      rename => { "[zeek][opcua_binary_create_monitored_items][create_monitored_items_diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_create_monitored_items][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_create_monitored_items_create_item][monitoring_parameters_status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_create_session][discovery_profile_link_id]" => "[zeek][opcua_binary_create_session_discovery][discovery_profile_link_id]" }
      rename => { "[zeek][opcua_binary_create_session][endpoint_link_id]" => "[zeek][opcua_binary_create_session_endpoints][endpoint_link_id]" }
      rename => { "[zeek][opcua_binary_create_session][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_create_session_endpoints][discovery_profile_link_id]" => "[zeek][opcua_binary_create_session_discovery][discovery_profile_link_id]" }
      rename => { "[zeek][opcua_binary_create_session_endpoints][user_token_link_id]" => "[zeek][opcua_binary_create_session_user_token][user_token_link_id]" }
      rename => { "[zeek][opcua_binary_create_subscription][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_get_endpoints][endpoint_description_link_id]" => "[zeek][opcua_binary_get_endpoints_description][endpoint_description_link_id]" }
      rename => { "[zeek][opcua_binary_get_endpoints][locale_link_id]" => "[zeek][opcua_binary_get_endpoints_locale_id][locale_link_id]" }
      rename => { "[zeek][opcua_binary_get_endpoints][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_get_endpoints][profile_uri_link_id]" => "[zeek][opcua_binary_get_endpoints_profile_uri][profile_uri_link_id]" }
      rename => { "[zeek][opcua_binary_get_endpoints_description][discovery_profile_link_id]" => "[zeek][opcua_binary_get_endpoints_discovery][discovery_profile_link_id]" }
      rename => { "[zeek][opcua_binary_get_endpoints_description][user_token_link_id]" => "[zeek][opcua_binary_get_endpoints_user_token][user_token_link_id]" }
      rename => { "[zeek][opcua_binary_opensecure_channel][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_read][diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_read][nodes_to_read_link_id]" => "[zeek][opcua_binary_read_nodes_to_read][nodes_to_read_link_id]" }
      rename => { "[zeek][opcua_binary_read][opcua_link_id]" => "[zeek][opcua_binary][opcua_link_id]" }
      rename => { "[zeek][opcua_binary_read][read_results_link_id]" => "[zeek][opcua_binary_read_results][results_link_id]" }
      rename => { "[zeek][opcua_binary_read_results][status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_variant_metadata][variant_source_data_link_id]" => "[zeek][opcua_binary][variant_source_link_id]" }
      rename => { "[zeek][opcua_binary_read_results][read_results_variant_metadata_link_id]" => "[zeek][opcua_binary][variant_source_link_id]" }
      rename => { "[zeek][opcua_binary_variant_data][variant_metadata_data_link_id]" => "[zeek][opcua_binary][variant_source_link_id]" }
      rename => { "[zeek][opcua_binary_variant_data_value][variant_metadata_link_id]" => "[zeek][opcua_binary][variant_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_literal_operand][literal_operand_variant_link]" => "[zeek][opcua_binary][variant_source_link_id]" }
      rename => { "[zeek][opcua_binary_variant_metadata][variant_data_link_id]" => "[zeek][opcua_binary_variant_data][variant_data_link_id]" }
      rename => { "[zeek][opcua_binary_variant_metadata][variant_data_array_multi_dim_link_id]" => "[zeek][opcua_binary_variant_array_dims][array_dim_link_id]" }
      rename => { "[zeek][opcua_binary_variant_data][variant_data_status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_variant_data][variant_data_diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_variant_data][variant_data_ext_obj_link_id]" => "[zeek][opcua_binary_variant_extension_object][ext_obj_link_id]" }
      rename => { "[zeek][opcua_binary_variant_data][variant_data_value_link_id]" => "[zeek][opcua_binary_variant_data_value][variant_data_value_source_link]" }
      rename => { "[zeek][opcua_binary_variant_data_value][status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_create_monitored_items_create_item][filter_info_details_link_id]" => "[zeek][opcua_binary][filter_source_link_id]" }
      rename => { "[zeek][opcua_binary_data_change_filter][monitored_parameters_link_id]" => "[zeek][opcua_binary][filter_source_link_id]" }
      rename => { "[zeek][opcua_binary_aggregate_filter][monitored_parameters_link_id]" => "[zeek][opcua_binary][filter_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter][monitored_parameters_link_id]" => "[zeek][opcua_binary][filter_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter][select_clause_link_id]" => "[zeek][opcua_binary_event_filter_select_clause][select_clause_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter][where_clause_content_filter_link_id]" => "[zeek][opcua_binary_event_filter_where_clause][where_clause_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_where_clause][content_filter_element_link_id]" => "[zeek][opcua_binary_event_filter_where_clause_elements][content_filter_element_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_where_clause][content_filter_status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_where_clause][content_filter_diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_where_clause_elements][content_filter_filter_operand_link_id]" => "[zeek][opcua_binary][operand_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_where_clause_elements][content_filter_operand_status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_where_clause_elements][content_filter_operand_diag_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_select_clause][simple_attribute_operand_browse_path_link_id]" => "[zeek][opcua_binary_event_filter_simple_attribute_operand_browse_paths][simple_attribute_operand_browse_path_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_select_clause][select_clause_status_code_link_id]" => "[zeek][opcua_binary_status_code_detail][status_code_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_select_clause][select_clause_diagnostic_info_link_id]" => "[zeek][opcua_binary_diag_info_detail][diag_info_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_simple_attribute_operand][content_filter_filter_operand_link_id]" => "[zeek][opcua_binary][operand_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_simple_attribute_operand][simple_attribute_operand_browse_path_link_id]" => "[zeek][opcua_binary_event_filter_simple_attribute_operand_browse_paths][simple_attribute_operand_browse_path_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_attribute_operand][content_filter_filter_operand_link_id]" => "[zeek][opcua_binary][operand_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_attribute_operand][browse_path_element_link_id]" => "[zeek][opcua_binary_event_filter_attribute_operand_browse_paths][browse_path_element_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_element_operand][content_filter_filter_operand_link_id]" => "[zeek][opcua_binary][operand_source_link_id]" }
      rename => { "[zeek][opcua_binary_event_filter_literal_operand][content_filter_filter_operand_link_id]" => "[zeek][opcua_binary][operand_source_link_id]" }
    }

    # count the number of contributing "log types" after we've renamed stuff
    ruby {
        id => "ruby_zeek_opcua_binary_log_types"
        code => "
            zeekHash = event.get('[zeek]')
            if !zeekHash.nil? && zeekHash.is_a?(Hash) then
              event.set('[zeek][opcua_binary][log_types]', zeekHash.count { |_, v| v.is_a?(Hash) })
            end
        "
    }

    if ([zeek][opcua_binary_activate_session][ext_obj_password]) {
      mutate { id => "mutate_merge_zeek_opcua_binary_activate_session_ext_obj_password"
               merge => { "[related][password]" => "[zeek][opcua_binary_activate_session][ext_obj_password]" } }
    }

    if ([zeek][opcua_binary_activate_session][ext_obj_user_name]) {
      mutate { id => "mutate_merge_zeek_opcua_binary_activate_session_ext_obj_user_name"
               merge => { "[related][user]" => "[zeek][opcua_binary_activate_session][ext_obj_user_name]" } }
    }

    if ([zeek][opcua_binary_create_session_user_token][user_token_policy_id]) {
      mutate { id => "mutate_merge_zeek_opcua_binary_create_session_user_token_user_token_policy_id"
               merge => { "[related][user]" => "[zeek][opcua_binary_create_session_user_token][user_token_policy_id]" } }
    }

    if ([zeek][opcua_binary_get_endpoints_user_token][user_token_policy_id]) {
      mutate { id => "mutate_merge_zeek_opcua_binary_get_endpoints_user_token_user_token_policy_id"
               merge => { "[related][user]" => "[zeek][opcua_binary_get_endpoints_user_token][user_token_policy_id]" } }
    }

    if ([zeek][opcua_binary_activate_session][ext_obj_policy_id]) and
       ([zeek][opcua_binary_activate_session][ext_obj_type_id_str] =~ /(User(Name)?IdentityToken|AnonymousIdentityToken)/) {
      mutate { id => "mutate_merge_zeek_opcua_binary_activate_session_ext_obj_policy_id"
               merge => { "[related][user]" => "[zeek][opcua_binary_activate_session][ext_obj_policy_id]" } }
    }

    if ([zeek][opcua_binary_create_session_endpoints][text]) {
      mutate { id => "mutate_add_field_zeek_opcua_binary_create_session_endpoints_text_software_name"
               add_field => { "[zeek][software][name]" => "%{[zeek][opcua_binary_create_session_endpoints][text]}" } }
      mutate { id => "mutate_add_field_zeek_opcua_binary_create_session_endpoints_text_software_type"
               add_field => { "[zeek][software][software_type]" => "OPCUA" } }
    }

    if ([zeek][opcua_binary_get_endpoints_description][text]) {
      mutate { id => "mutate_add_field_zeek_opcua_binary_get_endpoints_description_text_software_name"
               add_field => { "[zeek][software][name]" => "%{[zeek][opcua_binary_get_endpoints_description][text]}" } }
      mutate { id => "mutate_add_field_zeek_opcua_binary_get_endpoints_description_text_software_type"
               add_field => { "[zeek][software][software_type]" => "OPCUA" } }
    }

  } else if ([log_source] == "ospf") {
    #############################################################################################################################
    # ospf.log specific logic

    mutate { id => "mutate_split_zeek_ospf_neighbors"
             split => { "[zeek][ospf][neighbors]" => "," } }
    mutate { id => "mutate_split_zeek_ospf_routers"
             split => { "[zeek][ospf][routers]" => "," } }
    mutate { id => "mutate_split_zeek_ospf_metrics"
             split => { "[zeek][ospf][metrics]" => "," } }
    mutate { id => "mutate_split_zeek_ospf_fwd_addrs"
             split => { "[zeek][ospf][fwd_addrs]" => "," } }
    mutate { id => "mutate_split_zeek_ospf_route_tags"
             split => { "[zeek][ospf][route_tags]" => "," } }
    mutate { id => "mutate_split_zeek_link_prefixes"
             split => { "[zeek][ospf][link_prefixes]" => "," } }
    mutate { id => "mutate_split_zeek_intra_prefixes"
             split => { "[zeek][ospf][intra_prefixes]" => "," } }

  } else if ([log_source] == "pe") {
    #############################################################################################################################
    # pe.log specific logic

    mutate { id => "mutate_split_zeek_pe_section_names"
             split => { "[zeek][pe][section_names]" => "," } }

  } else if ([log_source] == "radius") {
    #############################################################################################################################
    # radius.log specific logic

    if ([related][user]) { mutate { id => "mutate_merge_zeek_radius_user"
                                    merge => { "[radius][user]" => "[related][user]" } } }

    if ([zeek][radius][framed_addr]) {
      mutate { id => "mutate_merge_zeek_radius_framed_addr"
               merge => { "[radius][framedIp]" => "[zeek][radius][framed_addr]" } }
    }

    if ([zeek][radius][tunnel_client]) {
      mutate { id => "mutate_merge_zeek_radius_tunnel_client"
               merge => { "[radius][endpointIp]" => "[zeek][radius][tunnel_client]" } }
    }

    if ([zeek][radius][mac]) {
      mutate { id => "mutate_merge_zeek_radius_mac"
               merge => { "[radius][mac]" => "[zeek][radius][mac]" } }
      if (![source][mac]) {
        mutate { id => "mutate_merge_zeek_radius_zeek_mac"
                 merge => { "[source][mac]" => "[zeek][radius][mac]" } }
      }
    }

  } else if ([log_source] == "rdp") {
    #############################################################################################################################
    # rdp.log specific logic

    mutate { id => "mutate_split_zeek_rdp_client_channels"
             split => { "[zeek][rdp][client_channels]" => "," } }

  } else if ([log_source] == "s7comm_read_szl") {
    #############################################################################################################################
    # s7comm_read_szl.log specific logic

    # so we can link s7comm and s7comm_read_szl by this field
    mutate { id => "mutate_rename_zeek_s7comm_read_szl_pdu_reference"
             rename => { "[zeek][s7comm_read_szl][pdu_reference]" => "[zeek][s7comm][pdu_reference]" } }

  } else if ([log_source] == "s7comm_upload_download") {
    #############################################################################################################################
    # s7comm_upload_download.log specific logic

    # so we can link s7comm and s7comm_upload_download by this field
    mutate { id => "mutate_rename_zeek_s7comm_upload_download_pdu_reference"
             rename => { "[zeek][s7comm_upload_download][pdu_reference]" => "[zeek][s7comm][pdu_reference]" } }

  } else if ([log_source] == "signatures") {
    #############################################################################################################################
    # signatures.log specific logic
    #
    # this has been reworked significantly from its original form to normalize to ECS along with suricata.alert.*

    if ("_carved" in [tags]) {
      # Malcolm does some "special" stuff in zeek_carve_logger.py for file carving, sort of hijacking signatures.log for it

      # _carved signature logs' sub_message contains fuid(s) comma-separated
      if ([zeek][signatures][sub_message]) {
        mutate { id => "mutate_split_zeek_signatures_sub_message"
                 split => { "[zeek][signatures][sub_message]" => "," } }
        mutate { id => "mutate_rename_zeek_signatures_sub_message"
                 rename => { "[zeek][signatures][sub_message]" => "[zeek][fuid]" } }
      }

      if ([zeek][signatures][event_message]) {
        # sub_message contains "Signature [Engine]" list semi-colon separated
        ruby {
            id => "ruby_zeek_signatures_event_message_parse"
            code => "
                matchesHash = Hash.new
                idArray = Array.new
                event.get('[zeek][signatures][event_message]').split(';').each { |hit|
                  nameAndEngines = hit.split(/(.+?)\s*<(.+)>/)
                  nameAndEngines[2].split(',').each { |engine|
                    unless matchesHash.key?(engine)
                      matchesHash[engine] = Array.new
                    end
                    matchesHash[engine].push(nameAndEngines[1])
                    idArray.push(nameAndEngines[1])
                  }
                }
                event.set('[zeek][signatures][hits]', matchesHash)
                event.set('[event][module]', matchesHash.keys)
                event.set('[event][hits]', matchesHash.length)
                event.set('[rule][name]', idArray.uniq)
            "
        }
      }

    } else {
      # not _carved, actual zeek signatures.log entries

      if ([zeek][signatures][signature_id]) {
        if ([zeek][signatures][signature_id] =~ /^dpd_/) {
          # I don't care about DPD matching signatures
          drop { id => "drop_zeek_ignored_signatures_dpd" }
        } else {
          mutate { id => "mutate_merge_zeen_signature_id_rule_name"
                   merge => { "[rule][name]" => "[zeek][signatures][signature_id]" } }
        }
      }

      if ([zeek][signatures][event_message]) {
        mutate { id => "mutate_add_field_ecs_event_original_signature_event_message"
                 add_field => { "[event][original]" => "%{[zeek][signatures][event_message]}" } }
      }

    } # carved vs not

    if (![event][module]) {
      ruby { id => "ruby_add_field_zeek_signature_event_module"
             code => "event.set('[event][module]', [ 'zeek' ].flatten.reject{ |e| e.nil? || e&.empty? })" }
    }

    # ECS - zeek.signatures.note -> rule.category
    if ([zeek][signatures][note]) {
      mutate { id => "mutate_add_field_ecs_zeek_rule_category_signatures_note"
               merge => { "[rule][category]" => "[zeek][signatures][note]" } }
    }

    if ('Capa' in [event][module]) {
      # ECS - populate threat information for MITRE ATT&CK techniques specified by capa hits
      ruby {
          id => "ruby_signatures_attack_extract"
          # matches array is like: 1) tactic name, 2) technique name, 3) sub-technique name, 4) technique number
          # <MatchData
          #  "Persistence::Create or Modify System Process::Windows Service [ATT&CK T1543.003]"
          #    1:"Persistence"
          #    2:"Create or Modify System Process"
          #    3:"Windows Service"
          #    4:"T1543.003">,
          # <MatchData
          #  "Execution::Shared Modules [ATT&CK T1129]"
          #    1:"Execution"
          #    2:"Shared Modules"
          #    3:nil
          #    4:"T1129">
          init => "
            require 'yaml'; $tacticIdMap = YAML.safe_load(File.read('/etc/mitre_attack_tactic_ids.yaml'));
          "
          code => "
            matches = Array.new
            begin
              event.get('[rule][name]').each do |signature|
                matches.push(/(.+?)::(.+?)(?:::(.+?))?\s*\[ATT&CK\s*(.+?)\]/.match(signature))
              end
            rescue Exception => e
              event.set('ruby_exception', 'ruby_signatures_attack_extract: ' + e.message)
            end
            if (matches.length > 0) then
                tacticNames = matches.map{ |x| x[1].gsub(' ', '_') }.reject{ |e| e.nil? || e&.empty? }
                tacticIds = tacticNames.clone.map(&:clone).map{ |x| $tacticIdMap[x] }.reject{ |e| e.nil? || e&.empty? }
                tacticRefs = tacticIds.clone.map(&:clone).map { |x| x.gsub(/\..*/, '').prepend('https://attack.mitre.org/tactics/') }.uniq.reject{ |e| e.nil? || e&.empty? }
                techniqueNames = matches.map{ |x| [x[2], x[3]].reject{ |e| e.nil? || e&.empty? }.join(':') }.reject{ |e| e.nil? || e&.empty? }
                techniqueIds = matches.map{ |x| x[4] }.reject{ |e| e.nil? || e&.empty? }
                techniqueRefs = techniqueIds.clone.map(&:clone).map { |x| x.gsub(/\..*/, '').prepend('https://attack.mitre.org/techniques/') }.uniq.reject{ |e| e.nil? || e&.empty? }
                event.set('[threat][tactic][name]', tacticNames.uniq) unless (tacticNames.length == 0)
                event.set('[threat][tactic][id]', tacticIds.uniq) unless (tacticIds.length == 0)
                event.set('[threat][tactic][reference]', tacticRefs.uniq) unless (tacticRefs.length == 0)
                event.set('[threat][technique][name]', techniqueNames.uniq) unless (techniqueNames.length == 0)
                event.set('[threat][technique][id]', techniqueIds.uniq) unless (techniqueIds.length == 0)
                event.set('[threat][technique][reference]', techniqueRefs.uniq) unless (techniqueRefs.length == 0)
                event.set('[threat][framework]', 'MITRE ATT&CK')
            end
          "
      }
    } # Capa

    # get more specific than 'Signatures::Sensitive_Signature' if we can
    if ([rule][category]) and ([rule][category][0] == 'Signatures::Sensitive_Signature') {
      if ([threat][tactic][name]) {
        mutate { id => "mutate_merge_zeek_sensitive_signature_tactic"
                 merge => { "[@metadata][zeek_sensitive_signature_replacement]" => "[threat][tactic][name]" } }
      } else if ([threat][technique][name]) {
        mutate { id => "mutate_merge_zeek_sensitive_signature_technique"
                 merge => { "[@metadata][zeek_sensitive_signature_replacement]" => "[threat][technique][name]" } }
      } else if ([threat][framework]) {
        mutate { id => "mutate_merge_zeek_sensitive_signature_framework"
                 merge => { "[@metadata][zeek_sensitive_signature_replacement]" => "[threat][framework]" } }
      }
      if ([@metadata][zeek_sensitive_signature_replacement]) {
        mutate { id => "remove_field_zeek_sensitive_signature"
                 remove_field => [ "[rule][category][0]" ] }
        mutate { id => "mutate_merge_zeek_sensitive_signature_replacement"
                 merge => { "[rule][category]" => "[@metadata][zeek_sensitive_signature_replacement]" } }
      } else if ([event][hits]) and ([event][hits] > 1) {
        mutate { id => "remove_field_zeek_sensitive_signature_multiple"
                 remove_field => [ "[rule][category][0]" ] }
        ruby { id => "ruby_add_field_zeek_multiple_signatures"
               code => "event.set('[rule][category]', [ 'Signatures::Multiple_Signatures', event.get('[rule][category]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
      }
    }

    # remove signature fields that were mapped to ECS
    mutate { id => "mutate_remove_fields_zeek_signatures"
             remove_field => [
              "[zeek][signatures][event_message]",
              "[zeek][signatures][note]" ] }

  } else if ([log_source] == "sip") {
    #############################################################################################################################
    # sip.log specific logic

    ruby {
      id => "ruby_zeek_field_zeek_sip_version"
      code => '
      versions = Array.new
      paths = [event.get("[zeek][sip][request_path]"), event.get("[zeek][sip][response_path]")].reject{ |e| e.nil? || e&.empty? }.join(",")
      paths.scan(/\bSIP:?\/([\d\.]+)/i) { |match| versions << match[0] }
      event.set("[zeek][sip][version]", versions.uniq)'
    }

    mutate { id => "mutate_split_zeek_sip_request_path"
             split => { "[zeek][sip][request_path]" => "," } }

    mutate { id => "mutate_split_zeek_sip_response_path"
             split => { "[zeek][sip][response_path]" => "," } }

    if ([zeek][sip][request_body_len]) { mutate { id => "mutate_add_field_zeek_sip_client_bytes"
                                                 add_field => { "[client][bytes]" => "%{[zeek][sip][request_body_len]}" } } }

    if ([zeek][sip][response_body_len]) { mutate { id => "mutate_add_field_zeek_sip_server_bytes"
                                                  add_field => { "[server][bytes]" => "%{[zeek][sip][response_body_len]}" } } }

  } else if ([log_source] == "smb_cmd") or ([log_source] == "smb_files") {
    #############################################################################################################################
    # smb_cmd.log and smb_files.log specific logic
    # note that smb_cmd.referenced_file is exactly the same structure as the log line for smb_files, which is why I've combined
    # the logic here to avoid duplication

    if ([zeek][smb_cmd]) {

      if ([zeek][smb_cmd][tree]) {
         # translate Zeek's double-backslashes single backslash in filenames
         ruby {
           id => "ruby_zeek_smb_cmd_tree_dedoubleslash"
           path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
           script_params => {
             "source" => "[zeek][smb_cmd][tree]"
             "target" => "[zeek][smb_cmd][tree]"
           }
         }
         # split zeek.smb_cmd.tree to host and service
         ruby {
           id => "ruby_zeek_smb_cmd_tree_split"
           path => "/usr/share/logstash/malcolm-ruby/smbsplit.rb"
           script_params => {
             "source" => "[zeek][smb_cmd][tree]"
             "host" => "[smb][host]"
             "share" => "[smb][share]"
             "path" => "[smb][filename]"
           }
         }
         # if we didn't populate service, fall back to tree_service for share
         if (![smb][share]) and ([zeek][smb_cmd][tree_service]) {
             mutate { id => "mutate_merge_zeek_smb_cmd_tree_service_share"
                      merge => { "[smb][share]" => "[zeek][smb_cmd][tree_service]" } }
         }
      } # if [zeek][smb_cmd][tree]

      if ([zeek][smb_cmd][referenced_file]) {

        # move "up" referenced_file to its own smb_files top-level entity
        mutate {
          id => "mutate_rename_zeek_zeek_smb_cmd_referenced_file"
          rename => { "[zeek][smb_cmd][referenced_file]" => "[zeek][smb_files]" }
        }

        # remove unset (-) or "(empty)" referenced_file (now zeek_smb_files) subfield values
        ruby {
          id => "ruby_zeek_remove_empty_smb_cmd_referenced_file_values"
          path => "/usr/share/logstash/malcolm-ruby/compact_event_hash.rb"
          script_params => {
            "field" => "[zeek][smb_files]"
          }
        }

        # collect referenced file FUID(s) at parent level (here rather than in 12_zeek_normalize.conf because
        # this would have already been done as a root-level fuid array in the main "rename" above if we
        # had not had to move it up a level just now)
        if ([zeek][smb_files][fuid]) {
          mutate { id => "mutate_merge_zeek_smb_files_fuid"
                   merge => { "[zeek][fuid]" => "[zeek][smb_files][fuid]" } }
          mutate { id => "mutate_remove_zeek_smb_files_fuid"
                   remove_field => [ "[zeek][smb_files][fuid]" ] }
        }

        if ([zeek][smb_files][action]) { mutate { id => "mutate_gsub_zeek_smb_cmd_referenced_file_action"
                                                 gsub => [ "[zeek][smb_files][action]", "^SMB::", "" ] } }

      } # if ([zeek][smb_cmd][referenced_file])

    } # if ([zeek][smb_cmd])

    # this should now apply to either lines from smb_files.log or smb_cmd.referenced_file
    if ([zeek][smb_files]) {

      # translate Zeek's double-backslashes single backslash in filenames
      ruby {
        id => "ruby_zeek_smb_files_path_dedoubleslash"
        path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
        script_params => {
          "source" => "[zeek][smb_files][path]"
          "target" => "[zeek][smb_files][path]"
        }
      }
      ruby {
        id => "ruby_zeek_smb_files_name_dedoubleslash"
        path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
        script_params => {
          "source" => "[zeek][smb_files][name]"
          "target" => "[zeek][smb_files][name]"
        }
      }
      ruby {
        id => "ruby_zeek_smb_files_prev_name_dedoubleslash"
        path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
        script_params => {
          "source" => "[zeek][smb_files][prev_name]"
          "target" => "[zeek][smb_files][prev_name]"
        }
      }

      # store smb_files.name and/or smb_files.prev_name as smb.filename for Arkime
      if ([zeek][smb_files][name]) { mutate { id => "mutate_merge_zeek_smb_files_name_to_filename"
                                            merge => { "[smb][filename]" => "[zeek][smb_files][name]" } } }
      if ([zeek][smb_files][prev_name]) { mutate { id => "mutate_merge_zeek_smb_files_prev_name_to_filename"
                                                 merge => { "[smb][filename]" => "[zeek][smb_files][prev_name]" } } }

      # if we have smb_files.path, split into host/share/path
      if ([zeek][smb_files][path]) {
        ruby {
          id => "ruby_zeek_smb_files_path_split"
          path => "/usr/share/logstash/malcolm-ruby/smbsplit.rb"
          script_params => {
            "source" => "[zeek][smb_files][path]"
            "host" => "[smb][host]"
            "share" => "[smb][share]"
            "path" => "[@metadata][smb_files_path]"
          }
        }
      }

      # store appropriate filename in file.name
      if (![smb][filename]) and ([@metadata][smb_files_path]) {
        mutate { id => "mutate_merge_zeek_metadata_smb_files_path_file_name"
                  merge => { "[smb][filename]" => "[@metadata][smb_files_path]" } }
      }

    } # if ([zeek][smb_files])

  } else if ([log_source] == "smb_mapping") {
    #############################################################################################################################
    # smb_mapping.log specific logic

    if ([zeek][smb_mapping][path]) {
      # translate Zeek's double-backslashes single backslash in filenames
      ruby {
        id => "ruby_zeek_smb_mapping_path_dedoubleslash"
        path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
        script_params => {
          "source" => "[zeek][smb_mapping][path]"
          "target" => "[zeek][smb_mapping][path]"
        }
      }
    }

    if ([zeek][smb_mapping][path]) {
      ruby {
        id => "ruby_zeek_smb_mapping_path_split"
        path => "/usr/share/logstash/malcolm-ruby/smbsplit.rb"
        script_params => {
          "source" => "[zeek][smb_mapping][path]"
          "host" => "[smb][host]"
          "share" => "[smb][share]"
          "path" => "[smb][filename]"
        }
      }
    }

  } else if ([log_source] == "smtp") {
    #############################################################################################################################
    # smtp.log specific logic

    mutate { id => "mutate_split_zeek_smtp_rcptto"
             split => { "[zeek][smtp][rcptto]" => "," } }
    mutate { id => "mutate_split_zeek_smtp_to"
             split => { "[zeek][smtp][to]" => "," } }
    mutate { id => "mutate_split_zeek_smtp_cc"
             split => { "[zeek][smtp][cc]" => "," } }
    mutate { id => "mutate_split_zeek_smtp_path"
             split => { "[zeek][smtp][path]" => "," } }

    if ([zeek][smtp][user_agent]) {
      mutate { id => "mutate_merge_zeek_smtp_user_agent"
               merge => { "[email][useragent]" => "[zeek][smtp][user_agent]" } }
    }

    if ([zeek][smtp][from]) { mutate { id => "mutate_merge_zeek_smtp_from"
                                     merge => { "[email][src]" => "[zeek][smtp][from]" } } }
    if ([zeek][smtp][mailfrom]) { mutate { id => "mutate_merge_zeek_smtp_mailfrom"
                                         merge => { "[email][src]" => "[zeek][smtp][mailfrom]" } } }
    if ([zeek][smtp][reply_to]) { mutate { id => "mutate_merge_zeek_smtp_reply_to"
                                         merge => { "[email][src]" => "[zeek][smtp][reply_to]" } } }
    if ([zeek][smtp][to]) { mutate { id => "mutate_merge_zeek_smtp_dst_from_to"
                                   merge => { "[email][dst]" => "[zeek][smtp][to]" } } }
    if ([zeek][smtp][cc]) { mutate { id => "mutate_merge_zeek_smtp_dst_from_cc"
                                   merge => { "[email][dst]" => "[zeek][smtp][cc]" } } }
    if ([zeek][smtp][rcptto]) { mutate { id => "mutate_merge_zeek_dst_from_rcptto"
                                       merge => { "[email][dst]" => "[zeek][smtp][rcptto]" } } }
    if ([zeek][smtp][helo]) {
      mutate { id => "mutate_merge_zeek_smtp_helo"
               merge => { "[email][smtpHello]" => "[zeek][smtp][helo]" } }
    }
    if ([zeek][smtp][subject]) {
      mutate { id => "mutate_merge_zeek_smtp_subject"
               merge => { "[email][subject]" => "[zeek][smtp][subject]" } }
    }

    if ([zeek][smtp][msg_id]) {
      mutate { id => "mutate_gsub_zeek_smtp_msg_id"
               gsub => [ "[zeek][smtp][msg_id]", "(^<|>$)", "" ] }
      mutate { id => "mutate_merge_zeek_smtp_msg_id"
               merge => { "[email][id]" => "[zeek][smtp][msg_id]" } }
    }
    if ([zeek][smtp][in_reply_to]) {
      mutate { id => "mutate_gsub_zeek_smtp_in_reply_to"
               gsub => [ "[zeek][smtp][in_reply_to]", "(^<|>$)", "" ] }
      mutate { id => "mutate_merge_zeek_smtp_in_reply_to"
               merge => { "[email][id]" => "[zeek][smtp][in_reply_to]" } }
    }

    if ([zeek][smtp][last_reply]) {
      # will be mapped to a "result" later in normalization
      grok {
        id => "grok_zeek_zeek_smtp_last_reply"
        match => { "[zeek][smtp][last_reply]" => [ "^%{SPACE}%{NUMBER:[zeek][smtp][last_reply_code]}" ] }
      }
    }

  } else if ([log_source] == "ssh") {
    #############################################################################################################################
    # ssh.log specific logic

    if ([zeek][ssh][server]) { mutate { id => "mutate_merge_zeek_ssh_server_version"
                                       merge => { "[ssh][version]" => "[zeek][ssh][server]" } } }

    if ([zeek][ssh][client]) { mutate { id => "mutate_merge_zeek_client_version"
                                       merge => { "[ssh][version]" => "[zeek][ssh][client]" } } }

    if (![ssh][version]) and ([zeek][ssh][version]) { mutate { id => "mutate_merge_zeek_ssh_version"
                                                              merge => { "[ssh][version]" => "[zeek][ssh][version]" } } }

    if ([zeek][ssh][host_key] and [zeek][ssh][host_key_alg]) {
      # this is stupid, the %{} doesn't seem to be liked by mutate.merge
      mutate { id => "mutate_add_field_zeek_ssh_host_key"
               add_field => { "[@metadata][ssh_key_str]" => "%{[zeek][ssh][host_key_alg]} %{[zeek][ssh][host_key]}" } }
      mutate { id => "mutate_merge_zeek_ssh_key"
               merge => { "[ssh][key]" => "[@metadata][ssh_key_str]" } }
    }

    # HASSH stuff (see https://github.com/salesforce/hassh/tree/master/bro)

    if ([zeek][ssh][hassh]) {
      mutate { id => "mutate_merge_zeek_ssh_hassh"
               merge => { "[ssh][hassh]" => "[zeek][ssh][hassh]" } }
    }

    if ([zeek][ssh][hasshServer]) {
      mutate { id => "mutate_merge_zeek_ssh_hasshServer"
               merge => { "[ssh][hasshServer]" => "[zeek][ssh][hasshServer]" } }
    }

    if ([zeek][ssh][hasshAlgorithms]) { mutate { id => "mutate_split_zeek_ssh_hasshAlgorithms"
                                                split => { "[zeek][ssh][hasshAlgorithms]" => "," } } }

    if ([zeek][ssh][hasshServerAlgorithms]) { mutate { id => "mutate_split_zeek_ssh_hasshServerAlgorithms"
                                                      split => { "[zeek][ssh][hasshServerAlgorithms]" => "," } } }

    if ([zeek][ssh][cshka]) { mutate { id => "mutate_split_zeek_ssh_cshka"
                                      split => { "[zeek][ssh][cshka]" => "," } } }

    if ([zeek][ssh][sshka]) { mutate { id => "mutate_split_zeek_ssh_sshka"
                                      split => { "[zeek][ssh][sshka]" => "," } } }


  } else if ([log_source] == "ssl") {
    #############################################################################################################################
    # ssl.log specific logic

    # split subjects/issuers out into hashes
    # 1. handle escaped commans (urlencode)
    # 2. rename source hashes into metadata for splitting
    # 3. split fields by comma into destination hashes
    # 4. urldecode any commas we might have had

    if ([zeek][ssl][subject]) {
      mutate { id => "mutate_gsub_zeek_ssl_subject"
               gsub => [ "[zeek][ssl][subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_subject"
               rename => { "[zeek][ssl][subject]" => "[zeek][ssl][subject_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_subject"
        field_split => ","
        source => "[zeek][ssl][subject_full]"
        target => "[zeek][ssl][subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_subject"
        field => "[zeek][ssl][subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_subject_full"
        field => "[zeek][ssl][subject_full]"
      }
    }

    if ([zeek][ssl][client_subject]) {
      mutate { id => "mutate_gsub_zeek_ssl_client_subject"
               gsub => [ "[zeek][ssl][client_subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_client_subject"
               rename => { "[zeek][ssl][client_subject]" => "[zeek][ssl][client_subject_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_client_subject"
        field_split => ","
        source => "[zeek][ssl][client_subject_full]"
        target => "[zeek][ssl][client_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_subject"
        field => "[zeek][ssl][client_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_subject_full"
        field => "[zeek][ssl][client_subject_full]"
      }
    }

    if ([zeek][ssl][issuer]) {
      mutate { id => "mutate_gsub_zeek_ssl_issuer"
               gsub => [ "[zeek][ssl][issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_issuer"
               rename => { "[zeek][ssl][issuer]" => "[zeek][ssl][issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_issuer"
        field_split => ","
        source => "[zeek][ssl][issuer_full]"
        target => "[zeek][ssl][issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_issuer"
        field => "[zeek][ssl][issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_issuer_full"
        field => "[zeek][ssl][issuer_full]"
      }
    }

    if ([zeek][ssl][client_issuer]) {
      mutate { id => "mutate_gsub_zeek_ssl_client_issuer"
               gsub => [ "[zeek][ssl][client_issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_client_issuer"
               rename => { "[zeek][ssl][client_issuer]" => "[zeek][ssl][client_issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_client_issuer"
        field_split => ","
        source => "[zeek][ssl][client_issuer_full]"
        target => "[zeek][ssl][client_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_issuer"
        field => "[zeek][ssl][client_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_issuer_full"
        field => "[zeek][ssl][client_issuer_full]"
      }
    }

    if ([zeek][ssl][cipher]) {
      # ECS - zeek.ssl.cipher -> tls.cipher
      mutate { id => "mutate_merge_zeek_ssl_cipher"
               merge => { "[tls][cipher]" => "[zeek][ssl][cipher]" } }
    }

    if ([zeek][ssl][ja3]) {
      mutate { id => "mutate_merge_zeek_ssl_ja3"
               merge => { "[tls][ja3]" => "[zeek][ssl][ja3]" } }
    }

    if ([zeek][ssl][ja3s]) {
      mutate { id => "mutate_merge_zeek_ssl_ja3s"
               merge => { "[tls][ja3s]" => "[zeek][ssl][ja3s]" } }
    }

    if ([zeek][ssl][cert_chain_fuids]) { mutate { id => "mutate_split_zeek_ssl_cert_chain_fuids"
                                                 split => { "[zeek][ssl][cert_chain_fuids]" => "," } } }

    if ([zeek][ssl][client_cert_chain_fuids]) { mutate { id => "mutate_split_zeek_ssl_client_cert_chain_fuids"
                                                        split => { "[zeek][ssl][client_cert_chain_fuids]" => "," } } }

    if ([zeek][ssl][cert_chain_fps]) {
      mutate { id => "mutate_split_zeek_ssl_cert_chain_fps"
               split => { "[zeek][ssl][cert_chain_fps]" => "," } }
      # store certificate chain fingerprints in zeek_x509.fingerprint as well for cross-reference with x509.log
      mutate { id => "mutate_merge_zeek_ssl_cert_chain_fps"
               merge => { "[zeek][x509][fingerprint]" => "[zeek][ssl][cert_chain_fps]" } }
      # TODO: zeek.ssl.*cert_chain_fps to:
      #       https://www.elastic.co/guide/en/ecs/current/ecs-tls.html#field-tls-client-hash-md5 (or sha1, sha256, etc.)
      #       https://www.elastic.co/guide/en/ecs/current/ecs-tls.html#field-tls-server-hash-md5 (or sha1, sha256, etc.)
    }

    if ([zeek][ssl][client_cert_chain_fps]) {
      mutate { id => "mutate_split_zeek_ssl_client_cert_chain_fps"
               split => { "[zeek][ssl][client_cert_chain_fps]" => "," } }
      # store certificate chain fingerprints in zeek_x509.fingerprint as well for cross-reference with x509.log
      mutate { id => "mutate_merge_zeek_ssl_client_cert_chain_fps"
               merge => { "[zeek][x509][fingerprint]" => "[zeek][ssl][client_cert_chain_fps]" } }
    }

    # ECS - zeek.ssl.ssl_version -> tls.version and tls.version_protocol
    if ([zeek][ssl][ssl_version]) {
      # turn TLSv10, TLSv13, TSLv12, etc. to 'tls' and '1.2', etc.
      ruby {
        id => "ruby_ecs_ssl_version_parse"
        code => "
          verMatch = event.get('[zeek][ssl][ssl_version]').tr('.', '').match(/(.+)\s*[v-]\s*([\d\.]+)/i)
          verParts = verMatch.nil? ? nil : verMatch.captures
          unless verParts.nil?
            event.set('[tls][version_protocol]', verParts[0].downcase)
            event.set('[tls][version]', verParts[1].split(//).join('.'))
          end
        "
      }
    }

    # ECS - zeek.ssl.established -> tls.established
    if ([zeek][ssl][established]) {          mutate { id => "mutate_add_field_ecs_zeek_tls_established"
                                                     add_field => { "[tls][established]" => "%{[zeek][ssl][established]}" } } }

    # ECS - zeek.ssl.resumed -> tls.resumed
    if ([zeek][ssl][resumed]) {              mutate { id => "mutate_add_field_ecs_zeek_tls_resumed"
                                                     add_field => { "[tls][resumed]" => "%{[zeek][ssl][resumed]}" } } }

    # ECS - zeek.ssl.next_protocol -> tls.next_protocol
    if ([zeek][ssl][next_protocol]) {
      mutate { id => "mutate_add_field_ecs_zeek_tls_next_protocol"
                     add_field => { "[tls][next_protocol]" => "%{[zeek][ssl][next_protocol]}" } }
      mutate { id => "mutate_lowercase_field_ecs_zeek_tls_next_protocol"
               lowercase => [ "[tls][next_protocol]" ] }
    }

    # ECS - zeek.ssl.curve -> tls.curve
    if ([zeek][ssl][curve]) {                mutate { id => "mutate_add_field_ecs_zeek_tls_client_curve"
                                                     add_field => { "[tls][curve]" => "%{[zeek][ssl][curve]}" } } }

    # ECS - zeek.ssl.ja3 -> tls.client.ja3
    if ([zeek][ssl][ja3]) {                  mutate { id => "mutate_add_field_ecs_zeek_tls_client_ja3"
                                                     add_field => { "[tls][client][ja3]" => "%{[zeek][ssl][ja3]}" } } }

    # ECS - zeek.ssl.client_issuer_full -> tls.client.issuer
    if ([zeek][ssl][client_issuer_full]) {   mutate { id => "mutate_add_field_ecs_zeek_tls_client_issuer_full"
                                                     add_field => { "[tls][client][issuer]" => "%{[zeek][ssl][client_issuer_full]}" } } }

    # ECS - zeek.ssl.client_subject_full -> tls.client.subject
    if ([zeek][ssl][client_subject_full]) {  mutate { id => "mutate_add_field_ecs_zeek_tls_client_subject_full"
                                                     add_field => { "[tls][client][subject]" => "%{[zeek][ssl][client_subject_full]}" } } }

    # ECS - zeek.ssl.server_name -> tls.client.server_name and server.domain
    if ([zeek][ssl][server_name]) {
      mutate { id => "mutate_add_field_ecs_zeek_tls_client_server_name"
               add_field => { "[tls][client][server_name]" => "%{[zeek][ssl][server_name]}" } }
      mutate { id => "mutate_add_field_ecs_zeek_tls_client_server_name_destination_domain"
               add_field => { "[server][domain]" => "%{[zeek][ssl][server_name]}" } }
    }

    # ECS - zeek.ssl.issuer_full -> tls.server.issuer
    if ([zeek][ssl][issuer_full]) {          mutate { id => "mutate_add_field_ecs_zeek_tls_issuer_full"
                                                     add_field => { "[tls][server][issuer]" => "%{[zeek][ssl][issuer_full]}" } } }

    # ECS - zeek.ssl.ja3s -> tls.server.ja3s
    if ([zeek][ssl][ja3s]) {                 mutate { id => "mutate_add_field_ecs_zeek_tls_server_ja3s"
                                                     add_field => { "[tls][server][ja3s]" => "%{[zeek][ssl][ja3s]}" } } }

    # ECS - zeek.ssl.subject_full -> tls.server.subject
    if ([zeek][ssl][subject_full]) {         mutate { id => "mutate_add_field_ecs_zeek_tls_subject_full"
                                                     add_field => { "[tls][server][subject]" => "%{[zeek][ssl][subject_full]}" } } }

  } else if ([log_source] == "stun") {
    #############################################################################################################################
    # stun.log specific logic

    if ([zeek][stun][attr_type]) {
      mutate { id => "mutate_split_field_zeek_stun_attr_type"
               split => { "[zeek][stun][attr_type]" => "," } }
    }

  } else if ([log_source] == "stun_nat") {
    #############################################################################################################################
    # stun_nat.log specific logic

    # ECS - zeek.stun_nat.wan_addr -> source.nat.ip
    if ([zeek][stun_nat][wan_addr]) {    mutate { id => "mutate_add_field_ecs_zeek_stun_nat_wan_addr"
                                                  add_field => { "[source][nat][ip]" => "%{[zeek][stun_nat][wan_addr]}" } } }

    # ECS - zeek.stun_nat.wan_port -> source.nat.port
    if ([zeek][stun_nat][wan_port]) {    mutate { id => "mutate_add_field_ecs_zeek_stun_nat_wan_port"
                                                  add_field => { "[source][nat][port]" => "%{[zeek][stun_nat][wan_port]}" } } }

  } else if ([log_source] =~ /^synchrophasor/) {

    mutate {
      id => "mutate_rename_synchrophasor_fields"
      rename => { "[zeek][synchrophasor_cfg][data_rate]" => "[zeek][synchrophasor][data_rate]" }
      rename => { "[zeek][synchrophasor_cfg][frame_size]" => "[zeek][synchrophasor][frame_size]" }
      rename => { "[zeek][synchrophasor_cfg][frame_type]" => "[zeek][synchrophasor][frame_type]" }
      rename => { "[zeek][synchrophasor_cfg][header_time_stamp]" => "[zeek][synchrophasor][header_time_stamp]" }
      rename => { "[zeek][synchrophasor_cfg_detail][frame_type]" => "[zeek][synchrophasor][frame_type]" }
      rename => { "[zeek][synchrophasor_cfg_detail][header_time_stamp]" => "[zeek][synchrophasor][header_time_stamp]" }
      rename => { "[zeek][synchrophasor_cmd][frame_size]" => "[zeek][synchrophasor][frame_size]" }
      rename => { "[zeek][synchrophasor_cmd][frame_type]" => "[zeek][synchrophasor][frame_type]" }
      rename => { "[zeek][synchrophasor_cmd][header_time_stamp]" => "[zeek][synchrophasor][header_time_stamp]" }
      rename => { "[zeek][synchrophasor_data][frame_size]" => "[zeek][synchrophasor][frame_size]" }
      rename => { "[zeek][synchrophasor_data][frame_type]" => "[zeek][synchrophasor][frame_type]" }
      rename => { "[zeek][synchrophasor_data][header_time_stamp]" => "[zeek][synchrophasor][header_time_stamp]" }
      rename => { "[zeek][synchrophasor_data_detail][frame_type]" => "[zeek][synchrophasor][frame_type]" }
      rename => { "[zeek][synchrophasor_data_detail][header_time_stamp]" => "[zeek][synchrophasor][header_time_stamp]" }
      rename => { "[zeek][synchrophasor_hdr][frame_size]" => "[zeek][synchrophasor][frame_size]" }
      rename => { "[zeek][synchrophasor_hdr][frame_type]" => "[zeek][synchrophasor][frame_type]" }
      rename => { "[zeek][synchrophasor_hdr][header_time_stamp]" => "[zeek][synchrophasor][header_time_stamp]" }
    }

    mutate {
      id => "mutate_split_synchrophasor_fields"
      split => { "[zeek][synchrophasor_cfg_detail][analog_conv_analog_flags]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][analog_conv_mag_scale]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][analog_conv_offset]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][analog_conv_user_defined_scaling]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][annam]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][dgnam]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][digital_conv_normal_status_mask]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][digital_conv_valid_inputs_mask]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_angle_adj]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_calibration_mag_adj]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_calibration_phas_adj]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_downsampled_fir_filter]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_downsampled_no_fir_filter]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_downsampled_reselection]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_filtered_without_changing_sampling]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_mod_appl]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_phasor_component]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_phasor_type]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_phunit]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_phvalue]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_pseudo_phasor_val]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_rotation_phase_adj]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_scale_factor]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_upsampled_extrapolation]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_upsampled_interpolation]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phasor_conv_user_def]" => "," }
      split => { "[zeek][synchrophasor_cfg_detail][phnam]" => "," }
      split => { "[zeek][synchrophasor_cmd][extframe]" => "," }
      split => { "[zeek][synchrophasor_data_detail][analog_data]" => "," }
      split => { "[zeek][synchrophasor_data_detail][digital]" => "," }
      split => { "[zeek][synchrophasor_data_detail][est_polar_angle]" => "," }
      split => { "[zeek][synchrophasor_data_detail][est_polar_magnitude]" => "," }
      split => { "[zeek][synchrophasor_data_detail][est_rectangular_imaginary]" => "," }
      split => { "[zeek][synchrophasor_data_detail][est_rectangular_real]" => "," }
    }

    if ([zeek][synchrophasor][frame_size]) {
      mutate { id => "mutate_add_field_totDataBytes_zeek_synchrophasor_frame_size"
               add_field => { "[totDataBytes]" => "%{[zeek][synchrophasor][frame_size]}" } }
    }
    if ([zeek][synchrophasor][frame_size_tot]) {
      mutate { id => "mutate_add_field_totDataBytes_zeek_synchrophasor_frame_size_tot"
               add_field => { "[totDataBytes]" => "%{[zeek][synchrophasor][frame_size_tot]}" } }
    }

  } else if ([log_source] == "tds_rpc") {
    #############################################################################################################################
    # tds_rpc.log specific logic

    if ([zeek][tds_rpc][parameter]) {
      ruby {
        id => "ruby_zeek_tds_rpc_parse_parameter"
        code => "
          parameterHash = event.get('[zeek][tds_rpc][parameter]').split(',').each_with_object({}) do |a, hash|
            key,value = a.split(/\s*=\s*/)
            hash[key.to_s.delete_prefix('@')] = value
          end
          event.set('[zeek][tds_rpc][parameters]', parameterHash.reject{|k,v| k.nil? || v.nil? || k.empty? || v.empty?})"
      }

      mutate { id => "mutate_split_field_tds_rpc_parameter"
               split => { "[zeek][tds_rpc][parameter]" => "," } }
    }

  } else if ([log_source] == "weird") {
    #############################################################################################################################
    # weird.log specific logic

    if ([zeek][weird][name]) {
      # ECS - "Zeek" -> rule.author
      mutate { id => "mutate_add_field_ecs_rule_author_zeek_weird"
               add_field => { "[rule][author]" => "Zeek" } }
      # ECS - zeek weird URL -> rule.reference
      mutate { id => "mutate_add_field_ecs_rule_reference_zeek_weird"
               add_field => { "[rule][reference]" => "https://docs.zeek.org/en/current/scripts/base/frameworks/notice/weird.zeek.html" } }
      # ECS - zeek.weird.name -> rule.name
      ruby { id => "ruby_add_field_ecs_zeek_rule_name_weird_name"
             code => "event.set('[rule][name]', [ event.get('[zeek][weird][name]'), event.get('[rule][name]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
    }

    ruby {
      id => "ruby_add_field_zeek_weird_event_original"
      code => " event.set('[event][original]', [event.get('[zeek][weird][name]'),
                                                event.get('[zeek][weird][addl]')].reject{ |e| e.nil? || e&.empty? }.join(':'))" }

    # remove signature fields that were mapped to ECS or not useful
    mutate { id => "mutate_remove_fields_zeek_weird"
             remove_field => [
              "[zeek][weird][name]",
              "[zeek][weird][peer]" ] }

  } else if ([log_source] == "x509") {
    #############################################################################################################################
    # x509.log specific logic

    # split subject/issuer out into hashes
    # 1. handle escaped commans (urlencode)
    # 2. rename source hashes into metadata for splitting
    # 3. split fields by comma into destination hashes
    # 4. urldecode any commas we might have had

    if ([zeek][x509][certificate_subject]) {
      mutate { id => "mutate_gsub_zeek_x509_certificate_subject"
               gsub => [ "[zeek][x509][certificate_subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_x509_certificate_subject"
               rename => { "[zeek][x509][certificate_subject]" => "[zeek][x509][certificate_subject_full]" } }
      kv {
        id => "mutate_kv_zeek_x509_certificate_subject"
        field_split => ","
        source => "[zeek][x509][certificate_subject_full]"
        target => "[zeek][x509][certificate_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_subject"
        field => "[zeek][x509][certificate_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_subject_full"
        field => "[zeek][x509][certificate_subject_full]"
      }
      if ([zeek][x509][certificate_subject][CN]) {
        mutate { id => "mutate_merge_zeek_x509_certificate_subject_CN"
                 merge => { "[@metadata][cert][subjectCN]" => "[zeek][x509][certificate_subject][CN]" } }
      }
      if ([zeek][x509][certificate_subject][O]) {
        mutate { id => "mutate_add_zeek_x509_certificate_subject_O"
                 add_field => { "[@metadata][cert][subjectON]" => "%{[zeek][x509][certificate_subject][O]}" } }
      }
    }

    if ([zeek][x509][certificate_issuer]) {
      mutate { id => "mutate_gsub_zeek_x509_certificate_issuer"
               gsub => [ "[zeek][x509][certificate_issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_x509_certificate_issuer"
               rename => { "[zeek][x509][certificate_issuer]" => "[zeek][x509][certificate_issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_x509_certificate_issuer"
        field_split => ","
        source => "[zeek][x509][certificate_issuer_full]"
        target => "[zeek][x509][certificate_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_issuer"
        field => "[zeek][x509][certificate_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_issuer_full"
        field => "[zeek][x509][certificate_issuer_full]"
      }
      if ([zeek][x509][certificate_issuer][CN]) {
        mutate { id => "mutate_merge_zeek_x509_certificate_issuer_CN"
                 merge => { "[@metadata][cert][issuerCN]" => "[zeek][x509][certificate_issuer][CN]" } }
      }
      if ([zeek][x509][certificate_issuer][O]) {
        mutate { id => "mutate_add_zeek_x509_certificate_issuer_O"
                 add_field => { "[@metadata][cert][issuerON]" => "%{[zeek][x509][certificate_issuer][O]}" } }
      }
    }

    if ([zeek][x509][certificate_not_valid_before]) and ([zeek][x509][certificate_not_valid_after]) {
      ruby {
        id => "ruby_zeek_x509_valid_range"
        code => "event.set('[@metadata][cert][notBefore]', (1000*event.get('[zeek][x509][certificate_not_valid_before]').to_f).round(0))
                 event.set('[@metadata][cert][notAfter]', (1000*event.get('[zeek][x509][certificate_not_valid_after]').to_f).round(0))
                 event.set('[@metadata][cert][validDays]', ((event.get('[zeek][x509][certificate_not_valid_after]').to_f - event.get('[zeek][x509][certificate_not_valid_before]').to_f)/(24.0*60.0*60.0)).round(0))"
      }
      mutate {
        id => "mutate_convert_zeek_x509_time_range"
        convert => {
          "[@metadata][cert][notBefore]" => "integer"
          "[@metadata][cert][notAfter]" => "integer"
          "[@metadata][cert][validDays]" => "float"
        }
      }
    }

    if ([zeek][x509][certificate_serial]) {
      # todo: serial not showing up right...
      # ruby {
      #  id => "ruby_zeek_x509_serial"
      #  code => "event.set('[@metadata][cert][serial]', event.get('[certificate_serial]').unpack('C*').map {|e| e.to_s 16}.join(':'))"
      # }
      mutate { id => "mutate_add_field_zeek_x509_serial"
               add_field => { "[@metadata][cert][serial]" => "%{[zeek][x509][certificate_serial]}" } }
    }

    if ([@metadata][cert]) {
      ruby {
          id => "ruby_zeek_x509_cert_array_set"
          code => "
              certArray = Array.new
              certArray.push(event.get('[@metadata][cert]'))
              event.set('[cert]', certArray)"
      }
    }

    if ([zeek][x509][san_ip]) { mutate { id => "mutate_split_zeek_x509_san_ip"
                                        split => { "[zeek][x509][san_ip]" => "," } } }

    if ([zeek][x509][fingerprint]) { mutate { id => "mutate_split_zeek_x509_fingerprint"
                                             split => { "[zeek][x509][fingerprint]" => "," } } }

    # TODO: ECS TLS/X509 nestings?
    # - https://www.elastic.co/guide/en/ecs/current/ecs-tls.html#ecs-tls-nestings
    # - https://www.elastic.co/guide/en/ecs/current/ecs-x509.html#_field_reuse_27

  } # end if/else if/else for specific log type logic
  #######################################################################################################

  # rename log_source (eg., conn, ssh, etc.) to event.dataset
  mutate { id => "mutate_rename_zeek_logType"
           rename => { "[log_source]" => "[event][dataset]" } }

  # kind of a unique case, smb_cmd can also be smb_files
  if ([zeek][smb_files]) {

    if ([event][dataset] == "smb_cmd") {
      ruby { id => "ruby_add_field_zeek_tmp_logtype_smb_cmd"
             code => "event.set('[event][dataset]', [ 'smb_files', event.get('[event][dataset]') ].flatten.reject{ |e| e.nil? || e&.empty? })" }
    }

    # ECS - zeek.smb_files.times_created -> file.created
    # ECS - zeek.smb_files.times_accessed -> file.accessed
    # ECS - zeek.smb_files.times_changed -> file.ctime
    # ECS - zeek.smb_files.times_modified -> file.mtime
    # ECS - zeek.smb_files.size -> file.size
    if ([zeek][smb_files][times_created]) {   mutate { id => "mutate_add_field_ecs_smb_created"
                                                      add_field => { "[file][created]" => "%{[zeek][smb_files][times_created]}" } } }

    if ([zeek][smb_files][times_accessed]) {  mutate { id => "mutate_add_field_ecs_smb_accessed"
                                                      add_field => { "[file][accessed]" => "%{[zeek][smb_files][times_accessed]}" } } }

    if ([zeek][smb_files][times_changed]) {   mutate { id => "mutate_add_field_ecs_smb_changed"
                                                      add_field => { "[file][ctime]" => "%{[zeek][smb_files][times_changed]}" } } }

    if ([zeek][smb_files][times_modified]) {  mutate { id => "mutate_add_field_ecs_smb_modified"
                                                      add_field => { "[file][mtime]" => "%{[zeek][smb_files][times_modified]}" } } }

    if ([zeek][smb_files][size]) {            mutate { id => "mutate_add_field_ecs_smb_size"
                                                      add_field => { "[file][size]" => "%{[zeek][smb_files][size]}" } } }

  } # end if ([zeek][smb_files])

  # ECS - event.kind based on event.dataset (https://www.elastic.co/guide/en/ecs/current/ecs-allowed-values-event-kind.html)
  if ([zeek][notice]) or ([zeek][signatures]) or ([zeek][weird]) {
    mutate { id => "mutate_add_field_ecs_event_kind_alert"
             add_field => { "[event][kind]" => "alert" } }
  } else {
    mutate { id => "mutate_add_field_ecs_event_kind_event"
             add_field => { "[event][kind]" => "event" } }
  }

} # end Filter
