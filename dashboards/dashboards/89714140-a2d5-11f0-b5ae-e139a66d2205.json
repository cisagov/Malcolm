{
  "objects": [
    {
      "attributes": {
        "description": "Trees are Malcolm analytics designed to be utilized by analysts to assist in tracking lateral movement across a network.",
        "hits": 0,
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"highlightAll\":false,\"version\":true,\"query\":{\"language\":\"kuery\",\"query\":\"\"},\"filter\":[]}"
        },
        "optionsJSON": "{\"useMargins\":true}",
        "panelsJSON": "[{\"embeddableConfig\":{},\"gridData\":{\"h\":33,\"i\":\"1\",\"w\":8,\"x\":0,\"y\":0},\"panelIndex\":\"1\",\"version\":\"3.3.0\",\"panelRefName\":\"panel_0\"},{\"embeddableConfig\":{},\"gridData\":{\"h\":42,\"i\":\"76ed91be-9cfa-4ab6-97ea-176dff62779a\",\"w\":40,\"x\":8,\"y\":0},\"panelIndex\":\"76ed91be-9cfa-4ab6-97ea-176dff62779a\",\"version\":\"3.3.0\",\"panelRefName\":\"panel_1\"}]",
        "timeRestore": false,
        "title": "Connections Tree",
        "version": 1
      },
      "id": "89714140-a2d5-11f0-b5ae-e139a66d2205",
      "migrationVersion": {
        "dashboard": "7.9.3"
      },
      "namespaces": [
        "default"
      ],
      "references": [
        {
          "id": "df9e399b-efa5-4e33-b0ac-a7668a8ac2b3",
          "name": "panel_0",
          "type": "visualization"
        },
        {
          "id": "ab8b2ef0-a2d3-11f0-b5ae-e139a66d2205",
          "name": "panel_1",
          "type": "visualization"
        }
      ],
      "type": "dashboard",
      "updated_at": "2025-12-02T17:01:24.050Z",
      "version": "WzEyODMsMV0="
    },
    {
      "attributes": {
        "description": "",
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"query\":{\"query\":{\"query_string\":{\"query\":\"*\"}},\"language\":\"lucene\"},\"filter\":[]}"
        },
        "title": "Navigation",
        "uiStateJSON": "{}",
        "version": 1,
        "visState": "{\"title\":\"Navigation\",\"type\":\"markdown\",\"params\":{\"markdown\":\"MALCOLM_NAVIGATION_MARKDOWN_REPLACER\",\"type\":\"markdown\",\"fontSize\":10,\"openLinksInNewTab\":false},\"aggs\":[]}"
      },
      "id": "df9e399b-efa5-4e33-b0ac-a7668a8ac2b3",
      "migrationVersion": {
        "visualization": "7.10.0"
      },
      "namespaces": [
        "default"
      ],
      "references": [],
      "type": "visualization",
      "updated_at": "2025-12-02T16:23:42.854Z",
      "version": "WzEyNjIsMV0="
    },
    {
      "attributes": {
        "description": "Trees are Malcolm analytics designed to be utilized by analysts to assist in tracking lateral movement across a network.",
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": "{\"query\":{\"query\":\"\",\"language\":\"kuery\"},\"filter\":[]}"
        },
        "title": "Trees",
        "uiStateJSON": "{}",
        "version": 1,
        "visState": "{\"title\":\"Trees\",\"type\":\"vega\",\"aggs\":[],\"params\":{\"spec\":\"{\\n  /**\\n    Version: 2.0\\n    Authors:\\n      Mackenzie Zappe (mackenzie.zappe@inl.gov)\\n      Shelby Hiens\\n      Nicholas Donovan\\n      Jessica Rooney\\n    References:\\n      https://vega.github.io/vega/docs/\\n      https://vega.github.io/vega/examples/tree-layout/\\n    Commit:\\n      Corresponds to a0b643c in SMILE-Analytics/trees/release\\n  **/\\n  ##  Set up Vega specification definitions\\n  ##  Pay attention to Vega additions after V5\\n  // ## todo stop on broadcasts\\n  \\\"$schema\\\": \\\"https://vega.github.io/schema/vega/v5.json\\\",\\n  // Make room for binds under the graph\\n  \\\"autosize\\\": {\\n    \\\"type\\\": \\\"fit-x\\\",\\n    \\\"contains\\\": \\\"padding\\\"\\n  },\\n  \\\"padding\\\": {\\n    \\\"left\\\": {\\\"expr\\\": \\\"width/100\\\"},\\n    \\\"top\\\": {\\\"expr\\\": \\\"height/100\\\"},\\n    \\\"right\\\": {\\\"expr\\\": \\\"width/100\\\"},\\n    \\\"bottom\\\": -150\\n  },\\n  ##  --------------------------------------------------------------------------------------------------------------------------\\n  ##  SECTION 0: Config --------------------------------------------------------------------------------------------------------\\n  ##  Define Specification constants like multiple legend positioning\\n  ##  - arguments set in Config WILL be overwritten if redefined later in specification\\n  \\\"config\\\": {\\n    \\\"signals\\\": [\\n      {\\n        \\\"name\\\": \\\"width\\\",\\n        \\\"init\\\": \\\"containerSize()[0]\\\",\\n        \\\"on\\\": [ {\\\"events\\\": \\\"window:resize\\\", \\\"update\\\": \\\"windowSize()[0]*0.6\\\"} ]\\n      },\\n      {\\n        \\\"name\\\": \\\"height\\\",\\n        \\\"init\\\": \\\"containerSize()[1]\\\",\\n        \\\"on\\\": [ {\\\"events\\\": \\\"window:resize\\\", \\\"update\\\": \\\"windowSize()[1]*0.6\\\"} ]\\n      },\\n      // Adjust font scale based on display size\\n      {\\n        \\\"name\\\": \\\"fontScale\\\",\\n        \\\"update\\\": \\\"clamp(min(width / 1920, height / 1080), 0.3, 1.3)\\\"\\n      },\\n      {\\n        \\\"name\\\": \\\"paddingScale\\\",\\n        \\\"update\\\": \\\"clamp(min(width / 1920, height / 1080), 0.5, 2)\\\"\\n      },\\n      {\\n        \\\"name\\\": \\\"labelFontSize\\\",\\n        \\\"init\\\": \\\"16 * fontScale\\\"\\n      },\\n      {\\n        \\\"name\\\": \\\"titleFontSize\\\",\\n        \\\"init\\\": \\\"20 * fontScale\\\"\\n      },\\n      // Warn if data truncated\\n      {\\n        \\\"name\\\": \\\"maxDataSize\\\",\\n        \\\"value\\\": 10000\\n      },\\n      {\\n        \\\"name\\\": \\\"dataMaxed\\\",\\n        \\\"update\\\": \\\"length(data('table')) >= maxDataSize\\\"\\n      },\\n      {\\n        \\\"name\\\": \\\"maxedWarning\\\", // Warning to display to user if number of documents being processed exceeds 10k per Vega limitation\\n        \\\"update\\\": \\\"dataMaxed ? warn('Maximum data response reached. Data may be truncated. Try adjusting timeframe.') : null\\\"\\n      },\\n      {\\n        \\\"name\\\": \\\"labelOffset\\\",\\n        \\\"value\\\": 15\\n      }\\n    ],\\n    \\\"axis\\\": {\\n      \\\"titleFontSize\\\": {\\n        \\\"signal\\\": \\\"titleFontSize\\\"\\n      },\\n      \\\"titlePadding\\\": {\\n        \\\"signal\\\": \\\"25 * paddingScale\\\"\\n      },\\n      \\\"labelFontSize\\\": {\\n        \\\"signal\\\": \\\"labelFontSize * .9\\\"\\n      },\\n      \\\"tickWidth\\\": 3\\n    },\\n    \\\"title\\\": {\\n      \\\"fontSize\\\": {\\n        \\\"signal\\\": \\\"titleFontSize * 1.2\\\"\\n      }\\n    },\\n    \\\"legend\\\": {\\n      \\\"titleFontSize\\\": {\\n        \\\"signal\\\": \\\"titleFontSize * 0.9\\\"\\n      },\\n      \\\"labelFontSize\\\": {\\n        \\\"signal\\\": \\\"labelFontSize\\\"\\n      },\\n      \\\"padding\\\": {\\n        \\\"signal\\\": \\\"10 * paddingScale\\\"\\n      }\\n    },\\n    \\\"text\\\": {\\n      \\\"fontSize\\\": {\\n        \\\"signal\\\": \\\"labelFontSize * 0.9\\\"\\n      },\\n      \\\"baseline\\\": \\\"middle\\\"\\n    },\\n    \\\"rule\\\": {\\n      \\\"strokeWidth\\\": 0.2,\\n      \\\"stroke\\\": \\\"firebrick\\\"\\n    }\\n  },\\n  ##  ---------------------------------------------------------------------------------------------------------------------------\\n  ##  SECTION 1: Signals --------------------------------------------------------------------------------------------------------\\n  ##  - Define dynamic variables (Signals) that can be updated at any point during the specification\\n  \\\"signals\\\": [\\n    //    logs into console run `VEGA_DEBUG.view.logLevel(3)` in console first\\n    //    {\\n    //      \\\"name\\\": \\\"logger\\\",\\n    //      \\\"on\\\": [\\n    //        {\\n    //          \\\"events\\\": {\\\"signal\\\":  \\\"clear\\\"},\\n    //          \\\"update\\\": \\\"info(clear)\\\"\\n    //        }\\n    //      ],\\n    //    },\\n\\n    // Dynamic resizing signals based off window size\\n    {\\n      \\\"name\\\": \\\"width\\\",\\n      //\\\"value\\\": \\\"width\\\",\\n      \\\"on\\\": [ {\\\"events\\\": \\\"window:resize\\\", \\\"update\\\": \\\"windowSize()[0]*0.6\\\"} ]\\n    },\\n    {\\n      \\\"name\\\": \\\"height\\\",\\n      //\\\"value\\\": \\\"height\\\",\\n      \\\"on\\\": [ {\\\"events\\\": \\\"window:resize\\\", \\\"update\\\": \\\"windowSize()[1]*0.6\\\"} ]\\n    },\\n    // Zoom-related signals\\n    // Sets the custom domain range (x-axis) that is informed by autosize\\n    {\\n      \\\"name\\\": \\\"xrange\\\",\\n      \\\"update\\\": \\\"[0, width]\\\" // width is automatically defined based on autosize at top of scheme\\n    },\\n    {\\n    // Sets the custom range range (y-axis) that is informed by autosize\\n      \\\"name\\\": \\\"yrange\\\",\\n      \\\"update\\\": \\\"[height, 0]\\\" // height is automatically defined based on autosize at top of scheme\\n    },\\n    {\\n    // determines extent of domain -  Updated by 'xdom' signal\\n      \\\"name\\\": \\\"xext\\\",\\n      \\\"update\\\": \\\"[0, width]\\\"\\n    },\\n    {\\n    // determines extent of range -  Updated by 'ydom' signal\\n      \\\"name\\\": \\\"yext\\\",\\n      \\\"update\\\": \\\"[height, 0]\\\"\\n    },\\n    // Signal used to capture whether the user is pressing down and dragging at a certain spot in the visual\\n    {\\n      \\\"name\\\": \\\"down\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"mouseup,touchend\\\",\\n          \\\"update\\\": \\\"null\\\"\\n        },\\n        {\\n          \\\"events\\\": \\\"mousedown, touchstart\\\",\\n          \\\"update\\\": \\\"xy()\\\"\\n        },\\n        {\\n          \\\"events\\\": \\\"symbol:mousedown, symbol:touchstart\\\",\\n          \\\"update\\\": \\\"null\\\"\\n        }\\n      ]\\n    },\\n    // determines the x-position of the current cursor position as moved by the user\\n    {\\n      \\\"name\\\": \\\"xcur\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"mousedown, touchstart, touchend\\\",\\n          \\\"update\\\": \\\"xdom\\\"\\n        }\\n      ]\\n    },\\n    // determines the y-position of the current cursor position as moved by the user\\n    {\\n      \\\"name\\\": \\\"ycur\\\",\\n      \\\"value\\\": null,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"mousedown, touchstart, touchend\\\",\\n          \\\"update\\\": \\\"ydom\\\"\\n        }\\n      ]\\n    },\\n    // calculates position of where the mouse wants the center of the visual to be\\n    {\\n      \\\"name\\\": \\\"delta\\\",\\n      \\\"value\\\": [0, 0],\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": [\\n            {\\n              \\\"source\\\": \\\"window\\\",\\n              \\\"type\\\": \\\"mousemove\\\",\\n              \\\"consume\\\": true,\\n              \\\"between\\\": [\\n                {\\n                  \\\"type\\\": \\\"mousedown\\\"\\n                },\\n                {\\n                  \\\"source\\\": \\\"window\\\",\\n                  \\\"type\\\": \\\"mouseup\\\"\\n                }\\n              ]\\n            },\\n            {\\n              \\\"type\\\": \\\"touchmove\\\",\\n              \\\"consume\\\": true,\\n              \\\"filter\\\": \\\"event.touches.length === 1\\\"\\n            }\\n          ],\\n          \\\"update\\\": \\\"down ? [down[0]-x(), y()-down[1]] : [0,0]\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"anchor\\\",\\n      \\\"value\\\": [0, 0],\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"wheel\\\",\\n          \\\"update\\\": \\\"[invert('xscale', x()), invert('yscale', y())]\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"type\\\": \\\"touchstart\\\",\\n            \\\"filter\\\": \\\"event.touches.length===2\\\"\\n          },\\n          \\\"update\\\": \\\"[(xdom[0] + xdom[1]) / 2, (ydom[0] + ydom[1]) / 2]\\\"\\n        }\\n      ]\\n    },\\n    // if the user moves the mouse wheel/zooms on trackpad, do calculations to determine visual positions\\n    {\\n      \\\"name\\\": \\\"zoom\\\",\\n      \\\"value\\\": 1,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"wheel!\\\",\\n          \\\"force\\\": true,\\n          \\\"update\\\": \\\"pow(1.001, event.deltaY * pow(16, event.deltaMode))\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"dist2\\\"\\n          },\\n          \\\"force\\\": true,\\n          \\\"update\\\": \\\"dist1 / dist2\\\"\\n        },\\n        {\\n          \\\"events\\\": [\\n            {\\n              \\\"source\\\": \\\"view\\\",\\n              \\\"type\\\": \\\"dblclick\\\"\\n            }\\n          ],\\n          \\\"update\\\": \\\"1\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"dist1\\\",\\n      \\\"value\\\": 0,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"type\\\": \\\"touchstart\\\",\\n            \\\"filter\\\": \\\"event.touches.length===2\\\"\\n          },\\n          \\\"update\\\": \\\"pinchDistance(event)\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"dist2\\\"\\n          },\\n          \\\"update\\\": \\\"dist2\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"dist2\\\",\\n      \\\"value\\\": 0,\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"type\\\": \\\"touchmove\\\",\\n            \\\"consume\\\": true,\\n            \\\"filter\\\": \\\"event.touches.length===2\\\"\\n          },\\n          \\\"update\\\": \\\"pinchDistance(event)\\\"\\n        }\\n      ]\\n    },\\n    //recalculate xext based on user mouse behavior\\n    {\\n      \\\"name\\\": \\\"xdom\\\",\\n      \\\"update\\\": \\\"xext\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"delta\\\"\\n          },\\n          \\\"update\\\": \\\"[xcur[0] + span(xcur) * delta[0] / width, xcur[1] + span(xcur) * delta[0] / width]\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"zoom\\\"\\n          },\\n          \\\"update\\\": \\\"[anchor[0] + (xdom[0] - anchor[0]) * zoom, anchor[0] + (xdom[1] - anchor[0]) * zoom]\\\"\\n        },\\n        {\\n          \\\"events\\\": [\\n            {\\n              \\\"source\\\": \\\"view\\\",\\n              \\\"type\\\": \\\"dblclick\\\"\\n            }\\n          ],\\n          \\\"update\\\": \\\"xrange\\\"\\n        }\\n      ]\\n    },\\n    //recalculate yext based on user mouse behavior\\n    {\\n      \\\"name\\\": \\\"ydom\\\",\\n      \\\"update\\\": \\\"yext\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"delta\\\"\\n          },\\n          \\\"update\\\": \\\"[ycur[0] + span(ycur) * delta[1] / height, ycur[1] + span(ycur) * delta[1] / height]\\\"\\n        },\\n        {\\n          \\\"events\\\": {\\n            \\\"signal\\\": \\\"zoom\\\"\\n          },\\n          \\\"update\\\": \\\"[anchor[1] + (ydom[0] - anchor[1]) * zoom, anchor[1] + (ydom[1] - anchor[1]) * zoom]\\\"\\n        },\\n        {\\n          \\\"events\\\": [\\n            {\\n              \\\"source\\\": \\\"view\\\",\\n              \\\"type\\\": \\\"dblclick\\\"\\n            }\\n          ],\\n          \\\"update\\\": \\\"yrange\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"cx\\\",\\n      \\\"update\\\": \\\"width / 2\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"events\\\": \\\"[symbol:mousedown, window:mouseup] > window:mousemove\\\",\\n          \\\"update\\\": \\\"cx==width/2?cx+0.001:width/2\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"cy\\\",\\n      \\\"update\\\": \\\"height / 2\\\"\\n    },\\n    // Takes User Input to define the initial root\\n    {\\n      \\\"name\\\": \\\"userInputRoot\\\",\\n      \\\"init\\\": \\\"''\\\",\\n      \\\"bind\\\": {\\n        \\\"input\\\": \\\"search\\\",\\n        \\\"placeholder\\\": \\\"  x.x.x.x \\\", // place holder to show syntax to user - spaces used to center placeholder in bind box\\n        \\\"name\\\": \\\"Root IP\\\",\\n        \\\"debounce\\\": 1200\\n      }\\n    },\\n    // Finds the index of the root src IP\\n    {\\n      \\\"name\\\": \\\"rootIndex\\\",\\n      \\\"update\\\": \\\"indexof(pluck(data('table'), 'src'), userInputRoot) \\\"\\n    },\\n    // Pulls the src information based on the rootIndex and stores it as intitialRoot\\n    {\\n      \\\"name\\\": \\\"initialRoot\\\",\\n      \\\"update\\\": \\\"pluck(data('table'), 'src')[rootIndex]\\\",\\n    },\\n    // pulls enrichment data for the intialRoot based on rootIndex\\n    {\\n      \\\"name\\\": \\\"initialRootData\\\",\\n      \\\"update\\\": \\\"pluck(data('table'), 'aggregated_objs')[rootIndex]\\\",\\n    },\\n    // checks if the searched IP exists in table or if the search bar is empty to determine whether to show the error\\n    {\\n      \\\"name\\\": \\\"nonexistentIPWarning\\\",\\n      \\\"update\\\": \\\"(rootIndex !== -1) || (userInputRoot === '') ? true : false\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"initialConnection2\\\",\\n      \\\"update\\\": \\\"null + '+' + userInputRoot\\\"\\n    },\\n    {\\n      \\\"name\\\": \\\"treeDepth\\\",\\n      \\\"update\\\": \\\"data('completeTree') && data('completeTree').root ? data('completeTree').root.height : -1\\\"\\n    },\\n    // Allow the depth of the tree to be chosen\\n    {\\n      \\\"name\\\": \\\"n\\\",\\n      \\\"init\\\": 3,\\n      \\\"bind\\\": {\\n        \\\"input\\\": \\\"range\\\",\\n        \\\"min\\\": 1,\\n        \\\"max\\\": 15,\\n        \\\"step\\\": 1,\\n        \\\"name\\\": \\\"Tree Height\\\",\\n        \\\"debounce\\\": 300\\n      }\\n    },\\n    // time filter toggle\\n    {\\n      \\\"name\\\": \\\"timeFilter\\\",\\n      \\\"init\\\": \\\"'Off'\\\",\\n      \\\"bind\\\": {\\n        \\\"input\\\": \\\"radio\\\",\\n        \\\"options\\\": [\\\"On\\\", \\\"Off\\\"],\\n        \\\"name\\\": \\\"Time Filter\\\",\\n        \\\"debounce\\\": 300\\n      }\\n    },\\n    {\\n      \\\"name\\\": \\\"On\\\",\\n      \\\"init\\\": \\\"\\\",\\n      \\\"debounce\\\": 300\\n    },\\n    {\\n      \\\"name\\\": \\\"Off\\\",\\n      \\\"update\\\": \\\"\\\",\\n      \\\"debounce\\\": 300\\n    },\\n    // change scale for nodeColor\\n      {\\n        \\\"name\\\": \\\"nodeColor\\\",\\n        \\\"init\\\": \\\"'set1'\\\",\\n        \\\"bind\\\": {\\n          \\\"input\\\": \\\"select\\\",\\n          \\\"options\\\": [\\\"observable10\\\", \\\"dark2\\\", \\\"paired\\\", \\\"set1\\\"],\\n          \\\"name\\\": \\\"Node Color\\\",\\n          \\\"debounce\\\": 1200\\n        }\\n      },\\n      // Save n history as [previous, current]\\n      {\\n        \\\"name\\\": \\\"nHist\\\",\\n        \\\"value\\\": [\\n          3\\n        ],\\n        \\\"on\\\": [\\n          {\\n            \\\"events\\\": {\\n              \\\"signal\\\": \\\"n\\\"\\n            },\\n            \\\"update\\\": \\\"slice(split(join(nHist)+','+n, ','), -2)\\\"\\n          }\\n        ]\\n      },\\n      // Save previous n\\n      {\\n        \\\"name\\\": \\\"nPrev\\\",\\n        \\\"update\\\": \\\"toNumber(nHist.length > 1 ? nHist[nHist.length-2] : nHist[0])\\\"\\n      },\\n      // When n shrinks we need to clear the graph and rebuild the tree\\n      {\\n        \\\"name\\\": \\\"clear\\\",\\n        \\\"init\\\": \\\"false\\\",\\n        \\\"on\\\": [\\n          {\\n            \\\"events\\\": {\\n              \\\"signal\\\": \\\"n\\\"\\n            },\\n            \\\"update\\\": \\\"n <= nPrev\\\",\\n            \\\"force\\\": true\\n          },\\n          {\\n            \\\"events\\\": {\\n              \\\"signal\\\": \\\"timeFilter\\\"\\n            },\\n            \\\"update\\\": \\\"timeFilter\\\",\\n            \\\"force\\\": true\\n          },\\n          {\\n            \\\"events\\\": {\\n              \\\"signal\\\": \\\"userInputRoot\\\"\\n            },\\n            \\\"update\\\": \\\"nonexistentIPWarning\\\",\\n            \\\"force\\\": true\\n          },\\n        ]\\n      },\\n      // A counter that triggers the BF iteration\\n      {\\n        \\\"name\\\": \\\"step\\\",\\n        \\\"value\\\": 0,\\n        \\\"on\\\": [\\n          {\\n            // check the `update` condition every 50 ms\\n            \\\"events\\\": {\\n              \\\"type\\\": \\\"timer\\\",\\n              \\\"throttle\\\": 50\\n            },\\n            \\\"update\\\": \\\"data('next') && length(data('next')) ? step + 1 : step\\\"\\n          }\\n        ]\\n      },\\n      // Signals for collapsing a clicked node\\n      {\\n        \\\"name\\\": \\\"clicked\\\",\\n        \\\"value\\\": null,\\n        \\\"on\\\": [\\n          {\\n            \\\"events\\\": \\\"@node:click\\\",\\n            \\\"update\\\": \\\"{'identifier': datum.identifier}\\\",\\n            \\\"force\\\": \\\"true\\\"\\n          },\\n          {\\n            \\\"events\\\": \\\"@nodeLabel:click\\\",\\n            \\\"update\\\": \\\"{'identifier': datum.identifier}\\\",\\n            \\\"force\\\": \\\"true\\\"\\n          }\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"clearCollapsed\\\",\\n        \\\"value\\\": false,\\n        \\\"on\\\": [\\n          {\\n            \\\"events\\\": \\\"dblclick[!event.item]\\\",\\n            \\\"update\\\": \\\"true\\\",\\n            \\\"force\\\": true\\n          }\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"count_num_connections\\\",\\n        //\\\"value\\\": 0,\\n        //\\\"init\\\": \\\"data(datum.proto)\\\"\\n      },\\n      //Return the index of the device_array where the ip matches the current node's dst field\\n      {\\n        \\\"name\\\": \\\"nodeEnrich\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"indexof(pluck(datum.device_array, 'ip'), split(datum.identifier,'+')[1])\\\",\\n            \\\"force\\\": \\\"true\\\",\\n          },\\n          {\\n            \\\"events\\\": \\\"@node:mouseout\\\",\\n            \\\"update\\\": \\\"{}\\\",\\n            \\\"debounce\\\": 1000,\\n          },\\n        ]\\n      },\\n      // Get the data at nodeEnrich index from the device_array\\n      {\\n        \\\"name\\\": \\\"device_data\\\",\\n        \\\"value\\\": \\\"{'ip': null}\\\", //declare initial as null to avoid startup error\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"datum.device_array[nodeEnrich]\\\",\\n            \\\"force\\\": \\\"true\\\"\\n          },\\n          {\\n            \\\"events\\\": \\\"@node:mouseout\\\",\\n            \\\"update\\\": \\\"{}\\\",\\n            //\\\"debounce\\\": 1000,\\n          },\\n        ]\\n      },\\n      // Determine if netbox enrichment exists for a node and then pull the role value as a string\\n      {\\n        \\\"name\\\": \\\"netbox_role\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"device_data.device ? toString(pluck(device_data.device, 'role')) : null\\\",\\n            \\\"force\\\": \\\"true\\\"\\n          },\\n        ]\\n      },\\n      // Determine if netbox enrichment exists for a node and then pull the name value as a string\\n      {\\n        \\\"name\\\": \\\"netbox_name\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"device_data.device ? toString(pluck(device_data.device, 'name')) : null\\\",\\n            \\\"force\\\": \\\"true\\\"\\n          },\\n        ]\\n      },\\n      // {\\n      //   \\\"name\\\": \\\"device_host_name\\\",\\n      //   \\\"on\\\":[\\n      //     {\\n      //       \\\"events\\\": \\\"@node:mouseover\\\",\\n      //       \\\"update\\\": \\\"datum.device_array[2].host_name ? pluck(datum.device_array[2], 'host_name') : null\\\",\\n      //       \\\"force\\\": \\\"true\\\"\\n      //     },\\n      //   ]\\n      // },\\n      {\\n        \\\"name\\\": \\\"device_mac\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"device_data ? pluck(device_data, 'mac')[0] : null \\\",\\n            \\\"force\\\": \\\"true\\\"\\n          },\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"device_oui\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"device_data ? pluck(device_data, 'oui') : null\\\",\\n            \\\"force\\\": true,\\n          }\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"device_as\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"device_data ? pluck(device_data, 'as') : null\\\",\\n            \\\"force\\\": true,\\n          }\\n        ]\\n      },\\n      // Format the node hover data so tooltip is populated\\n      {\\n        \\\"name\\\": \\\"device_info\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\": \\\"@node:mouseover\\\",\\n            \\\"update\\\": \\\"{'IP': device_data.ip, 'MAC': device_mac, 'OUI': device_oui, 'As': device_as, 'Netbox Name': netbox_name, 'Netbox Role': netbox_role }\\\",\\n            \\\"force\\\": \\\"true\\\"\\n          },\\n          {\\n            \\\"events\\\": \\\"@node:mouseout\\\",\\n            \\\"update\\\": \\\"{}\\\",\\n            //\\\"debounce\\\": 1000,\\n          },\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"color\\\",\\n        \\\"on\\\":[\\n          {\\n            \\\"events\\\":\\\"@node:mouseover\\\",\\n            \\\"update\\\":\\\"rgb(rgb(scale('color', datum.depth)).r * 0.7, rgb(scale('color', datum.depth)).g * 0.7, rgb(scale('color', datum.depth)).b * 0.7)\\\"\\n          }\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"tooltip2\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\": [\\n          {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"pluck(datum.target.enrichment, 'conn_state')\\\" },\\n          {\\\"events\\\": \\\"path:mouseout\\\", \\\"update\\\": \\\"{}\\\"}\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"tooltip3\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\": [\\n          {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"pluck(datum.target.enrichment, 'protocolArr')\\\" },\\n          {\\\"events\\\": \\\"path:mouseout\\\", \\\"update\\\": \\\"{}\\\"}\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"byte_data\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\": [\\n          {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"pluck(datum.target.enrichment, 'bytesArr')\\\" },\\n          {\\\"events\\\": \\\"path:mouseout\\\", \\\"update\\\": \\\"{}\\\"}\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"enrichmentSrc\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\": [\\n          {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"pluck(datum.target.enrichment, 'src')\\\"},\\n          {\\\"events\\\": \\\"path:mouseout\\\", \\\"update\\\": \\\"{}\\\"}\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"enrichmentDst\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\": [\\n          {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"pluck(datum.target.enrichment, 'dst')\\\"},\\n          {\\\"events\\\": \\\"path:mouseout\\\", \\\"update\\\": \\\"{}\\\"}\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"bytes_extent\\\",\\n        \\\"update\\\": \\\"{'min': pluck(data('bytesExtent'), 'byteMin')[0], 'max': pluck(data('bytesExtent'), 'byteMax')[0]}\\\"\\n      },\\n      {\\n        \\\"name\\\": \\\"time_extent\\\",\\n        \\\"update\\\": \\\"{'min': pluck(data('timeExtent'), 'timeMin'), 'max': pluck(data('timeExtent'), 'timeMax')}\\\"\\n      },\\n      {\\n        \\\"name\\\": \\\"connection_time\\\",\\n        \\\"value\\\": {},\\n        \\\"on\\\": [\\n          {\\\"events\\\": \\\"path:mouseover\\\", \\\"update\\\": \\\"datum.target.date_obj\\\"},\\n          {\\\"events\\\": \\\"path:mouseout\\\", \\\"update\\\": \\\"{}\\\"}\\n        ]\\n      },\\n      {\\n        \\\"name\\\": \\\"legend_height\\\", \\\"value\\\": 28\\n      },\\n    ],\\n    ## --------------------------------------------------------------------------------------------------------------------------\\n    ##  SECTION 2: DATA --------------------------------------------------------------------------------------------------------\\n    ##  Define datasets and data normalization to be worked with in schema\\n    \\\"data\\\": [\\n      {\\n        // 'Raw' data that is being pulled using opensearch dsl and aggregations capability\\n        // https://docs.opensearch.org/latest/query-dsl/\\n        // https://docs.opensearch.org/latest/aggregations/bucket/index/\\n\\n\\n        \\\"name\\\": \\\"table\\\",\\n        \\\"url\\\": {\\n          \\\"index\\\": \\\"MALCOLM_NETWORK_INDEX_PATTERN_REPLACER\\\",\\n          \\\"body\\\": {\\n            \\\"query\\\": {\\n              \\\"bool\\\": {\\n                \\\"must\\\": [\\n                  {\\n                    \\\"match\\\":{\\n                      \\\"event.provider\\\":\\\"zeek\\\",\\n                    },\\n                    \\\"match\\\":{\\n                      \\\"event.dataset\\\":\\\"conn\\\",\\n                    }\\n                  }\\n                  \\\"%dashboard_context-must_clause%\\\"\\n                ],\\n                \\\"must_not\\\": [\\n                  \\\"%dashboard_context-must_not_clause%\\\"\\n                ],\\n                \\\"filter\\\": [\\n                  \\\"%dashboard_context-filter_clause%\\\",\\n                  {\\n                    \\\"range\\\": {\\n                      \\\"MALCOLM_OTHER_INDEX_TIME_FIELD_REPLACER\\\": {\\n                        \\\"%timefilter%\\\": true\\n                      }\\n                    }\\n                  },\\n                  {\\n                    \\\"exists\\\": {\\n                      \\\"field\\\": \\\"event.id\\\"\\n                    }\\n                  },\\n                  {\\n                    \\\"exists\\\": {\\n                      \\\"field\\\": \\\"timestamp\\\"\\n                    }\\n                  },\\n              ]\\n            }\\n          },\\n          // assign all relevant destination ips to each unique source\\n          \\\"aggs\\\": {\\n          ##  Define parameters for\\n            \\\"connections\\\": {\\n              \\\"composite\\\": {\\n                \\\"size\\\": 10000,\\n                \\\"sources\\\": [\\n                  {\\\"src\\\": { \\\"terms\\\": {\\\"field\\\": \\\"source.ip\\\"} } },\\n                  {\\\"dst\\\": {\\\"terms\\\": {\\\"field\\\": \\\"destination.ip\\\"}} },\\n                  // {\\\"protocol\\\": {\\\"terms\\\": {\\\"field\\\": \\\"protocol\\\"}} },\\n                  {\\\"conn_state\\\": {\\\"terms\\\": {\\\"field\\\": \\\"zeek.conn.conn_state\\\"}}}\\n                ]\\n              },\\n                \\\"aggs\\\": {\\n                  \\\"metadata\\\": {\\n                    \\\"top_hits\\\": {\\n                      \\\"size\\\": 1,\\n                      \\\"_source\\\": {\\n                        \\\"includes\\\": [\\n                          \\\"source\\\",\\n                          \\\"destination\\\",\\n                          \\\"protocol\\\",\\n                          \\\"totDataBytes\\\",\\n                          \\\"timestamp\\\",\\n                          // \\\"host\\\"\\n                        ]\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n          \\\"size\\\": 0\\n          // this applies to hits, not aggregations, faster and reduces data size\\n      },\\n      \\\"format\\\": {\\n        \\\"property\\\": \\\"aggregations.connections.buckets\\\"\\n      },\\n      \\\"transform\\\": [\\n        // surfaced aggregated objs, src and dst device, protocols, segment names, conn states in the metadata (prettification)\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.metadata.hits.hits[0]._source.protocol ? datum.metadata.hits.hits[0]._source.protocol : null\\\",\\n          \\\"as\\\": \\\"proto\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.metadata.hits.hits[0]._id ? datum.metadata.hits.hits[0]._id : null\\\",\\n          \\\"as\\\": \\\"log_id\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"project\\\",\\n          \\\"fields\\\": [\\\"key.src\\\", \\\"key.dst\\\", \\\"key.conn_state\\\", \\\"metadata.hits.hits[0]._source.source\\\", \\\"metadata.hits.hits[0]._source.destination\\\", \\\"proto\\\", \\\"metadata.hits.hits[0]._source.totDataBytes\\\", \\\"metadata.hits.hits[0]._source.timestamp\\\"],\\n          \\\"as\\\": [\\\"src\\\", \\\"dst\\\", \\\"conn_state\\\", \\\"source\\\", \\\"destination\\\", \\\"protocol\\\", \\\"total_bytes\\\", \\\"time\\\"]\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"toString(datum.protocol)\\\",\\n          \\\"as\\\": \\\"proto_string\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\\"src\\\", \\\"dst\\\"],\\n          \\\"fields\\\":[\\\"proto\\\", \\\"total_bytes\\\"],\\n          \\\"ops\\\":[\\\"values\\\", \\\"mean\\\"],\\n          \\\"as\\\": [\\\"aggregated_objs\\\", \\\"byteAvg\\\"]\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"length(datum.aggregated_objs)\\\",\\n          \\\"as\\\": \\\"num_connections\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs ? pluck(datum.aggregated_objs, 'conn_state') : null\\\",\\n          \\\"as\\\": \\\"conn_state\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs ? pluck(datum.aggregated_objs, 'proto_string') : null\\\",\\n          \\\"as\\\": \\\"protocolArr\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs ? pluck(datum.aggregated_objs, 'total_bytes') : null\\\",\\n          \\\"as\\\": \\\"bytesArr\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs ? pluck(datum.aggregated_objs, 'time')[0] : null\\\",\\n          \\\"as\\\": \\\"timestamp\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs ? pluck(datum.aggregated_objs, 'destination')[0] : null\\\", //hardcoded to first index of objects because device is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"dst_device\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs ? pluck(datum.aggregated_objs, 'source')[0] : null\\\", //hardcoded to first index of objects because device is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"src_device\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs[0].destination.segment ? pluck(datum.aggregated_objs[0].destination.segment, toString('name')) : null\\\", //hardcoded to first index of objects because segment is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"dst_segment\\\"\\n        },\\n        {\\n          \\\"type\\\":\\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.aggregated_objs[0].source.segment ? pluck(datum.aggregated_objs[0].source.segment, toString('name')) : null\\\", //hardcoded to first index of objects because segment is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"src_segment\\\"\\n        },\\n        // {\\n        //   \\\"type\\\":\\\"formula\\\",\\n        //   \\\"expr\\\": \\\"datum.aggregated_objs[0].host ? pluck(datum.aggregated_objs[0].host, 'name') : null\\\",\\n        //   \\\"as\\\": \\\"host_name\\\"\\n        // },\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"collapsyNodes\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"trigger\\\": \\\"clearCollapsed || initialRoot\\\",\\n          \\\"remove\\\": true\\n        },\\n        {\\n          \\\"trigger\\\": \\\"clicked\\\",\\n          \\\"toggle\\\": \\\"clicked\\\"\\n        }\\n      ]\\n    },\\n    // Acts as the queue for the Breadth first traversal\\n    {\\n      \\\"name\\\": \\\"queue\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"trigger\\\": \\\"clear || initialRoot\\\",\\n          \\\"remove\\\": true\\n        },\\n        {\\n          \\\"trigger\\\": \\\"clear || initialRoot\\\",\\n          \\\"insert\\\": \\\"{'id': initialRoot, 'depth': 0, 'identifier': initialConnection2, 'testCat': null}\\\"\\n        },\\n        {\\n          \\\"trigger\\\": \\\"step\\\",\\n          \\\"remove\\\": true\\n        },\\n        {\\n          \\\"trigger\\\": \\\"step\\\",\\n          \\\"insert\\\": \\\"data('next')\\\"\\n        }\\n      ]\\n    }\\n    // Tracks all visited nodes\\n    {\\n      \\\"name\\\": \\\"visited\\\",\\n      \\\"on\\\": [\\n        {\\n          \\\"trigger\\\": \\\"clear || initialRoot\\\",\\n          \\\"remove\\\": true\\n        },\\n        {\\n          \\\"trigger\\\": \\\"clear || initialRoot\\\",\\n          \\\"insert\\\": \\\"(nonexistentIPWarning !== false) && (userInputRoot !== '') ? {'src': null, 'dst': initialRoot, 'id': initialRoot, 'depth': 0, 'enrichment': initialRootData, 'identifier': initialConnection2, 'parentIdentifier': null, 'testSplit': null, 'testCat': null} : null\\\"    // If IP exists in table then insert the initial node, otherwise do not insert\\n        },\\n        {\\n          \\\"trigger\\\": \\\"step\\\",\\n          \\\"insert\\\": \\\"(nonexistentIPWarning !== false) && (userInputRoot !== '') ? data('next') : null\\\"\\n        },\\n      ],\\n      \\\"transform\\\":[\\n        // RootNode enrichment flattening - does not change enrichment transforms that are handled in table dataset\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) ? length(datum.enrichment) : 0\\\",\\n          \\\"as\\\": \\\"enrich_len\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? pluck(datum.enrichment, 'proto_string') : datum.protocolArr\\\",\\n          \\\"as\\\": \\\"protocolArr\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? pluck(datum.enrichment, 'conn_state') : datum.conn_state\\\",\\n          \\\"as\\\": \\\"conn_state\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? pluck(datum.enrichment, 'destination')[0] : datum.dst_device\\\", // hardcoded to first index of objects because device is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"dst_device\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? pluck(datum.enrichment, 'source')[0] : datum.src_device\\\", // hardcoded to first index of objects because device is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"src_device\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? toString(pluck(datum.enrichment, 'destination.segment')) : datum.dst_segment\\\", // hardcoded to first index of objects because segment is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"dst_segment\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? toString(pluck(datum.enrichment, 'source.segment')) : datum.src_segment\\\", // hardcoded to first index of objects because segment is enriched from netbox not network traffic\\n          \\\"as\\\": \\\"src_segment\\\"\\n        },\\n        // {\\n        //   \\\"type\\\": \\\"formula\\\",\\n        //   \\\"expr\\\": \\\"isValid(datum.enrichment) && datum.enrich_len > 0 ? toString(pluck(datum.enrichment, 'host.name')) : datum.host_name\\\", // hardcoded to first index of objects because device is enriched from netbox not network traffic\\n        //   \\\"as\\\": \\\"host_name\\\"\\n        // },\\n      ]\\n    },\\n    // Tracks what nodes to search next\\n    {\\n      \\\"name\\\": \\\"next\\\",\\n      \\\"source\\\": \\\"table\\\",\\n      \\\"transform\\\": [\\n        // Stop if we reach n\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"treeDepth < n\\\"\\n        },\\n        // unique identifier for strat\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.src + '+' + datum.dst\\\",\\n          \\\"as\\\": \\\"identifier\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\" datum.src === pluck(data('visited'), 'dst')[indexof(pluck(data('visited'), 'dst'), datum.src)] ? pluck(data('visited'), 'identifier')[indexof(pluck(data('visited'), 'dst'), datum.src)] : null\\\",\\n          \\\"as\\\": \\\"parentIdentifier\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.src + '+' + datum.dst\\\",\\n          \\\"as\\\": \\\"testCat\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"split(datum.testCat,'+')[0]\\\",\\n          \\\"as\\\": \\\"testSplit\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"lookup\\\",\\n          \\\"from\\\": \\\"queue\\\",\\n          \\\"key\\\": \\\"identifier\\\",\\n          \\\"fields\\\": [\\n            \\\"parentIdentifier\\\"\\n          ],\\n          \\\"values\\\": [\\n            \\\"depth\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"parentDepth\\\"\\n          ]\\n        },\\n        // Keep valid ids in the queue\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"isValid(datum.parentDepth)\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.dst\\\",\\n          \\\"as\\\": \\\"id\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datum.parentDepth + 1\\\",\\n          \\\"as\\\": \\\"depth\\\"\\n        },\\n        // Grab the parent node timestamp and insert into current node metadata\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"(datum.src === pluck(data('visited'), 'dst')[indexof(pluck(data('visited'), 'dst'), datum.src)]) && (datum.parentIdentifier === pluck(data('visited'), 'identifier')[indexof(pluck(data('visited'), 'identifier'), datum.parentIdentifier)]) ? pluck(data('visited'), 'timestamp')[indexof(pluck(data('visited'), 'dst'), datum.src)] : null\\\",\\n          \\\"as\\\": \\\"parentTime\\\"\\n        },\\n        // time filter - filter out past timestamps (nodes)\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"timeFilter === 'On' && datum.depth > 1 ? datum.timestamp > datum.parentTime : 'Off'\\\",\\n        },\\n      ]\\n    },\\n      // defines IP nodes and organizes data in tree data structure\\n    {\\n      \\\"name\\\": \\\"completeTree\\\",\\n      \\\"source\\\": [\\n        \\\"visited\\\"\\n      ],\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\n            \\\"parentIdentifier\\\",\\n            \\\"identifier\\\",\\n          ],\\n          \\\"fields\\\": [\\\"protocolArr\\\"], // passes down enrichment data\\n          \\\"ops\\\": [\\\"values\\\"],\\n          \\\"as\\\": [\\\"enrichment\\\"]\\n        },\\n        {\\n          \\\"type\\\": \\\"stratify\\\",\\n          \\\"key\\\": \\\"identifier\\\",\\n          \\\"parentKey\\\": \\\"parentIdentifier\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"tree\\\",\\n          \\\"method\\\": \\\"tidy\\\",\\n          \\\"size\\\": [\\n            {\\n              \\\"signal\\\": \\\"height\\\"\\n            },\\n            {\\n              \\\"signal\\\": \\\"width\\\"\\n            }\\n          ],\\n          \\\"separation\\\": true,\\n          \\\"as\\\": [\\n            \\\"y\\\",\\n            \\\"x\\\",\\n            \\\"depth\\\",\\n            \\\"children\\\"\\n          ]\\n        },\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"ancestors\\\",\\n      \\\"source\\\": \\\"completeTree\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"treeAncestors('completeTree', datum.identifier)\\\",\\n          \\\"as\\\": \\\"ancestors\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"flatten\\\",\\n          \\\"fields\\\": [\\n            \\\"ancestors\\\"\\n          ],\\n          \\\"as\\\": [\\n            \\\"ancestor\\\"\\n          ]\\n        },\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"datum.ancestor.identifier !== datum.identifier\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"indata('collapsyNodes', 'identifier', datum.ancestor.identifier)\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"collapsed\\\",\\n      \\\"source\\\": \\\"ancestors\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"groupby\\\": [\\n            \\\"identifier\\\"\\n          ]\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"visibleTree\\\",\\n      \\\"source\\\": \\\"completeTree\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"filter\\\",\\n          \\\"expr\\\": \\\"!indata('collapsed', 'identifier', datum.identifier)\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"stratify\\\",\\n          \\\"key\\\": \\\"identifier\\\",\\n          \\\"parentKey\\\": \\\"parentIdentifier\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"tree\\\",\\n          \\\"method\\\": \\\"tidy\\\",\\n          \\\"size\\\": [\\n            {\\n              \\\"signal\\\": \\\"height - 150\\\"\\n            },\\n            {\\n              \\\"signal\\\": \\\"width - 220\\\"\\n            }\\n          ],\\n          \\\"separation\\\": true,\\n          \\\"as\\\": [\\n            \\\"y\\\",\\n            \\\"x\\\",\\n            \\\"depth\\\",\\n            \\\"children\\\"\\n          ]\\n        },\\n        // Creates device_array to determine which device info to show on node hover\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"[pluck(datum.enrichment[0], 'dst_device'), pluck(datum.enrichment[0], 'src_device'), datum.enrichment[0]]\\\",\\n          \\\"as\\\": \\\"device_array\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"pluck(datum.enrichment, 'byteAvg')[0]\\\",    // must be pluck and NOT datum.byteAvg\\n          \\\"as\\\": \\\"byteAvg\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"pluck(datum.enrichment, 'timestamp')[0]\\\", // grabs timestamp field value from enrichment object\\n          \\\"as\\\": \\\"ts\\\"\\n        },\\n        // converts timestamp into a Date object for humanreadable version of timestamp field\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"datetime(year(datum.ts), month(datum.ts), date(datum.ts), hours(datum.ts), minutes(datum.ts), seconds(datum.ts), milliseconds(datum.ts))\\\",\\n          \\\"as\\\": \\\"date_obj\\\"\\n        },\\n\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"bytesExtent\\\",\\n      \\\"source\\\": \\\"visibleTree\\\",\\n      \\\"transform\\\":[\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"fields\\\": [\\\"byteAvg\\\", \\\"byteAvg\\\"],\\n          \\\"ops\\\":[\\\"min\\\", \\\"max\\\"],\\n          \\\"as\\\": [\\\"byteMin\\\", \\\"byteMax\\\"]\\n        },\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"timeExtent\\\",\\n      \\\"source\\\": \\\"visited\\\",\\n      \\\"transform\\\":[\\n        {\\n          \\\"type\\\": \\\"aggregate\\\",\\n          \\\"fields\\\": [\\\"timestamp\\\", \\\"timestamp\\\"],\\n          \\\"ops\\\":[\\\"min\\\", \\\"max\\\"],\\n          \\\"as\\\": [\\\"timeMin\\\", \\\"timeMax\\\"]\\n        },\\n      ]\\n    },\\n    // Calculate paths between nodes\\n    {\\n      \\\"name\\\": \\\"links\\\",\\n      \\\"source\\\": \\\"visibleTree\\\",\\n      \\\"transform\\\": [\\n        {\\n          \\\"type\\\": \\\"treelinks\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"linkpath\\\",\\n          \\\"orient\\\": \\\"horizontal\\\",\\n          \\\"shape\\\": \\\"diagonal\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"pluck(datum.target.enrichment, 'byteAvg')[0]\\\",\\n          \\\"as\\\": \\\"byteAvg\\\"\\n        },\\n        {\\n          \\\"type\\\": \\\"formula\\\",\\n          \\\"expr\\\": \\\"isValid((datum.byteAvg - bytes_extent.min)/ (bytes_extent.max - bytes_extent.min)) ? (datum.byteAvg - bytes_extent.min)/ (bytes_extent.max - bytes_extent.min) : 1 \\\", //evaluates whether the normal number is valid, defaults to 1\\n          \\\"as\\\": \\\"byteAvg_normal\\\"\\n        },\\n        ]\\n      },\\n    ],\\n    ## --------------------------------------------------------------------------------------------------------------------------\\n    ##  SECTION 3: Scales -------------------------------------------------------------------------------------------------------\\n    ##  Maps data values to either categorical data or numerical data to change the way the data presents visually\\n    \\\"scales\\\": [\\n      // Assign a color for each layer\\n      {\\n        \\\"name\\\": \\\"color\\\",\\n        \\\"type\\\": \\\"linear\\\",\\n        \\\"range\\\": {\\n          \\\"scheme\\\": {\\\"signal\\\": \\\"nodeColor\\\"} // built in color scheme from Vega // observable10  set1 tableu1\\n        },\\n        \\\"domain\\\": [0,15], // hardcoded to fix infinite depth error\\n        \\\"zero\\\": true\\n      },\\n      {\\n        \\\"name\\\": \\\"dash_scale\\\",\\n        \\\"type\\\": \\\"ordinal\\\",\\n        \\\"domain\\\": [\\\"0 bytes transferred\\\", \\\"> 0 bytes transferred\\\"],\\n        \\\"range\\\": [[5,2], null]\\n      },\\n      {\\n      //  Scale to determine x visual bounds after user attempts to zoom or drag mouse\\n      // used to scale the x value for marks\\n        \\\"name\\\": \\\"xscale\\\",\\n        \\\"zero\\\": false,\\n        \\\"domain\\\": {\\n          \\\"signal\\\": \\\"xdom\\\"\\n        },\\n        \\\"range\\\": {\\n          \\\"signal\\\": \\\"xrange\\\"\\n        }\\n      },\\n      {\\n      //  Scale to determine y visual bounds after user attempts to zoom or drag mouse\\n      // used to scale the y value for marks\\n        \\\"name\\\": \\\"yscale\\\",\\n        \\\"zero\\\": false,\\n        \\\"domain\\\": {\\n          \\\"signal\\\": \\\"ydom\\\"\\n        },\\n        \\\"range\\\": {\\n          \\\"signal\\\": \\\"yrange\\\"\\n        }\\n      },\\n    ],\\n\\n    ## --------------------------------------------------------------------------------------------------------------------------\\n    ##  SECTION 5: Marks --------------------------------------------------------------------------------------------------------\\n    ##  Determines how the data visually appears in the visualization\\n    \\\"marks\\\": [\\n      {\\n        // Render the tree inside a group to allow us to manipulate the entire position\\n        //Group mark made to standardize positioning of marks in visualization\\n        \\\"type\\\": \\\"group\\\",\\n        \\\"type\\\": \\\"group\\\",\\n        \\\"name\\\": \\\"treeGroup\\\",\\n        \\\"encode\\\": {\\n          \\\"enter\\\": {\\n            // Offset to make first IP visible\\n            \\\"x\\\": {\\n              \\\"value\\\": 400\\n            },\\n            \\\"height\\\": {\\n              \\\"signal\\\": \\\"height-100\\\"\\n            },\\n            \\\"width\\\": {\\n              \\\"signal\\\": \\\"width\\\"\\n            }\\n          }\\n        },\\n        \\\"title\\\": {\\n          \\\"text\\\": \\\"IP Connections Tree Hierarchy\\\",\\n          \\\"orient\\\": \\\"top\\\",\\n          \\\"align\\\": \\\"center\\\"\\n        },\\n        \\\"marks\\\": [\\n          // Draw the paths\\n          {\\n            \\\"type\\\": \\\"path\\\",\\n            \\\"name\\\": \\\"nodePath\\\",\\n            \\\"zindex\\\": 0,\\n            \\\"from\\\": {\\n              \\\"data\\\": \\\"links\\\",\\n            },\\n            \\\"encode\\\": {\\n              \\\"update\\\": {\\n                \\\"path\\\": {\\n                  \\\"field\\\": \\\"path\\\"\\n                },\\n                \\\"stroke\\\": {\\n                  \\\"value\\\": \\\"#7777\\\"\\n                },\\n                \\\"strokeDash\\\":[\\n                  {\\n                  \\\"test\\\":\\\"datum.byteAvg == 0\\\",\\n                  \\\"value\\\": [10,5]\\n                  },\\n                  {\\n                    \\\"signal\\\": \\\"null\\\"\\n                  }\\n                ],\\n                \\\"strokeWidth\\\": {\\\"signal\\\": \\\"5 + (datum.byteAvg_normal * (20-5))\\\"}\\n              },\\n              \\\"hover\\\": {\\n                \\\"cursor\\\": {\\n                  \\\"value\\\": \\\"pointer\\\"\\n                },\\n                // Changes the link color on hover\\n                \\\"stroke\\\": {\\n                  \\\"value\\\": \\\"#aaa\\\"\\n                },\\n                \\\"tooltip\\\": {\\n                  \\\"signal\\\": \\\"{'Time': toString(datum.target.date_obj),'Src Segment': toString(pluck(datum.target.enrichment, 'src_segment')), 'Dst Segment': toString(pluck(datum.target.enrichment, 'dst_segment')), 'Byte Avg': datum.byteAvg}\\\",\\n                }\\n              }\\n            },\\n            \\\"transform\\\":[\\n              // redefine the source/target x/y positions after mouse moves so the links know where to be drawn\\n              {\\n              \\\"type\\\": \\\"linkpath\\\",\\n              \\\"orient\\\": \\\"horizontal\\\",\\n              \\\"shape\\\": \\\"diagonal\\\",\\n              \\\"sourceX\\\": {\\\"expr\\\": \\\"scale('xscale', datum.datum.source.x)\\\"},\\n              \\\"sourceY\\\": {\\\"expr\\\": \\\"scale('yscale', datum.datum.source.y)\\\"},\\n              \\\"targetX\\\": {\\\"expr\\\": \\\"scale('xscale', datum.datum.target.x)\\\"},\\n              \\\"targetY\\\": {\\\"expr\\\": \\\"scale('yscale', datum.datum.target.y)\\\"}\\n              },\\n            ]\\n          },\\n          {\\n          \\\"type\\\": \\\"text\\\",     // ip title for enrichment box\\n          \\\"from\\\": {\\\"data\\\": \\\"links\\\"},\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                // \\\"align\\\": {\\\"value\\\": \\\"left\\\"},\\n                \\\"baseline\\\": {\\\"value\\\": \\\"top\\\"},\\n                // \\\"fill\\\": {\\\"value\\\": \\\"white\\\"}, //JCR, changes color of IPs addrs in enrichment box that appear on link hover. Removing hardcoded colo lets it change with the Malcolm theme\\n                \\\"opacity\\\": {\\\"value\\\": 0},\\n              },\\n              \\\"update\\\": {\\n                \\\"x\\\": {\\\"value\\\": -395},\\n                \\\"y\\\": {\\\"value\\\": 20},\\n                \\\"text\\\": {\\\"signal\\\": \\\"enrichmentSrc + ' - ' + enrichmentDst\\\"},\\n                \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                \\\"fontStyle\\\": {\\\"value\\\": \\\"bold\\\"},\\n                \\\"fontSize\\\": {\\\"value\\\": 16},\\n                \\\"opacity\\\": {\\\"signal\\\": \\\"isArray(enrichmentSrc) ? 1 : 0\\\" } // checks if enrichmentSrc is an array - if Array then text is an IP value and won't be [object Object] when opacity == 1\\n              },\\n            }\\n          },\\n          {\\n          \\\"type\\\": \\\"text\\\",     // header for conn state, bytes, protocols\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                // \\\"align\\\": {\\\"value\\\": \\\"left\\\"},\\n                \\\"baseline\\\": {\\\"value\\\": \\\"top\\\"},\\n                // \\\"fill\\\": {\\\"value\\\": \\\"white\\\"}, //JCR, changes color of onn state, bytes, protocols label in enrichment box that appear on link hover. Removing hardcoded colo lets it change with the Malcolm theme\\n                \\\"opacity\\\": {\\\"value\\\": 0},\\n              },\\n              \\\"update\\\": {\\n                \\\"x\\\": {\\\"value\\\": -395},\\n                \\\"y\\\": {\\\"value\\\": 40},\\n                \\\"text\\\": {\\\"value\\\": \\\"Conn State   Bytes             Protocol\\\"},\\n                \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                \\\"fontStyle\\\": {\\\"value\\\": \\\"bold\\\"},\\n                \\\"fontSize\\\": {\\\"value\\\": 15},\\n                \\\"opacity\\\": {\\\"signal\\\": \\\"isArray(tooltip3) ? 1 : 0\\\" } // checks if enrichmentSrc is an array - if Array then text is an IP value and won't be [object Object] when opacity == 1\\n              },\\n            }\\n          },\\n          {\\n          \\\"type\\\": \\\"text\\\",     // conn state text in enrichment box\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                // \\\"align\\\": {\\\"value\\\": \\\"left\\\"},\\n                \\\"baseline\\\": {\\\"value\\\": \\\"top\\\"},\\n                \\\"fill\\\": {\\\"value\\\": \\\"#159d8d\\\"} // JCR, changd to match Malcolm color scheme\\n              },\\n              \\\"update\\\": {\\n                \\\"x\\\": {\\\"value\\\": -395},\\n                \\\"y\\\": {\\\"value\\\": 60},\\n                \\\"text\\\": {\\\"signal\\\": \\\"isArray(tooltip2) ? tooltip2 : 'Hover over node for node enrichment.' \\\"}, // checks if node enrichments is populated, if not display user instructions\\n                \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                \\\"fontSize\\\": {\\\"value\\\": 15},\\n                \\\"opacity\\\": 1,\\n              }\\n            }\\n          },\\n          {\\n            \\\"type\\\": \\\"text\\\",     // total byte data text in enrichment box\\n              \\\"encode\\\": {\\n                \\\"enter\\\": {\\n                  \\\"baseline\\\": {\\\"value\\\": \\\"top\\\"},\\n                  \\\"fill\\\": {\\\"value\\\": \\\"#159d8d\\\"} // JCR, changd to match Malcolm color scheme\\n                },\\n                \\\"update\\\": {\\n                  \\\"x\\\": {\\\"value\\\": -303},\\n                  \\\"y\\\": {\\\"value\\\": 60},\\n                  \\\"text\\\": {\\\"signal\\\": \\\"byte_data\\\"},\\n                  \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                  \\\"fontSize\\\": {\\\"value\\\": 15},\\n                  \\\"opacity\\\": {\\\"signal\\\": \\\"isArray(byte_data) ? 1 : 0\\\" } // checks if byte_data is an array - if Array then text is an byte value and won't be [object Object] when opacity == 1\\n                }\\n              }\\n          },\\n          {\\n          \\\"type\\\": \\\"text\\\",     // protocol text in enrichment box\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                \\\"baseline\\\": {\\\"value\\\": \\\"top\\\"},\\n                \\\"fill\\\": {\\\"value\\\": \\\"#159d8d\\\"}, // JCR, changed to match Malcolm color scheme\\n              },\\n              \\\"update\\\": {\\n                \\\"x\\\": {\\\"signal\\\": \\\"isArray(tooltip3) ? -208 : -395\\\"},\\n                \\\"y\\\": {\\\"signal\\\": \\\"isArray(tooltip3) ? 60 : 75\\\"},\\n                \\\"text\\\": {\\\"signal\\\": \\\"isArray(tooltip3) ? tooltip3 : 'Hover over link for link enrichment.' \\\"}, // checks if link enrichments is populated, if not display user instructions\\n                \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                \\\"fontSize\\\": {\\\"value\\\": 15},\\n                \\\"opacity\\\": 1,\\n              }\\n            }\\n          },\\n          {\\n            \\\"type\\\": \\\"text\\\",     // nonexistent IP warning text\\n            \\\"zindex\\\": 0,\\n            \\\"encode\\\": {\\n                \\\"enter\\\": {\\n                  \\\"baseline\\\": {\\\"value\\\": \\\"center\\\"},\\n                  \\\"orient\\\": \\\"bottom\\\"\\n                  // \\\"fill\\\": {\\\"value\\\": \\\"#172430\\\"}, // JCR, if color isn't hardcoded them the color changes based on Malcolm theme\\n                },\\n                \\\"update\\\": {\\n                  \\\"x\\\": {\\\"value\\\": -400},\\n                  \\\"y\\\": {\\\"signal\\\": \\\"height-200\\\"},\\n                  \\\"text\\\": {\\\"value\\\": \\\"IP address not found. Try adjusting the time range.\\\"},\\n                  \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                  \\\"fontStyle\\\": {\\\"value\\\": \\\"bold\\\"},\\n                  \\\"fontSize\\\": {\\\"signal\\\": \\\"titleFontSize\\\"},\\n                  \\\"opacity\\\": {\\\"signal\\\": \\\"nonexistentIPWarning === true ? 0 : 1\\\" } // if IP exists in table then do not show error, otherwise show the error\\n                }\\n              }\\n          },\\n          // Draw the nodes\\n          {\\n            \\\"type\\\": \\\"symbol\\\",\\n            \\\"name\\\": \\\"node\\\",\\n            \\\"zindex\\\": 10,\\n            \\\"from\\\": {\\n              \\\"data\\\": \\\"visibleTree\\\"\\n            },\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                \\\"size\\\": {\\n                  \\\"value\\\": 300\\n                },\\n                \\\"stroke\\\": {\\n                  \\\"value\\\": \\\"black\\\"\\n                },\\n              },\\n              \\\"hover\\\": {\\n                \\\"cursor\\\": {\\n                  \\\"value\\\": \\\"pointer\\\"\\n                },\\n              },\\n              \\\"update\\\": {\\n                // Make collapsed nodes larger\\n                \\\"size\\\": [\\n                  {\\n                    \\\"test\\\": \\\"indata('collapsyNodes', 'identifier', datum.identifier)\\\",\\n                    \\\"signal\\\": \\\"300 * 1.5\\\"\\n                  },\\n                  {\\n                    \\\"signal\\\": \\\"300\\\"\\n                  }\\n                ],\\n                // Stroke collapsed nodes\\n                \\\"strokeDash\\\": [\\n                  {\\n                    \\\"test\\\": \\\"indata('collapsyNodes', 'identifier', datum.identifier)\\\",\\n                    \\\"signal\\\": \\\"[5,3]\\\"\\n                  },\\n                  {\\n                    \\\"signal\\\": \\\"null\\\"\\n                  }\\n                ],\\n                \\\"strokeWidth\\\": [\\n                  {\\n                    \\\"test\\\": \\\"indata('collapsyNodes', 'identifier', datum.identifier)\\\",\\n                    \\\"signal\\\": \\\"4\\\"\\n                  },\\n                  {\\n                    \\\"signal\\\": \\\"0\\\"\\n                  }\\n                ],\\n                \\\"x\\\": {\\\"signal\\\": \\\"scale('xscale', datum.x)\\\" }, // x value is scaled to account for mouse behavior\\n                \\\"y\\\": {\\\"signal\\\": \\\"scale('yscale', datum.y)\\\"}, // y value is scaled to account for mouse behavior\\n                // Make collapsed nodes darker\\n                \\\"fill\\\": [\\n                  {\\n                    \\\"test\\\": \\\"indata('collapsyNodes', 'identifier', datum.identifier)\\\", // || device_data.ip == datum.dst\\\",\\n                    \\\"signal\\\": \\\"rgb(rgb(scale('color', datum.depth)).r * 0.7, rgb(scale('color', datum.depth)).g * 0.7, rgb(scale('color', datum.depth)).b * 0.7)\\\"\\n                  },\\n                  {\\n                    \\\"scale\\\": \\\"color\\\",\\n                    \\\"field\\\": \\\"depth\\\"\\n                  }\\n                ],\\n                // tooltip must be declared in update instead of hover to prevent ip collisions\\n                \\\"tooltip\\\": {\\n                  \\\"signal\\\": \\\"device_info\\\",\\n                },\\n              },\\n\\n            }\\n          },\\n          {\\n            // IP address labels for the nodes\\n            \\\"type\\\": \\\"text\\\",\\n            \\\"name\\\": \\\"nodeLabel\\\",\\n            \\\"zindex\\\": 10,\\n            \\\"from\\\": {\\n              \\\"data\\\": \\\"visibleTree\\\"\\n            },\\n            \\\"encode\\\": {\\n              \\\"enter\\\": {\\n                \\\"text\\\": {\\n                  \\\"signal\\\": \\\"split(datum.identifier,'+')[1]\\\"\\n                },\\n                \\\"fontSize\\\": {\\\"value\\\": 15},\\n                \\\"font\\\": {\\\"value\\\": \\\"Arial\\\"},\\n                \\\"baseline\\\": {\\n                  \\\"value\\\": \\\"middle\\\"\\n                }\\n              },\\n              \\\"update\\\": {\\n                \\\"x\\\": {\\\"signal\\\": \\\"scale('xscale', datum.x)\\\" }, // x value is scaled to account for mouse behavior\\n                \\\"y\\\": {\\\"signal\\\": \\\"scale('yscale', datum.y)\\\"}, // y value is scaled to account for mouse behavior\\n                // Collapsed or parents have labels on left\\n                \\\"dx\\\": [\\n                  {\\n                    \\\"test\\\": \\\"indata('collapsyNodes', 'identifier', datum.identifier) || datum.children\\\",\\n                    \\\"signal\\\": \\\"-1 * labelOffset\\\"\\n                  },\\n                  {\\n                    \\\"signal\\\": \\\"labelOffset\\\"\\n                  }\\n                ],\\n                \\\"align\\\": [\\n                  {\\n                    \\\"test\\\": \\\"indata('collapsyNodes', 'identifier', datum.identifier) || datum.children\\\",\\n                    \\\"signal\\\": \\\"'right'\\\"\\n                  },\\n                  {\\n                    \\\"signal\\\": \\\"'left'\\\"\\n                  }\\n                ],\\n                \\\"opacity\\\": 1\\n              },\\n              \\\"hover\\\": {\\n                \\\"cursor\\\": {\\n                  \\\"value\\\": \\\"pointer\\\"\\n                }\\n              }\\n            }\\n          }\\n      ]\\n      }\\n    ],\\n    \\\"legends\\\": [\\n      {\\n        \\\"title\\\": \\\"Average Bytes\\\",\\n        \\\"orient\\\": \\\"none\\\",\\n        \\\"titleColor\\\": { \\\"value\\\": \\\"#159d8d\\\" },\\n        \\\"labelColor\\\": { \\\"value\\\": \\\"#159d8d\\\" },\\n        // \\\"fillColor\\\": { \\\"value\\\": \\\"#172430\\\" }, // JCR, left empty for auto theme color\\n        \\\"padding\\\": { \\\"value\\\": 5 },\\n        \\\"strokeDash\\\": \\\"dash_scale\\\",\\n        \\\"symbolType\\\": \\\"stroke\\\",\\n        \\\"symbolStrokeWidth\\\": 3,\\n        \\\"symbolSize\\\": 400,\\n        \\\"legendX\\\": 0,\\n        \\\"legendY\\\": { \\\"signal\\\": \\\"legend_height + 150\\\" },\\n\\n        \\\"encode\\\": {\\n          \\\"symbols\\\": {\\n            \\\"update\\\": {\\n              // \\\"stroke\\\": { \\\"value\\\": \\\"#dfe5ef\\\" },\\n              \\\"fillOpacity\\\": { \\\"value\\\": 0 }\\n            }\\n          },\\n          \\\"title\\\": {\\n            \\\"update\\\": {\\n              \\\"fontSize\\\": { \\\"value\\\": 14 }\\n            }\\n          },\\n          \\\"labels\\\": { \\\"update\\\": { \\\"fontSize\\\": { \\\"value\\\": 14 } } }\\n        }\\n      }\\n    ]\\n  }\\n\"}}"
      },
      "id": "ab8b2ef0-a2d3-11f0-b5ae-e139a66d2205",
      "migrationVersion": {
        "visualization": "7.10.0"
      },
      "namespaces": [
        "default"
      ],
      "references": [],
      "type": "visualization",
      "updated_at": "2025-12-02T17:00:23.020Z",
      "version": "WzEyODIsMV0="
    }
  ],
  "version": "3.3.0"
}
