{
    /**  /**
    Version 1.0
        Authors:
        Nicholas Donovan
        
        Sara Hudson
        Thanks to:
        Sebastian Vera
        Mackenzie Zappe
        Melanie Pierce
        Jessica Rooney
        References:
        https://vega.github.io/vega/docs/
        https://vega.github.io/vega/examples/overview-plus-detail/
        https://vega.github.io/vega/examples/interactive-legend/
        https://vega.github.io/vega/examples/table-scrollbar/
        Commit:
          Corresponds to 8ca1225 in SMILE-Analytics/squiggles/release

        To Do
        Allow drag from main graph
        Allow IP Selection text filter box thing (on hold until I can set a signal bind position)
    **/


    /** modbusData transforms for summarized, I don't want to maintain two copies yet
        {
        "type": "window",
        "groupby": ["addr"],
        "ops": ["lag", "lead"],
        "fields": ["value", "value"],
        "as": ["prevValue", "nextValue"],
        "sort": {"field": "timestamp"}
        },
        {
        "type": "filter",
        "expr": "(datum.prevValue === null || datum.nextValue === null) || (datum.value !== datum.prevValue || datum.value !== datum.nextValue) && datum.prevValue !== null"
        }
    **/

    "$schema": "https://vega.github.io/schema/vega/v5.json",
    ##  --------------------------------------------------------------------------------------------------------------------------
    ##  SECTION 0: Config --------------------------------------------------------------------------------------------------------
    ##  Define Specification constants like multiple instruction positioning
    ##  - arguments set in Config WILL be overwritten if redefined later in specification
    "config": {
        "signals": [
        {
            "name": "fontScale",
            "update": "clamp(min(width / 1920, height / 1080), 0.7, 1.2)"
        },
        {
            "name": "paddingScale",
            "update": "clamp(min(width / 1920, height / 1080), 0.5, 2)"
        },
        {
            "name": "labelFontSize",
            "init": "16 * fontScale"
        },
        {
            "name": "titleFontSize",
            "init": "18 * fontScale"
        },
        {
            "name": "upperHeight",
            "update": "height * 0.6"
        },
        {
            "name": "lowerHeight",
            "update": "height * 0.1"
        },
        {
            "name": "graphWidth",
            "update": "width * 0.80"
        },
        {
            "name": "overviewGraphY",
            "update": "upperHeight + (200 * paddingScale)"
        },
        {
            "name": "ipSelectX",
            "init": "graphWidth + (40 * paddingScale)"
        },
        {
            "name": "unitSelectY",
            "update": "ipsScrollAreaHeight + 30"
        },
        {
            "name": "interpolate",
            "value": "linear"
        }
        ],
        "axis": {
        "titleFontSize": {
            "signal": "titleFontSize"
        },
        "titlePadding": {
            "signal": "25 * paddingScale"
        },
        "labelFontSize": {
            "signal": "labelFontSize"
        },
        "labelFontWeight": "bold",
        "tickWidth": 3
        },
        "title": {
        "fontSize": {
            "signal": "titleFontSize"
        }
        },
        "legend": {
        "orient": "top-left",
        "titleFontSize": {
            "signal": "titleFontSize * 0.9"
        },
        "labelFontSize": {
            "signal": "labelFontSize"
        },
        "symbolSize": 128,
        "symbolStrokeWidth": 2,
        "padding": {
            "signal": "10 * paddingScale"
        }
        },
        "text": {
        "fontSize": {
            "signal": "labelFontSize * 0.9"
        },
        "baseline": "middle"
        },
        "rule": {
        "strokeWidth": 0.2,
        "stroke": "firebrick"
        },
        "rect": {
        "fill": "darkgrey"
        }
    },
    ##  ---------------------------------------------------------------------------------------------------------------------------
    ##  SECTION 1: Signals --------------------------------------------------------------------------------------------------------
    ##  - Define dynamic variables (Signals) that can be updated at any point during the specification
    "signals": [
        /** For main and overview graphs **/
        {
        "name": "xDetailZoom"
        },
        // updated in overview marks group
        {
        "name": "yDetailZoom"
        },
        // updated in overview marks group

        // Holds the identification for a hovered dot tooltip
        {
        "name": "hoveredTimestamp",
        "value": [
            null,
            null
        ],
        "on": [
            {
            "events": "@infoDot:mouseover",
            "update": "[datum.addr, datum.timestamp]"
            },
            {
            "events": "@infoDot:mouseout",
            "update": "[null, null]"
            }
        ]
        },
        /** Legend **/
        // Clear the legend when clicking but not interacting with another event
        {
        "name": "clear",
        "value": true,
        "on": [
            {
            "events": "pointerup[!event.item]",
            "update": "true",
            "force": true
            }
        ]
        },
        // Allow multi-select while holding shift
        {
        "name": "shift",
        "value": false,
        "on": [
            {
            "events": "@legendSymbol:pointerdown, @legendSymbol:pointerup || @legendLabel:pointerdown, @legendLabel:pointerup",
            "update": "event.shiftKey",
            "force": true
            }
        ]
        },
        // Add clicked items to selected data set
        {
        "name": "clicked",
        "value": null,
        "on": [
            {
            "events": "@legendSymbol:pointerdown, @legendSymbol:pointerup || @legendLabel:pointerdown, @legendLabel:pointerup",
            "update": "{value: datum.value}",
            "force": true
            },
            {
            "events": "@detailLine:pointerdown, @detailLine.pointerup",
            "update": "{value: datum.addr}",
            "force": true
            }
        ]
        },
        /** Selection Tables **/
        {
        "name": "ips",
        "update": "length(data('destIps')) ? pluck(data('destIps'), 'destIp') : warn('No IP addresses found.')"
        },
        {
        "name": "units",
        "update": "length(data('destIps')) ? pluck(data('units'), 'unitId') : []"
        },
        {
        "name": "rowHeight",
        "value": 30
        },
        {
        "name": "minIps",
        "value": 10
        },
        {
        "name": "minUnits",
        "value": 5
        },
        /** IP Selection **/
        {
        "name": "ipsToDisplay",
        "update": "min(minIps, length(data('destIps')))"
        },
        {
        "name": "ipsScrollAreaHeight",
        "update": "rowHeight * ipsToDisplay"
        },
        {
        "name": "ipsScrollPositionMax",
        "update": "length(data('destIps')) - ipsToDisplay + 1"
        },
        {
        "name": "ipsScrollBarHeight",
        "init": "clamp((rowHeight * ipsToDisplay) * ipsToDisplay / length(data('destIps')), 30, 600)"
        },
        // IP that was selected in the table
        {
        "name": "selectedIp",
        "init": "ips[0]",
        "on": [
            {
            "events": "@destIps-rect-cell:pointerdown, @destIps-rect-cell:pointerup || @destIps-text-content:pointerdown, @destIps-text-content:pointerup",
            "update": "datum.destIp"
            }
        ]
        },
        {
        "name": "ipsScrollbarMouseDragY",
        "init": "0",
        "on": [
            {
            "events": "[@rect-scrollbar:pointerdown, window:pointerup] > window:pointermove",
            "update": "clamp(y(), 1, ipsScrollAreaHeight)"
            }
        ]
        },
        {
        "name": "ipsScrollPosition",
        "value": 1,
        "on": [
            {
            "events": [
                {
                "markname": "destIps-rect-cell",
                "type": "wheel",
                "consume": true
                },
                {
                "markname": "destIps-text-content",
                "type": "wheel",
                "consume": true
                }
            ],
            "update": "clamp(round(ipsScrollPosition + event.deltaY / abs(event.deltaY) * pow(1.0001, event.deltaY * pow(16, event.deltaMode)), 0), 1, ipsScrollPositionMax)"
            },
            {
            "events": "[@rect-scrollbar:pointerdown, window:pointerup] > window:pointermove",
            "update": "clamp(round(invert('ipsScaleScrollBarY', ipsScrollbarMouseDragY), 0), 1, ipsScrollPositionMax)"
            }
        ]
        },
        /** Unit Selection **/
        {
        "name": "unitsToDisplay",
        "update": "min(minUnits, length(data('units')))"
        },
        {
        "name": "unitsScrollAreaHeight",
        "update": "rowHeight * unitsToDisplay"
        },
        {
        "name": "unitsScrollPositionMax",
        "update": "length(data('units')) - unitsToDisplay + 1"
        },
        {
        "name": "unitsScrollBarHeight",
        "init": "clamp((rowHeight * unitsToDisplay) * unitsToDisplay / length(data('units')), 30, 600)"
        },
        // Unit that was selected in the table
        {
        "name": "selectedUnit",
        "init": "units ? units[0] : ''",
        "on": [
            {
            "events": {
                "signal": "units"
            },
            "update": "units[0]"
            },
            {
            "events": "@units-rect-cell:pointerdown, @units-rect-cell:pointerup || @units-text-content:pointerdown, @units-text-content:pointerup",
            "update": "datum.unitId"
            }
        ]
        },
        {
        "name": "unitsScrollbarMouseDragY",
        "init": "0",
        "on": [
            {
            "events": "[@rect-scrollbar:pointerdown, window:pointerup] > window:pointermove",
            "update": "clamp(y(), 1, unitsScrollAreaHeight)"
            }
        ]
        },
        {
        "name": "unitsScrollPosition",
        "value": 1,
        "on": [
            {
            "events": [
                {
                "type": "wheel",
                "consume": true,
                "markname": "units-rect-cell"
                },
                {
                "type": "wheel",
                "consume": true,
                "markname": "units-text-content"
                }
            ],
            "update": "clamp(round(unitsScrollPosition + event.deltaY / abs(event.deltaY) * pow(1.0001, event.deltaY * pow(16, event.deltaMode)), 0), 1, unitsScrollPositionMax)"
            },
            {
            "events": "[@rect-scrollbar:pointerdown, window:pointerup] > window:pointermove",
            "update": "clamp(round(invert('unitsScaleScrollBarY', unitsScrollbarMouseDragY), 0), 1, unitsScrollPositionMax)"
            }
        ]
        },
        {
        "name": "potentialDate",
        "value": null,
        "update": "timeParse(pluck(data('ipData'), 'value')[0], '%-m/%-d/%Y')"
        // pluck(data('destIps'), 'destIp')
        },
        {
        "name": "isDate",
        "value": false,
        "update": "potentialDate == null ? false : true"
        },
        {
        "name": "markDataset",
        "update": "data('markDataset') ? pluck(data('markDataset'), 'dataset') : ['']"
        },
        {
        "name": "markNames",
        "value": {
            "modbus_detailed": "Modbus Writes",
            "bacnet_property": "BACnet - Analog/Binary IO"
        }
        },
        {
        "name": "markDatasetName",
        "update": "length(markDataset) > 1 ? markDataset : markNames[markDataset[0]] ? markNames[markDataset[0]] : markDataset"
        }
    ],
    ## --------------------------------------------------------------------------------------------------------------------------
    ##  SECTION 2: DATA --------------------------------------------------------------------------------------------------------
    ##  Define datasets and data normalization to be worked with in schema
    "data": [
        {
        // query OpenSearch based on time range
        "name": "modbusRaw",
        "url": {
            "index": "arkime_sessions3-*",
            "body": {
            "query": {
                "bool": {
                    "must": [
                        "%dashboard_context-must_clause%",
                        {
                            "match": {
                                "event.provider": "zeek"
                            }
                        },
                            {
                            "match": {
                                "event.dataset": "modbus_detailed"
                            }
                        },
            
                    ], 
                    "must_not": [
                        "%dashboard_context-must_not_clause%",
                        {
                            "match": {
                            "zeek.modbus.func": "*EXCEPTION"
                            }
                        }
                    ],
                    "filter": [
                        "%dashboard_context-filter_clause%",
                        {
                            "range": {
                            "@timestamp": {
                                "%timefilter%": true
                            }
                            }
                        },
                        {
                            "exists": {
                            "field": "event.id"
                            }
                        },
                        {
                            "exists": {
                            "field": "timestamp"
                            }
                        },
                            // Use the set time filter in opensearch
                            {
                            "wildcard": {
                                "zeek.modbus.func": {
                                "value": "*WRITE*"
                                }
                            }
                            },
                            {
                            "term": {
                                "zeek.modbus_detailed.matched": "T"
                            }
                            },
                            {
                            "exists": {
                                "field": "zeek.modbus_detailed.request_values"
                            }
                            }
                            // Ensure the values exist - only written for WRITE_SINGLE_* (COIL OR REGISTER) ATM [MZ]
                        ],
                }
            },
            "size": 10000,
            "sort": [
                {
                "timestamp": {
                    "order": "asc"
                }
                }
            ],
            // These are the fields we retrieve
            "_source": [
                "event.dataset",
                "event.id",
                "timestamp",
                "destination.ip",
                "destination.port",
                "zeek.modbus_detailed.request_values",
                "zeek.modbus_detailed.address",
                "zeek.modbus.func",
                "zeek.modbus.unit_id",
                "zeek.modbus_detailed.quantity"
            ]
            }
        },
        "format": {
            "property": "hits.hits"
        },
        // Save the needed fieldnames as something more usable and remove the rest of the data
        "transform": [
            {
            "type": "project",
            "fields": [
                "_source.event.dataset",
                "_source.event.id",
                "_source.timestamp",
                "_source.destination.ip",
                "_source.destination.port",
                "_source.zeek.modbus_detailed.request_values",
                "_source.zeek.modbus_detailed.address",
                "_source.zeek.modbus.func",
                "_source.zeek.modbus.unit_id",
                "_source.zeek.modbus_detailed.quantity"
                
                // Some plcs can be daisy chained under an ip addr, multiple unit under the ip zeek.modbus.unit_id
            ],
            "as": [
                "dataset",
                "id",
                "timestamp",
                "destIp",
                "destPort",
                "values",
                "addr",
                "func",
                "unitId",
                "quantity"
                
            ]
            }
        ]
        },
        {
        "name": "modbusData",
        "source": "modbusRaw",
        "transform": [
            {
            "type": "filter",
            "expr": "datum.dataset === 'modbus_detailed'"
            },
            {
            "type": "filter",
            "expr": "datum.destIp === selectedIp && datum.unitId === selectedUnit"
            },
            // Takes values in the values array and flattens them to one value per data point.
            {
            "type": "flatten",
            "fields": [
                "values"
            ],
            "as": [
                "value"
            ],
            "index": "column"
            },
            {
            "type": "formula",
            "as": "dataType",
            "expr": "(indexof(datum.func, 'REG') !== -1) ? 'reg' : 'coil'"
            // Register or coil
            },
            {
            "type": "formula",
            "as": "dataType",
            "expr": "(datum.dataType === 'reg') && (indexof(datum.func, 'MULTIPLE') !== -1) ? 'mult_reg' : datum.dataType"
            // Multple or single register
            },
            {
            "type": "formula",
            "as": "dataType",
            "expr": "(datum.dataType === 'coil') && (indexof(datum.func, 'MULTIPLE') !== -1) ? 'mult_coil' : datum.dataType"
            // Multple or single coil
            },
            // ## TODO: Add support for WRITE_MULTIPLE* functions [MZ]
            // // Comment out index/col solution because data is only for single functions at this time [MZ]
            {
            "type": "formula",
            "as": "indexType",
            "expr": "(indexof(datum.func, 'REG') !== -1) ? datum.addr : datum.column"
            // Register or coil
            },
            //  Cast indexType as addr for all points
            {
            "type": "formula",
            "as": "addr",
            "expr": "datum.quantity == 1 ? datum.addr : datum.indexType"
            },
            // {
            // "type": "formula",
            // "as": "addr",
            // "expr": "toNumber(datum.addr)"
            // },
            // {
            // "type": "formula",
            // "as": "value",
            // "expr": "!isNumber(datum.value) ? (datum.value === 'T' ? 1 : datum.value === 'F' ? 0 : +datum.value) : datum.value"
            // },
            // Save only required fields and trash the rest
            // {
            // "type": "project",
            // "fields": [
            //     "dataset",
            //     "addr",
            //     "value",
            //     "timestamp",
            //     "destIp",
            //     "destPort",
            //     "unitId",
            //     "func",
            //     "id"
            // ]
            // }
        ]
        },

        // Group unique IPs
        {
        "name": "destIps",
        "source": [
            "modbusRaw",
        ],
        "transform": [
            {
            "type": "aggregate",
            "groupby": [
                "destIp"
            ]
            },
            {
            "type": "collect",
            "sort": {
                "field": "destIp"
            }
            }
        ]
        },
        // Group unique units for the selected IP
        {
        "name": "units",
        "source": "modbusRaw",
        "transform": [
            {
            "type": "filter",
            "expr": "datum.destIp === selectedIp"
            },
            {
            "type": "aggregate",
            "groupby": [
                "unitId"
            ]
            },
            {
            "type": "collect",
            "sort": {
                "field": "unitId"
            }
            }
        ]
        },
        // // Hack for the table, filters only the position in the table
        {
        "name": "unitSlice",
        "source": "units",
        "transform": [
            {
            "type": "filter",
            "expr": "(indexof(units, datum.unitId) + 1 >= unitsScrollPosition) && (indexof(units, datum.unitId) + 1 < (unitsScrollPosition + unitsToDisplay))"
            }
        ]
        },
        {
        "name": "ipSlice",
        "source": "destIps",
        "transform": [
            {
            "type": "filter",
            "expr": "(indexof(ips, datum.destIp) + 1 >= ipsScrollPosition) && (indexof(ips, datum.destIp) + 1 < (ipsScrollPosition + ipsToDisplay))"
            }
        ]
        },
        // Holds selected legend items
        {
        "name": "selected",
        "on": [
            {
            "trigger": "clear",
            "remove": true
            },
            {
            "trigger": "!shift",
            "remove": true
            },
            {
            "trigger": "!shift && clicked",
            "insert": "clicked"
            },
            {
            "trigger": "shift && clicked",
            "toggle": "clicked"
            }
        ]
        },
        {
        "name": "markData",
        "source": [
            "modbusData"
        ],
        "transform": [
            {
            "type": "formula",
            "expr": "datum.func",
            "as": "func"
            },
            {
            "type": "formula",
            "expr": " datum.addr",
            "as": "addr"
            },
            {
            "type": "formula",
            "expr": "datum.unitId",
            "as": "unitId"
            },
            {
            "type": "formula",
            "expr": " {}",
            "as": "hoverData"
            },
            {
            "type": "project",
            "fields": [
                "dataset",
                "id",
                "timestamp",
                "destIp",
                "destPort",
                "func",
                "addr",
                "value",
                "unitId",
                "hoverData",
                "dataType"
            ]
            }
        ]
        },
        {
        "name": "markDataset",
        "source": "markData",
        "transform": [
            {
            "type": "aggregate",
            "groupby": ["dataset"]
            }
        ]
        }
    ],
    ## --------------------------------------------------------------------------------------------------------------------------
    ##  SECTION 3: Scales -------------------------------------------------------------------------------------------------------
    ##  Maps data values to either categorical data or numerical data to change the way the data presents visually
    "scales": [
        {
        "name": "color",
        "type": "ordinal",
        "domain": {
            "data": "modbusData",
            "field": "addr",
            "sort": true
        },
        "range": {
            "scheme": "category20"
        }
        },
        {
        "name": "nodeShape",
        "type": "ordinal",
        "domain": ["reg", "coil", "mult_reg", "mult_coil"],
        "range": ["square", "circle", "diamond", "triangle"]
        },
        {
        "name": "ipsScaleScrollBarY",
        "type": "linear",
        "domain": [
            1,
            {
            "signal": "ipsScrollPositionMax"
            }
        ],
        "range": [
            0,
            {
            "signal": "rowHeight * ipsToDisplay - ipsScrollBarHeight - 1"
            }
        ]
        },
        {
        "name": "unitsScaleScrollBarY",
        "type": "linear",
        "domain": [
            1,
            {
            "signal": "unitsScrollPositionMax"
            }
        ],
        "range": [
            0,
            {
            "signal": "rowHeight * unitsToDisplay - unitsScrollBarHeight - 1"
            }
        ]
        }
    ],
    ## --------------------------------------------------------------------------------------------------------------------------
    ##  SECTION 5: Marks --------------------------------------------------------------------------------------------------------
    ##  Determines how the data visually appears in the visualization
    /****** START MAIN GRAPH MARKS ******/
    "marks": [
        {
        "type": "group",
        "name": "detail",
        "encode": {
            "enter": {
            "height": {
                "signal": "upperHeight"
            },
            "width": {
                "signal": "graphWidth"
            }
            }
        },
        "title": {
            "text": {
            "signal": "'Detailed Graph: '+ markDatasetName" 
            },
            "orient": "top",
            "align": "center"
        },
        "scales": [
            {
            "name": "xScale",
            "type": "time",
            "domain": {
                "data": "modbusData",
                "field": "timestamp"
            },
            "domainRaw": {
                "signal": "xDetailZoom"
            },
            "range": [
                0,
                {
                "signal": "graphWidth"
                }
            ],
            "nice": true
            },
            {
            "name": "yScale",
            "type": "symlog",
            "domain": {
                "data": "modbusData",
                "field": "value"
            },
            "domainRaw": {
                "signal": "yDetailZoom"
            },
            "range": [
                {
                "signal": "upperHeight - 10"
                },
                10
            ],
            "nice": true
            }
        ],
        "axes": [
            {
            "scale": "xScale",
            "title": "Date & Time",
            "orient": "bottom",
            "format": "%m-%d-%Y %H:%M:%S:%L",
            "formatType": "time",
            "labelAngle": -30,
            "labelPadding": {
                "signal": "50 * paddingScale"
            },
            "labelFontSize": {
                "signal": "labelFontSize * 0.95"
            },
            "grid": true
            },
            {
            "scale": "yScale",
            "title": "Values",
            "orient": "left",
            // "labelSeparation": 100
            "labelOverlap": true
            }
        ],
        "legends": [
            {
            "title": "PLC Address",
            "stroke": "color",
            "fill": "color",
            "encode": {
                "symbols": {
                "name": "legendSymbol",
                "interactive": true,
                "update": {
                    "opacity": [
                    {
                        "test": "!length(data('selected')) || indata('selected', 'value', datum.value)",
                        "value": 0.7
                    },
                    {
                        "value": 0.15
                    }
                    ],
                    "cursor": {
                    "value": "pointer"
                    }
                }
                },
                "labels": {
                "name": "legendLabel",
                "interactive": true,
                "update": {
                    "opacity": [
                    {
                        "test": "!length(data('selected')) || indata('selected', 'value', datum.value)",
                        "value": 1
                    },
                    {
                        "value": 0.25
                    }
                    ],
                    "text": {
                    "signal": "'Address ' + datum.label"
                    },
                    "cursor": {
                    "value": "pointer"
                    }
                }
                }
            }
            }
        ],
        "marks": [
            {
            "type": "group",
            "clip": true,
            "encode": {
                "enter": {
                "height": {
                    "field": {
                    "group": "height"
                    }
                },
                "width": {
                    "field": {
                    "group": "width"
                    }
                }
                }
            },
            "from": {
                // Separate data points by addr for graphing
                "facet": {
                "name": "series",
                "data": "modbusData",
                "groupby": "addr"
                }
            },
            "marks": [
                {
                "type": "line",
                "name": "detailLine",
                "from": {
                    "data": "series"
                },
                "interactive": true,
                "encode": {
                    "update": {
                    "x": {
                        "scale": "xScale",
                        "field": "timestamp"
                    },
                    "y": {
                        "scale": "yScale",
                        "field": "value"
                    },
                    "interpolate": {
                        "signal": "interpolate"
                    },
                    "opacity": [
                        {
                        "test": "!length(data('selected')) || indata('selected', 'value', datum.addr)",
                        "value": 1
                        },
                        {
                        "value": 0.05
                        }
                    ],
                    "stroke": [
                        {
                        "test": "!length(data('selected')) || indata('selected', 'value', datum.addr)",
                        "scale": "color",
                        "field": "addr"
                        },
                        {
                        "value": "#ccc"
                        }
                    ],
                    "cursor": {
                        "value": "pointer"
                    }
                    }
                }
                },
                {
                "type": "symbol",
                "name": "infoDot",
                "from": {
                    "data": "series"
                },
                "encode": {
                    "update": {
                    "x": {
                        "scale": "xScale",
                        "field": "timestamp"
                    },
                    "y": {
                        "scale": "yScale",
                        "field": "value"
                    },
                    "interpolate": {
                        "signal": "interpolate"
                    },
                    "tooltip": {
                        "signal": "{ 'Dataset': datum.dataset, 'PLC IP:Port': datum.destIp + ':' + datum.destPort, 'Unit ID': datum.unitId, 'Address': datum.addr, 'Function': datum.func, 'Value': datum.value,  'Date/Time': timeFormat(datum.timestamp, '%b %d, %Y') + ' ' + timeFormat(datum.timestamp, '%H:%M:%S:%L %Z'), 'Event ID': join(datum.id) }"
                    },
                    "opacity": [
                        {
                        "test": "!length(data('selected')) || indata('selected', 'value', datum.addr)",
                        "value": 1
                        },
                        {
                        "value": 0.25
                        }
                    ],
                    "size":{
                        "value":100
                    },
                    "fill": [
                        {
                        "test": "!length(data('selected')) || indata('selected', 'value', datum.addr)",
                        "signal": "(datum.addr === hoveredTimestamp[0] && datum.timestamp === hoveredTimestamp[1]) ? 'orange' : scale('color', datum.addr)"
                        }
                    ],
                    "shape": [
                        {
                        "scale": "nodeShape",
                        "field": "dataType"
                        }
                    ]
                    }
                }
                }
            ]
            }
        ]
        },
        /****** START OVERVIEW GRAPH ******/
        {
        "type": "group",
        "name": "overview",
        "encode": {
            "enter": {
            "y": {
                "signal": "overviewGraphY"
            },
            "height": {
                "signal": "lowerHeight"
            },
            "width": {
                "signal": "graphWidth"
            },
            "fill": {
                "value": "transparent"
            },
            "cursor": {
                "value": "crosshair"
            }
            }
        },
        "title": {
            "text": "Overview Selection Graph",
            "orient": "bottom",
            "align": "center"
        },
        "signals": [
            // Holds click-drag coordinates
            {
            "name": "brush",
            "value": [
                0,
                0
            ],
            "on": [
                {
                "events": "@overview:pointerdown",
                "update": "[[x(), x()], [y('overview'), y('overview')]]"
                },
                {
                "events": "[@overview:pointerdown, window:pointerup] > @overview:pointermove!",
                "update": "[[brush[0][0], clamp(x(), 0, graphWidth)], [brush[1][0], clamp(y('overview'), -5, lowerHeight + 10)]]"
                // + 5 allows the selection to go slightly lower than the minimum value
                },
                {
                "events": {
                    "signal": "delta"
                },
                "update": "[clampRange([anchor[0][0] + delta[0], anchor[0][1] + delta[0]], 0, graphWidth), clampRange([anchor[1][0] + delta[1], anchor[1][1] + delta[1]], 0, lowerHeight + 5)]"
                }
            ]
            },
            {
            "name": "anchor",
            "value": null,
            "on": [
                {
                "events": "@brushRect:pointerdown",
                "update": "slice(brush)"
                }
            ]
            },
            {
            "name": "down",
            "value": [
                0,
                0
            ],
            "on": [
                {
                "events": "@brushRect:pointerdown",
                "update": "[x(), y('overview')]"
                }
            ]
            },
            {
            "name": "delta",
            "value": [
                0,
                0
            ],
            "on": [
                {
                "events": "[@brushRect:pointerdown, window:pointerup] > @brushRect:pointermove!",
                "update": "[x() - down[0],  y('overview') - down[1]]"
                }
            ]
            },
            // Calculates and pushes X scale outward
            {
            "name": "xDetailZoom",
            "push": "outer",
            "on": [
                {
                "events": {
                    "signal": "brush"
                },
                "update": "(span(brush[0]) ? invert('xOverview', brush[0]) : null)"
                }
            ]
            },
            // Calculates and pushes Y scale outward
            {
            "name": "yDetailZoom",
            "push": "outer",
            "on": [
                {
                "events": {
                    "signal": "brush"
                },
                "update": "(span(brush[1]) ? reverse(invert('yOverview', brush[1])) : null)"
                }
            ]
            }
        ],
        "scales": [
            {
            "name": "xOverview",
            "type": "time",
            "range": [
                0,
                {
                "signal": "graphWidth"
                }
            ],
            "nice": true,
            "domain": {
                "data": "modbusData",
                "field": "timestamp"
            }
            },
            {
            "name": "yOverview",
            "type": "symlog",
            "range": [
                {
                "signal": "lowerHeight"
                },
                10
            ],
            "nice": true,
            "domain": {
                "data": "modbusData",
                "field": "value"
            }
            }
        ],
        "axes": [
            {
            "scale": "xOverview",
            "orient": "bottom",
            "labels": false
            },
            {
            "scale": "yOverview",
            "orient": "left",
            "labels": false
            }
        ],
        "marks": [
            {
            "type": "group",
            "from": {
                "facet": {
                "name": "series",
                "data": "modbusData",
                "groupby": "addr"
                }
            },
            "marks": [
                {
                "type": "line",
                "interactive": false,
                "from": {
                    "data": "series"
                },
                "encode": {
                    "enter": {
                    "x": {
                        "scale": "xOverview",
                        "field": "timestamp"
                    },
                    "y": {
                        "scale": "yOverview",
                        "field": "value"
                    },
                    "interpolate": {
                        "signal": "interpolate"
                    }
                    },
                    "update": {
                    "opacity": [
                        {
                        "test": "!length(data('selected')) || indata('selected', 'value', datum.addr)",
                        "value": 1
                        },
                        {
                        "value": 0.25
                        }
                    ],
                    "stroke": [
                        {
                        "test": "!length(data('selected')) || indata('selected', 'value', datum.addr)",
                        "scale": "color",
                        "field": "addr"
                        },
                        {
                        "value": "#ccc"
                        }
                    ]
                    }
                }
                },
                {
                "type": "symbol",
                "name": "infoDot",
                "from": {
                    "data": "series"
                },
                "interactive": false,
                "encode": {
                    "enter": {
                    "x": {
                        "scale": "xOverview",
                        "field": "timestamp"
                    },
                    "y": {
                        "scale": "yOverview",
                        "field": "value"
                    },
                    "interpolate": {
                        "signal": "interpolate"
                    }
                    },
                    "update": {
                    "opacity": [
                        {
                        "test": "!length(data('selected')) || indata('selected', 'value', datum.addr)",
                        "value": 1
                        },
                        {
                        "value": 0.25
                        }
                    ],
                    "fill": [
                        {
                        "test": "!length(data('selected')) || indata('selected', 'value', datum.addr)",
                        "signal": "(datum.addr === hoveredTimestamp[0] && datum.timestamp === hoveredTimestamp[1]) ? 'orange' : scale('color', datum.addr)"
                        }
                    ],
                    "shape": [
                        {
                        "scale": "nodeShape",
                        "field": "dataType"
                        }
                    ]
                    }
                }
                },
                // Shows the selected points
                {
                "type": "rect",
                "name": "brushRect",
                "encode": {
                    "enter": {
                    "fill": {
                        "value": "#333"
                    },
                    "fillOpacity": {
                        "value": 0.2
                    }
                    },
                    "update": {
                    "x": {
                        "signal": "brush[0][0]"
                    },
                    "x2": {
                        "signal": "brush[0][1]"
                    },
                    "y": {
                        "signal": "brush[1][0]"
                    },
                    "y2": {
                        "signal": "brush[1][1]"
                    }
                    }
                }
                },
                {
                "type": "rule",
                "interactive": false,
                "encode": {
                    "enter": {
                    "y2": {
                        "signal": "lowerHeight + 10"
                    }
                    },
                    "update": {
                    "x": {
                        "signal": "brush[0][0]"
                    }
                    }
                }
                },
                {
                "type": "rule",
                "interactive": false,
                "encode": {
                    "enter": {
                    "y2": {
                        "signal": "lowerHeight + 10"
                    }
                    },
                    "update": {
                    "x": {
                        "signal": "brush[0][1]"
                    }
                    }
                }
                },
                {
                "type": "rule",
                "interactive": false,
                "encode": {
                    "enter": {
                    "x2": {
                        "signal": "graphWidth"
                    },
                    "y": {
                        "signal": "lowerHeight"
                    }
                    },
                    "update": {
                    "y": {
                        "signal": "brush[1][0]"
                    }
                    }
                }
                },
                {
                "type": "rule",
                "interactive": false,
                "encode": {
                    "enter": {
                    "x2": {
                        "signal": "graphWidth"
                    },
                    "y": {
                        "signal": "lowerHeight"
                    }
                    },
                    "update": {
                    "y": {
                        "signal": "brush[1][1]"
                    }
                    }
                }
                }
            ]
            }
        ]
        },
        /****** START IP SELECT TABLE ******/
        // We're doing a table since we can not (as of now) update binds dynamically
        {
        "type": "group",
        "name": "ipSelect",
        "signals": [
            {
            "name": "scrollBarWidth",
            "update": "ipsToDisplay < minIps ? 0 : 12"
            },
            {
            "name": "scrollbarFillOpacity",
            "value": 0.2,
            "on": [
                {
                "events": "@rect-scrollbar:mouseover",
                "update": "0.4"
                },
                {
                "events": "@rect-scrollbar:mouseout",
                "update": "0.2"
                }
            ]
            }
        ],
        "scales": [
            {
            "name": "yScale",
            "type": "band",
            "domain": {
                "data": "ipSlice",
                "field": "destIp",
                "sort": true
            },
            "range": [
                0,
                {
                "signal": "rowHeight * length(data('ipSlice'))"
                }
            ]
            }
        ],
        "marks": [
            {
            "type": "text",
            "encode": {
                "enter": {
                "text": {
                    "value": "IP Selection"
                },
                "width": {
                    "signal": "width - ipSelectX - 20"
                },
                "x": {
                    "signal": "ipSelectX"
                },
                "dy": {
                    "value": -5
                }
                }
            }
            },
            {
            "name": "rule-scrolltrack-1",
            "type": "rule",
            "encode": {
                "update": {
                "x": {
                    "signal": "width - scrollBarWidth - 2"
                },
                "x2": {
                    "signal": "width - scrollBarWidth - 2"
                },
                "y2": {
                    "signal": "ipsScrollAreaHeight"
                },
                "stroke": {
                    "value": "black"
                },
                "strokeWidth": {
                    "signal": "!scrollBarWidth ? 0 : 0.2"
                }
                }
            }
            },
            {
            "name": "rule-scrolltrack-2",
            "type": "rule",
            "encode": {
                "update": {
                "x": {
                    "signal": "width"
                },
                "x2": {
                    "signal": "width"
                },
                "y2": {
                    "signal": "ipsScrollAreaHeight"
                },
                "stroke": {
                    "value": "black"
                },
                "strokeWidth": {
                    "signal": "!scrollBarWidth ? 0 : 0.2"
                }
                }
            }
            },
            {
            "name": "rect-scrollbar",
            "type": "rect",
            "encode": {
                "update": {
                "x": {
                    "signal": "width - scrollBarWidth - 1"
                },
                "y": {
                    "scale": "ipsScaleScrollBarY",
                    "signal": "ipsScrollPosition"
                },
                "width": {
                    "signal": "scrollBarWidth"
                },
                "height": {
                    "signal": "ipsScrollBarHeight"
                },
                "fill": {
                    "value": "#666666"
                },
                "fillOpacity": {
                    "signal": "scrollbarFillOpacity"
                }
                }
            }
            },
            {
            "name": "destIps-rect-cell",
            "type": "rect",
            "from": {
                "data": "ipSlice"
            },
            "encode": {
                "update": {
                "x": {
                    "signal": "ipSelectX"
                },
                "x2": {
                    "signal": "width - scrollBarWidth - 3"
                },
                "y": {
                    "scale": "yScale",
                    "field": "destIp",
                    "band": 0
                },
                "cursor": {
                    "value": "pointer"
                },
                "height": {
                    "signal": "rowHeight"
                },
                "opacity": [
                    {
                    "test": "datum.destIp === selectedIp",
                    "value": 0.4
                    },
                    {
                    "value": 0.2
                    }
                ]
                }
            }
            },
            {
            "name": "destIps-text-content",
            "type": "text",
            "from": {
                "data": "ipSlice"
            },
            "encode": {
                "update": {
                "text": {
                    "signal": "datum.destIp"
                },
                "x": {
                    "signal": "ipSelectX"
                },
                "dx": {
                    "value": 5
                },
                "y": {
                    "scale": "yScale",
                    "field": "destIp",
                    "band": 0.5
                },
                "cursor": {
                    "value": "pointer"
                }
                }
            }
            }
        ]
        },
        /****** START UNIT SELECT TABLE ******/
        {
        "type": "group",
        "name": "unitSelect",
        "encode": {
            "update": {
            "y": {
                "signal": "unitSelectY"
            }
            }
        },
        "signals": [
            {
            "name": "scrollBarWidth",
            "update": "unitsToDisplay < minUnits ? 0 : 12"
            },
            {
            "name": "scrollbarFillOpacity",
            "value": 0.2,
            "on": [
                {
                "events": "@units-rect-scrollbar:mouseover",
                "update": "0.4"
                },
                {
                "events": "@units-rect-scrollbar:mouseout",
                "update": "0.2"
                }
            ]
            }
        ],
        "scales": [
            {
            "name": "yScale",
            "type": "band",
            "domain": {
                "data": "unitSlice",
                "field": "unitId",
                "sort": true
            },
            "range": [
                0,
                {
                "signal": "rowHeight * length(data('unitSlice'))"
                }
            ]
            }
        ],
        "marks": [
            {
            "type": "text",
            "encode": {
                "enter": {
                "text": {
                    "value": "Unit Selection"
                },
                "width": {
                    "signal": "width - ipSelectX - 20"
                },
                "x": {
                    "signal": "ipSelectX"
                },
                "dy": {
                    "value": -5
                }
                }
            }
            },
            {
            "name": "rule-scrolltrack-1",
            "type": "rule",
            "encode": {
                "update": {
                "x": {
                    "signal": "width - scrollBarWidth - 2"
                },
                "x2": {
                    "signal": "width - scrollBarWidth - 2"
                },
                "y": {
                    "field": {
                    "group": "y"
                    }
                },
                "y2": {
                    "signal": "unitsScrollAreaHeight"
                },
                "stroke": {
                    "value": "black"
                },
                "strokeWidth": {
                    "signal": "!scrollBarWidth ? 0 : 0.2"
                }
                }
            }
            },
            {
            "name": "rule-scrolltrack-2",
            "type": "rule",
            "encode": {
                "update": {
                "x": {
                    "signal": "width"
                },
                "x2": {
                    "signal": "width"
                },
                "y": {
                    "field": {
                    "group": "y"
                    }
                },
                "y2": {
                    "signal": "unitsScrollAreaHeight"
                },
                "stroke": {
                    "value": "black"
                },
                "strokeWidth": {
                    "signal": "!scrollBarWidth ? 0 : 0.2"
                }
                }
            }
            },
            {
            "name": "units-rect-scrollbar",
            "type": "rect",
            "encode": {
                "update": {
                "x": {
                    "signal": "width - scrollBarWidth - 1"
                },
                "y": {
                    "scale": "unitsScaleScrollBarY",
                    "signal": "unitsScrollPosition"
                },
                "width": {
                    "signal": "scrollBarWidth"
                },
                "height": {
                    "signal": "unitsScrollBarHeight"
                },
                "fill": {
                    "value": "#666666"
                },
                "fillOpacity": {
                    "signal": "scrollbarFillOpacity"
                }
                }
            }
            },
            {
            "name": "units-rect-cell",
            "type": "rect",
            "from": {
                "data": "unitSlice"
            },
            "encode": {
                "update": {
                "x": {
                    "signal": "ipSelectX"
                },
                "x2": {
                    "signal": "width - scrollBarWidth - 3"
                },
                "y": {
                    "scale": "yScale",
                    "field": "unitId",
                    "band": 0
                },
                "cursor": {
                    "value": "pointer"
                },
                "height": {
                    "signal": "rowHeight"
                },
                "opacity": [
                    {
                    "test": "datum.unitId === selectedUnit",
                    "value": 0.4
                    },
                    {
                    "value": 0.2
                    }
                ]
                }
            }
            },
            {
            "name": "units-text-content",
            "type": "text",
            "from": {
                "data": "unitSlice"
            },
            "encode": {
                "update": {
                "text": {
                    "signal": "datum.unitId"
                },
                "x": {
                    "signal": "ipSelectX"
                },
                "dx": {
                    "value": 5
                },
                "y": {
                    "scale": "yScale",
                    "field": "unitId",
                    "band": 0.5
                },
                "cursor": {
                    "value": "pointer"
                }
                }
            }
            }
        ]
        }
    ]
}
